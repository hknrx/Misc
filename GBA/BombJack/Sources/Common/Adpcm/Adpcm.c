/*
** Bomb Jack - Sources\Common\Adpcm\Adpcm.c
** Nicolas ROBERT [NRX] - Hong Kong 2005 / France 2006
*/

////////////////
// Inclusions //
////////////////
#include <stdlib.h>
#include "Adpcm.h"
#include "AdpcmTables.h"

////////////
// Macros //
////////////
#define FIFO ((volatile unsigned long*)0x040000A0)
#define DMA  ((volatile DMA_STRUCT*)0x040000BC)
#define TM   ((volatile TM_STRUCT*)0x04000100)

#define SOUNDCNT_L *(volatile unsigned short*)0x04000080
#define SOUNDCNT_H *(volatile unsigned short*)0x04000082
#define SOUNDCNT_X *(volatile unsigned short*)0x04000084

#define FREQUENCY_SYSTEM_CLOCK 16777216
#define FREQUENCY_VBLANK_1024  61161  // = 59.7275*1024
#define FREQUENCY_RATIO        280896 // = 16777216/59.7275
#define MAX_NUMBER_SAMPLES     (MAX_WAVE_FREQUENCY*1024/FREQUENCY_VBLANK_1024)

///////////
// Types //
///////////
typedef struct
{
   unsigned long SAD;
   unsigned long DAD;
   unsigned short CNT_L;
   unsigned short CNT_H;
}
DMA_STRUCT;

typedef struct
{
   unsigned short CNT_L;
   unsigned short CNT_H;
}
TM_STRUCT;

typedef struct
{
   const unsigned char* inputDataBegin;
   const unsigned char* inputDataCurrent;
   const unsigned char* inputDataEnd;
   unsigned short numberSamplesPerVbl;
   unsigned char noCompress;
   signed char repeat;

   signed char __attribute__ ((aligned(4))) outputData[2][(MAX_NUMBER_SAMPLES+8)&~15]; // It must be a multiple of 4*4 bytes
   signed long lastSample;
   signed short lastIndex;
   unsigned char outputBuffer;
   unsigned char volume;
}
AdpcmChannel;

typedef struct
{
   unsigned char numberChannels;
   AdpcmChannel* channel[2];
}
Adpcm;

////////////////////////
// Variables globales //
////////////////////////
Adpcm adpcm={0,{NULL,NULL}};

//////////////////////
// AdpcmSafeStopDma //
//////////////////////
static inline void AdpcmSafeStopDma(volatile DMA_STRUCT* dma)
{
   // Is the DMA currently enabled?
   if(dma->CNT_H&(1<<15))
   {
      // Is the "DMA Repeat" currently "ON"?
      if(dma->CNT_H&(1<<9))
      {
         // We must first apply the following settings to avoid problems
         dma->CNT_H=(1<<15)| // DMA Enable Flag = ON
                    (0<<12)| // DMA Start Timing Setting #0 => Start Immediately
                    (1<<10)| // DMA Transfer Type = 32-bit Transfer
                    (0<<9)|  // DMA Repeat = OFF
                    (0<<7)|  // Source Address Control Flag Setting #0 => Increment after Transfer
                    (2<<5);  // Destination Address Control Flag Setting #2 => Fixed

         // Wait a little bit before setting the DMA again
         asm volatile("nop\nnop\nnop\nnop"); // Delay of 4 clocks
      }

      // Disable the DMA
      dma->CNT_H=(0<<15)| // DMA Enable Flag = OFF
                 (0<<12)| // DMA Start Timing Setting #0 => Start Immediately
                 (1<<10)| // DMA Transfer Type = 32-bit Transfer
                 (0<<9)|  // DMA Repeat = OFF
                 (0<<7)|  // Source Address Control Flag Setting #0 => Increment after Transfer
                 (2<<5);  // Destination Address Control Flag Setting #2 => Fixed
   }
}

/////////////////////
// AdpcmSafeSetDma //
/////////////////////
static inline void AdpcmSafeSetDma(volatile DMA_STRUCT* dma,unsigned long sourceAddress)
{
   // First, safely stop the DMA
   AdpcmSafeStopDma(dma);

   // Wait a little bit before setting the DMA again
   asm volatile("nop\nnop\nnop\nnop"); // Delay of 4 clocks

   // Set the new parameters
   dma->SAD=sourceAddress;
   dma->CNT_H=(1<<15)| // DMA Enable Flag = ON
              (3<<12)| // DMA Startup Timing Setting #3 => Start When Request Generated by Direct-Sound FIFO
              (1<<10)| // DMA Transfer Type = 32-bit Transfer
              (1<<9)|  // DMA Repeat = ON (because of direct-sound FIFO transfer mode)
              (0<<7)|  // Source Address Control Flag Setting #0 => Increment after Transfer
              (2<<5);  // Destination Address Control Flag Setting #2 => Fixed
}

///////////////
// AdpcmInit //
///////////////
unsigned char AdpcmInit(unsigned char numberChannels)
{
   unsigned char channel;

   // Check that the number of requested channels is correct
   if(numberChannels<1 || numberChannels>2 || adpcm.numberChannels!=0)
      return(1);

   // Enable the sound processing (direct sound A & B)
   SOUNDCNT_X=(1<<7);  // All Sounds Operation Flag = Operate
   SOUNDCNT_L=0;       // Disable sounds 1~4...
   SOUNDCNT_H=(1<<2)|  // Output Ratio for Direct Sound A = Full Range
              (1<<3)|  // Output Ratio for Direct Sound B = Full Range
              (1<<8)|  // R Output of Direct Sound A = Output to R
              (1<<9)|  // L Output of Direct Sound A = Output to L
              (0<<10)| // Timer Selection for Direct Sound A = Timer 0
              (1<<11)| // Direct Sound FIFO A Clear and Sequencer Reset
              (1<<12)| // R Output of Direct Sound B = Output to R
              (1<<13)| // L Output of Direct Sound B = Output to L
              (1<<14)| // Timer Selection for Direct Sound B = Timer 1
              (1<<15); // Direct Sound FIFO B Clear and Sequencer Reset

   // Prepare the DMA, allocate the memory, and initialize the structure
   for(channel=0;channel<numberChannels;++channel)
   {
      DMA[channel].DAD=(unsigned long)&FIFO[channel];
      DMA[channel].CNT_L=4; // Word Count = 4, to later safely stop the DMA

      adpcm.channel[channel]=(AdpcmChannel*)malloc(sizeof(AdpcmChannel));
      adpcm.channel[channel]->inputDataBegin=NULL;
      adpcm.channel[channel]->repeat=0;
      adpcm.channel[channel]->volume=1<<7; // Normal volume
   }

   // Now that everything is ready, we can safely set the number of channels
   adpcm.numberChannels=numberChannels;

   // It looks ok!
   return(0);
}

//////////////////
// AdpcmDestroy //
//////////////////
void AdpcmDestroy(void)
{
   unsigned char channel;

   // Really disable the sound processing
   SOUNDCNT_X=(0<<7); // All Sounds Operation Flag = Halt

   // Stop the sound of each channel immediately, and free the memory allocated
   for(channel=0;channel<adpcm.numberChannels;++channel)
   {
      AdpcmSafeStopDma(&DMA[channel]);
      TM[channel].CNT_H=(0<<7); // Timer Operation Flag = Disable
      free(adpcm.channel[channel]);
   }
}

////////////////
// AdpcmStart //
////////////////
unsigned char AdpcmStart(unsigned char channel,const AdpcmSound* sound,signed char repeat)
{
   unsigned short index;
   AdpcmChannel* channelPointer;
   unsigned short numberSamplesPerVbl;
   unsigned short timerDuration;

   // Check the channel
   if(channel>=adpcm.numberChannels)
      return(1);

   // Check the "magic"
   for(index=0;index<sizeof(ADPCM_MAGIC);++index)
      if(sound->magic[index]!=ADPCM_MAGIC[index])
         return(1);

   // Check the sample rate
   if(!sound->noCompress && sound->sampleRate>MAX_WAVE_FREQUENCY)
      return(1);

   // Reset the "repeat" now to avoid problems if the VBL occurs during the following instructions
   channelPointer=adpcm.channel[channel];
   channelPointer->repeat=0;

   // Stop any sound currently playing on this channel
   AdpcmSafeStopDma(&DMA[channel]);
   TM[channel].CNT_H=(0<<7); // Timer Operation Flag = Disable

   // Compute the number of samples per VBL and the duration of the timer
   numberSamplesPerVbl=(((sound->sampleRate<<10)/FREQUENCY_VBLANK_1024)+8)&~15; // It must be a multiple of 4*4 bytes
   timerDuration=FREQUENCY_RATIO/numberSamplesPerVbl;

   // Initialize the Adpcm structure
   channelPointer->inputDataBegin=sound->data;
   channelPointer->inputDataCurrent=sound->data;
   channelPointer->inputDataEnd=sound->data+sound->length;
   channelPointer->numberSamplesPerVbl=numberSamplesPerVbl;
   channelPointer->noCompress=sound->noCompress;

   if(!sound->noCompress)
   {
      channelPointer->lastSample=0;
      channelPointer->lastIndex=0;
      channelPointer->outputBuffer=0;
   }

   // Prepare the timer
   TM[channel].CNT_L=65535-timerDuration; // Timer Setting (timer overflow) => we get the wave file frequency

   // Set the "repeat" so that the sound will be activated during the next VBL
   channelPointer->repeat=repeat;

   // It looks ok!
   return(0);
}

///////////////
// AdpcmStop //
///////////////
unsigned char AdpcmStop(unsigned char channel)
{
   // Check the channel
   if(channel>=adpcm.numberChannels)
      return(1);

   // Stop the sound (it will actually be stopped during the next VBL)
   adpcm.channel[channel]->repeat=0;
   return(0);
}

///////////////////
// AdpcmGetSound //
///////////////////
const AdpcmSound* AdpcmGetSound(unsigned char channel)
{
   const unsigned char* inputDataBegin;

   // Check the channel
   if(channel>=adpcm.numberChannels)
      return(NULL);

   // Check a sound has been "registered" for this channel
   inputDataBegin=adpcm.channel[channel]->inputDataBegin;
   if(!inputDataBegin)
      return(NULL);

   // Return a pointer to the sound that is currently "registered" for this channel
   return((const AdpcmSound*)((unsigned long)inputDataBegin-sizeof(AdpcmSound)));
}

////////////////////
// AdpcmGetRepeat //
////////////////////
signed char AdpcmGetRepeat(unsigned char channel)
{
   // Check the channel
   if(channel>=adpcm.numberChannels)
      return(0);

   // Return the current value of "repeat" for this channel
   return(adpcm.channel[channel]->repeat);
}

////////////////////
// AdpcmSetVolume //
////////////////////
unsigned char AdpcmSetVolume(unsigned char channel,unsigned char volume)
{
   // Check the channel
   if(channel>=adpcm.numberChannels)
      return(1);

   // Set the volume
   adpcm.channel[channel]->volume=volume;
   return(0);
}

////////////////////
// AdpcmGetVolume //
////////////////////
unsigned char AdpcmGetVolume(unsigned char channel)
{
   // Check the channel
   if(channel>=adpcm.numberChannels)
      return(0);

   // Return the current value of "volume" for this channel
   return(adpcm.channel[channel]->volume);
}

////////////////////
// AdpcmDecodeVbl //
////////////////////
void __attribute__ ((section(".iwram"),long_call)) AdpcmDecodeVbl(unsigned char channel)
{
   AdpcmChannel* channelPointer;
   const unsigned char* inputDataCurrent;
   signed char* outputData;
   signed long sample;
   signed short index;
   signed short step;
   unsigned char byte;
   unsigned char code;
   signed short diff;
   unsigned short counter;
   unsigned char volume;

   // Check the channel
   if(channel>=adpcm.numberChannels)
      return;
   channelPointer=adpcm.channel[channel];

   // Anything to do?
   if(!channelPointer->repeat)
   {
      // No sound...
      AdpcmSafeStopDma(&DMA[channel]);
      TM[channel].CNT_H=(0<<7); // Timer Operation Flag = Disable
      return;
   }

   // Is it a simple (uncompressed) wave file?
   if(channelPointer->noCompress)
   {
      // Is it the beginning of the sound?
      if(channelPointer->inputDataCurrent==channelPointer->inputDataBegin)
         code=1;
      else
         code=0;

      // Or maybe its end?
      channelPointer->inputDataCurrent+=channelPointer->numberSamplesPerVbl;
      if(channelPointer->inputDataCurrent>=channelPointer->inputDataEnd)
      {
         if(channelPointer->repeat==-1 || --channelPointer->repeat)
         {
            // Prepare to restart the sound
            channelPointer->inputDataCurrent=channelPointer->inputDataBegin;
            code=1;
         }
         else
         {
            // Stop it now (we cannot wait for the next VBL!)
            AdpcmSafeStopDma(&DMA[channel]);
            TM[channel].CNT_H=(0<<7); // Timer Operation Flag = Disable
            return;
         }
      }

      // Start the sound
      if(code)
      {
         // Set the DMA
         AdpcmSafeSetDma(&DMA[channel],(unsigned long)channelPointer->inputDataBegin);

         // Enable the timer
         TM[channel].CNT_H=(0<<0)| // Prescalar Selection Setting #0 => System clock (16.78MHz)
                           (1<<7); // Timer Operation Flag = Enable
      }
      return;
   }

   // Retrieve the previous data
   inputDataCurrent=channelPointer->inputDataCurrent;
   sample=channelPointer->lastSample;
   index=channelPointer->lastIndex;

   // Get the volume
   volume=channelPointer->volume;

   // Here is the pointer to the output buffer
   outputData=channelPointer->outputData[channelPointer->outputBuffer];

   // Process the samples
   byte=0;
   for(counter=channelPointer->numberSamplesPerVbl;counter;--counter)
   {
      // Get the code
      if(counter&1)
      {
         code=byte>>4;

         // Check if it's finished
         if(inputDataCurrent>=channelPointer->inputDataEnd)
         {
            if(channelPointer->repeat==-1 || --channelPointer->repeat)
            {
               // We go back to the beginning
               inputDataCurrent=channelPointer->inputDataBegin;
               sample=0;
               index=0;
            }
            else
            {
               // Decoding is finished; we fill the end of the output buffer with 0...
               while(counter--)
                  *outputData++=0;
               break;
            }
         }
      }
      else
      {
         byte=*inputDataCurrent++;
         code=byte&0x0F;
      }

      // Get the step
      step=adpcmStep[index];

      // Modify the existing sample
      diff=step>>3;
      if(code&1)
         diff+=step>>2;
      if(code&2)
         diff+=step>>1;
      if(code&4)
         diff+=step;
      if(code&8)
      {
         sample-=diff;
         if(sample<-32768)
            sample=-32768;
      }
      else
      {
         sample+=diff;
         if(sample>32767)
            sample=32767;
      }

      // Compute the next index
      index+=adpcmModifyIndex[code];
      if(index<0)
         index=0;
      else if(index>88)
         index=88;

      // Store the new sample (8 bits only, it's just a GBA!)
      *outputData++=(sample*volume)>>(8+7);
   }

   // Store the current data
   channelPointer->inputDataCurrent=inputDataCurrent;
   channelPointer->lastSample=sample;
   channelPointer->lastIndex=index;

   // Set the DMA
   AdpcmSafeSetDma(&DMA[channel],(unsigned long)channelPointer->outputData[channelPointer->outputBuffer]);

   // Enable the timer (even if it has already been enabled ;-)
   TM[channel].CNT_H=(0<<0)| // Prescalar Selection Setting #0 => System clock (16.78MHz)
                     (1<<7); // Timer Operation Flag = Enable

   // Swap the output buffers
   channelPointer->outputBuffer^=1;
}
