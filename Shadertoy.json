{
 "userName": "Nrx",
 "date": "2021-06-15T16:24:21.583Z",
 "numShaders": 54,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "XdBGDd",
    "date": "1394949601",
    "viewed": 2473,
    "name": "Love Tunnel",
    "description": "Greetings everyone! :)\n\nThis is the result of my very first experiment with shaders and ray marching. Nothing really amazing, but I hope you like it though :).",
    "likes": 29,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "tunnel"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGRr",
       "filepath": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdXGzr",
       "filepath": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define FLOW\n#define RAY_LENGTH_MAX\t\t50.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (0.5, 0.0, -2.0)\n#define AMBIENT\t\t\t\t0.5\n#define SPECULAR_POWER\t\t4.0\n#define SPECULAR_INTENSITY\t0.2\n#define FADE_POWER\t\t\t3.0\n#define GAMMA\t\t\t\t(1.0 / 2.2)\n#define HSV2RGB_FAST\n#define TEXTURE_SCALE\t\t0.4\n\n// Constants\n#define PI\t\t3.14159265359\n#define DELTA\t0.01\n\nvec3 vRotateZ (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x + s * p.y, c * p.y - s * p.x, p.z);\n}\n\nfloat sphere (in vec3 p, in float r) {\n\treturn length (p) - r;\n}\n\nfloat box (in vec3 p, in vec3 b, in float r) {\n\t#ifdef BOX_NEGATIVE\n\tvec3 d = abs (p) - b + r;\n\treturn min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0)) - r;\n\t#else\n\treturn length (max (abs (p) - b + r, 0.0)) - r;\n\t#endif\n}\n\nfloat torusZ (in vec3 p, in float r1, in float r2) {\n\tvec2 q = vec2 (length (p.xy) - r1, p.z);\n\treturn length (q) - r2;\n}\n\nfloat cylinderZ (in vec3 p, in float r) {\n \treturn length (p.xy) - r;\n}\n\nvec3 twistZ (in vec3 p, in float k, in float angle) {\n\treturn vRotateZ (p, angle + k * p.z);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p, out vec4 q) {\n\n\t// Global deformation\n\tp += vec3 (2.0 * sin (p.z * 0.2 + iTime * 2.0), sin (p.z * 0.1 + iTime), 0.0);\n\n\t// Cylinder\n\tq.xyz = p;\n\tq.w = -1.0;\n\tfloat d = fixDistance (-cylinderZ (q.xyz, 4.0) + 0.5 * sin (atan (q.y, q.x) * 6.0) * sin (q.z), 0.4, 0.8);\n\n\t// Twisted boxes\n\tvec3 q_;\n\tq_.xy = mod (p.xy, 5.0) - 0.5 * 5.0;\n\tq_.z = mod (p.z, 12.0) - 0.5 * 12.0;\t\n\tq_ = twistZ (q_, 1.0, iTime);\n\tfloat d_ = fixDistance (box (q_, vec3 (0.6, 0.6, 1.5), 0.3), 0.4, 0.8);\n\tif (d_ < d) {\n\t\tq.xyz = q_;\n\t\td = d_;\n\t}\n\n\t// Rotating spheres\n\tq_ = p;\n\tq_.z += 12.0;\n\tq_ = vRotateZ (q_, sin (iTime * 4.0));\n\tq_.xy = mod (q_.xy, 4.5) - 0.5 * 4.5;\n\tq_.z = mod (q_.z, 24.0) - 0.5 * 24.0;\n\td_ = sphere (q_, 0.5);\n\tif (d_ < d) {\n\t\tq.xyz = q_;\n\t\td = d_;\n\t}\n\n\t// Torus\n\tq_ = p;\n\tq_.z = mod (q_.z + 12.0, 24.0) - 0.5 * 24.0;\n\td_ = torusZ (q_, 3.5, 0.4);\n\tif (d_ < d) {\n\t\tq.xyz = q_;\n\t\td = d_;\n\t}\n\n\t// Flow of boxes and spheres\n\t#ifdef FLOW\n\tq_ = p;\n\tq_.z += iTime * 20.0;\n\tconst float spacing = 0.5;\n\tconst float stepCount = 3.0;\n\tconst float period = spacing * stepCount;\n\tfor (float step = 0.0; step < stepCount; ++step) {\n\t\tfloat k1 = floor (q_.z / period + 0.5);\n \t\tfloat k2 = k1 * stepCount + step;\n\t\tvec3 qq = q_ - vec3 (0.4 * sin (k2), 0.4 * sin (k2 * 13.0), period * k1);\n\t\tif (mod (k2, 2.0) > 0.5) {\n\t\t\td_ = box (vRotateZ (qq, k2), vec3 (0.08), 0.01);\n\t\t} else {\n\t\t\td_ = sphere (qq, 0.08);\n\t\t}\n\t\tif (d_ < d) {\n\t\t\tq.xyz = qq;\n\t\t\tq.w = 1.0;\n\t\t\td = d_;\n\t\t}\n\t\tq_.z += spacing;\n\t}\n\t#endif\n\n\t// Final distance\n\treturn d;\n}\n\nvec3 getNormal (in vec3 p) {\n\tvec4 q;\n\tconst vec2 h = vec2 (DELTA, 0.0);\n\treturn normalize (vec3 (\n\t\tgetDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),\n\t\tgetDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),\n\t\tgetDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)\n\t));\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 (0.0, 0.0, iTime * 6.0);\n\tvec3 forward = vec3 (0.2 * cos (iTime), 0.2 * sin (iTime), cos (iTime * 0.3));\n\tvec3 up = vRotateZ (vec3 (0.0, 1.0, 0.0), PI * sin (iTime) * sin (iTime * 0.2));\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Ray marching\n\tvec3 p = origin;\n\tvec4 q;\n\tfloat rayLength = 0.0;\n\tint rayStepCounter = 0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = getDistance (p, q);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp += dist * direction;\n\t\t++rayStepCounter;\n\t}\n\n\t// Compute the fragment color\n\tvec3 color;\n\tfloat bass = texture (iChannel0, vec2 (0.0)).x;\n\tif (rayLength > RAY_LENGTH_MAX) {\n\t\tcolor = vec3 (0.0);\n\t} else {\n\n\t\t// Object color\n\t\tvec3 normal = getNormal (p);\n\t\tfloat hue = (p.z + iTime) * 0.1;\n\t\tif (q.w < 0.0) {\n\t\t\t#ifdef TEXTURE_SCALE\n\t\t\tvec3 textureUV = q.xyz * TEXTURE_SCALE;\n\t\t\tvec3 textureFactor = abs (normal);\n\t\t\tmat3 textureColor = mat3 (\n\t\t\t\ttexture (iChannel1, textureUV.yz).rgb,\n\t\t\t\ttexture (iChannel1, textureUV.zx).rgb,\n\t\t\t\ttexture (iChannel1, textureUV.xy).rgb\n\t\t\t\t);\n\t\t\tcolor = hsv2rgb (vec3 (hue, 1.0, 1.0));\n\t\t\tcolor *= textureColor * textureFactor / (textureFactor.x + textureFactor.y + textureFactor.z);\n\t\t\t#else\n\t\t\tfloat treble = texture (iChannel0, vec2 (0.8, 0.0)).x;\n\t\t\tfloat saturation = 0.8 + (0.2 + 0.8 * treble) * 0.4 * sin (q.x * 10.0) * sin (q.y * 10.0) * sin (q.z * 10.0);\n\t\t\tfloat value = 0.2 + 0.8 * bass;\n\t\t\tcolor = hsv2rgb (vec3 (hue, saturation, value));\n\t\t\t#endif\n\t\t} else {\n\t\t\tcolor = hsv2rgb (vec3 (hue, 1.0, 1.0));\n\t\t}\n\n\t\t// Lighting\n\t\tvec3 lightDirection = normalize (LIGHT);\n\t\tvec3 reflectDirection = reflect (direction, normal);\n\t\tfloat diffuse = max (0.0, dot (normal, lightDirection));\n\t\tfloat specular = pow (max (0.0, dot (reflectDirection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\t\tcolor = ((AMBIENT + diffuse) * color + specular) * fade;\n\n\t\t// Special effect\n\t\tcolor *= max (1.0, 10.0 * sin (p.z * 0.1 - iTime * 4.0) - 7.0);\n\n\t\t// Gamma correction\n\t\tcolor = pow (color, vec3 (GAMMA));\n\t}\n\n\t// Another special effect\n\tcolor.r = mix (color.r, float (rayStepCounter) / float (RAY_STEP_MAX / 2), bass * bass);\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Msj3Wt",
    "date": "1395302262",
    "viewed": 656,
    "name": "Dragoon",
    "description": "Just a very basic shader, but which I found the result to be \"interesting\".",
    "likes": 17,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define DELTA\t\t\t0.01\n#define RAY_LENGTH_MAX\t300.0\n#define RAY_STEP_MAX\t200\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p) {\n\tp += vec3 (3.0 * sin (p.z * 0.2 + iTime * 2.0), sin (p.z * 0.3 + iTime), 0.0);\n\treturn fixDistance (length (p.xy) - 4.0 + 0.8 * sin (abs (p.x * p.y) + p.z * 4.0) * sin (p.z), 2.5, 0.2);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((17.0 + 5.0 * sin (iTime)) * cos (iTime * 0.2), 12.0 * sin (iTime * 0.2), 0.0);\n\tvec3 forward = vec3 (-origin.x, -origin.y, 22.0 + 6.0 * cos (iTime * 0.2));\n\tvec3 up = vec3 (0.0, 1.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Ray marching\n\tvec3 p = origin;\n\tfloat dist = RAY_LENGTH_MAX;\n\tfloat rayLength = 0.0;\n\tint stepCount = 0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (p);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = origin + direction * rayLength;\n\t\t++stepCount;\n\t}\n\n\t// Compute the fragment color\n\tvec4 color = vec4 (float (stepCount * 3) / float (RAY_STEP_MAX), float (stepCount) * 1.5 / float (RAY_STEP_MAX), 0.0, 1.0);\n\tvec3 LIGHT = normalize (vec3 (1.0, -3.0, -1.0));\n\tif (dist < DELTA) {\n\t\tvec2 h = vec2 (DELTA, 0.0);\n\t\tvec3 normal = normalize (vec3 (\n\t\t\tgetDistance (p + h.xyy) - getDistance (p - h.xyy),\n\t\t\tgetDistance (p + h.yxy) - getDistance (p - h.yxy),\n\t\t\tgetDistance (p + h.yyx) - getDistance (p - h.yyx)));\n\t\tcolor.rg += 0.5 * max (0.0, dot (normal, LIGHT));\n\t}\n\telse {\n\t\tcolor.b += 0.1 + 0.5 * max (0.0, dot (-direction, LIGHT));\n\t}\n\tfragColor = color;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Ms2GWd",
    "date": "1395399997",
    "viewed": 1426,
    "name": "Mysterious Octopus",
    "description": "Just wanted to play with deformation of the primitives (here: the tentacles).",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define DELTA\t\t\t\t0.02\n#define RAY_LENGTH_MAX\t\t150.0\n#define RAY_STEP_MAX\t\t200\n#define AMBIENT\t\t\t\t0.3\n#define SPECULAR_POWER\t\t5.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t3.0\n#define GAMMA\t\t\t\t0.8\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n//#define ATAN2 // Comment this to use the original atan function\n#define SHADOW\n\nvec3 vRotateX (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat smin (float a, float b, float k) {\n\n\t// From http://www.iquilezles.org/www/articles/smin/smin.htm\n\tfloat h = clamp (0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix (b, a, h) - k * h * (1.0 - h);\n}\n\n#ifndef ATAN2\n#define atan2 atan\n#else\nfloat atan2 (float y, float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_bis (float y, float x) {\n\n\t// From http://http.developer.nvidia.com/Cg/atan2.html\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tfloat t4 = t3 * t3;\n\tfloat t5 = -0.013480470;\n\tt5 = t5 * t4 + 0.057477314;\n\tt5 = t5 * t4 - 0.121239071;\n\tt5 = t5 * t4 + 0.195635925;\n\tt5 = t5 * t4 - 0.332994597;\n\tt5 = t5 * t4 + 0.999995630;\n\tt3 = t5 * t3;\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_ter (float y, float x) {\n\n\t// From http://rc0rc0.wordpress.com/2013/06/05/minimax-approximation-to-arctan-atan-atan2/\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = 0.97239 * t3 - 0.19195 * t3 * t3 * t3;\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n#endif\n\nfloat getDistance (in vec3 p) {\n\tfloat k = 0.2 + 0.2 * sin (p.y * 2.0 + iTime * 3.0);\n\tvec3 pp = p;\n\tpp.z *= 1.2;\n\tfloat body = length (pp) + k - 4.5;\n\tbody = fixDistance (body, 2.0, 0.8);\n\n\tp.y += 1.0;\n\tfloat angle = 2.0 * M_PI / 8.0;\n\tpp = vRotateY (p, -angle * 0.5);\n\tangle *= floor (atan2 (pp.x, pp.z) / angle);\n\tp = vRotateY (p, angle);\n\tp.xy /= min (1.1, 40.0 / p.z);\n\tk = clamp (p.z - 5.0, 0.0, 0.5);\n\tp = vRotateX (p, p.z * (0.01 + 0.01 * sin (iTime * 0.5 + angle * 5.0)) + 0.1 * sin (p.z * 0.3 + iTime + angle * 3.0));\n\tp = vRotateY (p, 0.1 * sin (p.z * 0.2 + iTime * 2.0 + angle * 7.0));\n\tp.z = sin (p.z * 2.0) / 2.0;\n\tfloat tentacle = length (p) - 1.0 - k * sin (abs (p.x * p.y * p.y* p.y + p.z));\n\ttentacle = fixDistance (tentacle, 60.0, 0.15);\n\n\treturn smin (body, tentacle, 0.2);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Old monitor effect\n\tvec2 frag = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tfloat round = pow (length (frag * frag), 6.0);\n\tfrag.y *= 1.0 + round * 0.2;\n\tvec3 colorMonitor = vec3 (1.0 - round);\n\tcolorMonitor *= vec3 (0.8, 1.0 + abs (mod (frag.y, 0.04) / 0.04 - 0.5), 0.8);\n\n\t// Define the ray corresponding to this fragment\n\tfrag.x *= iResolution.x / iResolution.y;\n\tfrag.x += 0.01 * sin (frag.y * 40.0 + iTime);\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((50.0 * cos (iTime * 0.1)), -3.0 + 10.0 * sin (iTime * 0.2), -35.0 + 20.0 * sin (iTime * 0.3));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (0.0, 1.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Ray marching\n\tvec3 p = origin;\n\tfloat dist = RAY_LENGTH_MAX;\n\tfloat rayLength = 0.0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (p);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = origin + direction * rayLength;\n\t}\n\n\t// Compute the background color\n\tvec3 lightDirection = normalize (vec3 (2.0, sin (iTime), -2.0));\n\tvec3 finalColor = vec3 (0.1, 0.2, 0.2 + 0.3 * max (0.0, dot (-direction, lightDirection)));\n\tif (dist < DELTA) {\n\n\t\t// Define the color of the octopus\n\t\tvec3 color = vec3 (0.3, 0.1, 0.2);\n\n\t\t// Initialize the lighting\n\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\t\tfloat diffuse = 0.0;\n\t\tfloat specular = 0.0;\n\n\t\t#ifdef SHADOW\n\t\t// Ray march again to check whether the light is visible\n\t\tdist = RAY_LENGTH_MAX;\n\t\trayLength = DELTA * 10.0;;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tvec3 pp = p + lightDirection * rayLength;\n\t\t\tdist = getDistance (pp);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dist >= DELTA)\n\t\t#endif\n\t\t{\n\t\t\t// Get the normal\n\t\t\tvec2 h = vec2 (DELTA, 0.0);\n\t\t\tvec3 normal = normalize (vec3 (\n\t\t\t\tgetDistance (p + h.xyy) - getDistance (p - h.xyy),\n\t\t\t\tgetDistance (p + h.yxy) - getDistance (p - h.yxy),\n\t\t\t\tgetDistance (p + h.yyx) - getDistance (p - h.yyx)));\n\n\t\t\t// Lighting\n\t\t\tdiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tspecular = pow (max (0.0, dot (reflect (direction, normal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t}\n\n\t\t// Compute the final color\n\t\tfinalColor = mix (finalColor, (AMBIENT + diffuse) * color + specular, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = pow (finalColor, vec3 (GAMMA));\n\tfragColor = vec4 (finalColor * colorMonitor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ldfXzn",
    "date": "1395743430",
    "viewed": 2012,
    "name": "Diamonds are Forever",
    "description": "A bunch of diamonds. Just because a friend asked me :).",
    "likes": 39,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "transparency"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t5\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.2 // 2.417 for real diamonds... but it would require RAY_COUNT to be increased (because of total internal reflections)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t0.5\n#define LUMINOSITY_FACTOR\t2.0\n\n//#define ATAN2 // Comment this to use the original atan function\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n#ifndef ATAN2\n#define atan2 atan\n#else\nfloat atan2 (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_nobranch (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tfloat t4 = M_PI / 2.0 - t3;\n\tt3 = step (0.0, t2 - t1) * (t3 - t4) + t4;\n\tt4 = M_PI - t3;\n\tt3 = step (0.0, x) * (t3 - t4) + t4;\n\tt3 = step (0.0, y) * (t3 + t3) - t3;\n\treturn t3;\n}\n#endif\n\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.8));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.6));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 2.0));\nvec3 k;\nfloat getDistance (in vec3 p) {\n\tfloat repeat = 20.0;\n\tvec3 q = p + repeat * 0.5;\n\tk = floor (q / repeat);\n\tq -= repeat * (k + 0.5);\n\tp = mRotate (k + iTime) * q;\n\n\tfloat topCut = p.y - 1.1;\n\tfloat angleStep = M_PI / max (1.0, abs (4.0 + k.x + 2.0 * k.y + 4.0 * k.z));\n\tfloat angle = angleStep * (0.5 + floor (atan2 (p.x, p.z) / angleStep));\n\tq = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat bottomA = dot (q, normalBottomA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.8;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan2 (q.x, q.z) / angleStep);\n\tq = vRotateY (p, angle);\n\tfloat bottomB = dot (q, normalBottomB) - 1.95;\n\tfloat topB = dot (q, normalTopB) - 1.92;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XdlSRr",
    "date": "1395909642",
    "viewed": 721,
    "name": "Simple Voronoi",
    "description": "Not much to say: it's a basic Voronoi diagram...",
    "likes": 19,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voronoi"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Concept from: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// Relation between the \"HASH_MAGNITUDE\" (M) and \"KERNEL\" (K):\n// - In a given cell C1, the greatest distance from a point P1 of this cell to the cell's reference point R1 is D:\n//   D = SQRT2 * (M / 2 + 1 / 2)\n//   D = (M + 1) * SQRT2 / 2\n//   (This happens when P1 is in a corner of C1, and R1 is as far as possible in the opposite direction.)\n// - So, the farther other reference point R2 that can be closer to P1 is somewhere on the circle of center P1 and radius D.\n// - The center of the cell C2 which the reference point is R2 is maximum at a distance M / 2 from R2.\n// - The relative position of the center of C2 compare to C1 is K:\n//   K = floor (1 / 2 + sqrt ((D + M / 2) ^ 2 - (1 / 2) ^ 2))\n//   K = floor ((1 + sqrt (((M + 1) * SQRT2 + M) ^ 2 - 1)) / 2)\n// - If we neglect \"- 1\" in the square root, we can approximate K:\n//   K = floor ((1 + (M + 1) * SQRT2 + M) / 2)\n//   K = floor ((M + 1) * (SQRT2 + 1) / 2)\n// - Reciprocally, if we set K, we can compute the maximum value of M:\n//   M < 2 * (K + 1) / (SQRT2 + 1) - 1\n// Having said that, you can actually use greater values for M without too much risk, as the relations given here above are just for the worst case (i.e. theoretical).\n\n#define SQRT2\t1.41421356237\n#define SQRT3\t1.73205080757\n\n#define SIZE \t\t\t15\n#define HASH_MAGNITUDE\t(6.0 / (SQRT2 + 1.0) - 1.0) // Perfect if: HASH_MAGNITUDE < 2 * (KERNEL + 1) / (SQRT2 + 1) - 1\n#define KERNEL\t\t\t2 // Perfect if: KERNEL >= floor ((HASH_MAGNITUDE + 1) * (SQRT2 + 1) / 2)\n\n#define BORDER\n//#define CENTER\n#define DISTANCE\n#define STRIPS\n#define HEXAGONAL\n\nfloat hash (in int index) {\n\tfloat x = float (index);\n\treturn HASH_MAGNITUDE * 0.5 * sin (sin (x) * x + sin (x * x) * iTime);\n}\n\nvec2 pointInCell (in ivec2 cell) {\n\tint index = cell.x + cell.y * SIZE;\n\tvec2 point = vec2 (cell);\n\t#ifdef HEXAGONAL\n\tpoint.x += fract (point.y * 0.5) - 0.25;\n\t#endif\n\treturn point + vec2 (hash (index), hash (index + 1)) * (0.5 + 0.5 * sin (iTime * 0.5));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = float (SIZE) * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t#ifdef HEXAGONAL\n\tp.y /= SQRT3 * 0.5;\n\t#endif\n\tivec2 pCell = ivec2 (floor (p + 0.5));\n\n\tfloat dMin = HASH_MAGNITUDE + 1.0;\n\tvec2 pqMin;\n\tivec2 minCell;\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t#ifdef HEXAGONAL\n\t\t\tpq.y *= SQRT3 * 0.5;\n\t\t\t#endif\n\t\t\tfloat d = dot (pq, pq);\n\t\t\tif (d < dMin) {\n\t\t\t\tdMin = d;\n\t\t\t\tpqMin = pq;\n\t\t\t\tminCell = qCell;\n\t\t\t}\n\t\t}\n\t}\n\tint col = minCell.x + minCell.y * SIZE;\n\tvec4 color = 0.6 + vec4 (hash (col), hash (col + 1), hash (col + 2), 0.0) * 0.8 / HASH_MAGNITUDE;\n\n\t#ifdef CENTER\n\tdMin = sqrt (dMin);\n\t#else\n\tdMin = HASH_MAGNITUDE + 1.0;\n\t#endif\n\n\t#ifdef BORDER\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tif (qCell != minCell) {\n\t\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t\t#ifdef HEXAGONAL\n\t\t\t\tpq.y *= SQRT3 * 0.5;\n\t\t\t\t#endif\n\t\t\t\tdMin = min (dMin, dot (0.5 * (pqMin + pq), normalize (pq - pqMin)));\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\n\tcolor *= smoothstep (0.02, 0.1, dMin);\n\n\t#ifdef DISTANCE\n\tcolor *= 0.9 + 0.1 * sin (dMin * 40.0);\n\t#endif\n\n\t#ifdef STRIPS\n\tfloat strip = float (col);\n\tfloat stripCos = cos (strip);\n\tfloat stripSin = sin (strip);\n\tstrip = mix (1.0, sin (40.0 * (pqMin.x * stripCos - pqMin.y * stripSin)), mod (strip * 0.5, 2.0));\n\tstrip *= sin (40.0 * (pqMin.x * stripSin + pqMin.y * stripCos));\n\tcolor *= 0.8 + 0.2 * strip;\n\t#endif\n\n\tfragColor = color;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lsXXz8",
    "date": "1396527232",
    "viewed": 324,
    "name": "Little test",
    "description": "Just a little test...",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t50.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (0.5, 0.75, 1.0)\n#define BACK_COLOR\t\t\tvec3 (0.25, 0.5, 1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t4.0\n#define SPECULAR_INTENSITY\t0.5\n#define REFLECT_COUNT\t\t2\n#define FADE_POWER\t\t\t2.0\n#define GAMMA\t\t\t\t(1.0 / 2.2)\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define SHADOW\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\nfloat sphere (in vec3 p, in float r) {\n\treturn length (p) - r;\n}\n\nfloat box (in vec3 p, in vec3 b, in float r) {\n\treturn length (max (abs (p) - b + r, 0.0)) - r;\n}\n\nfloat plane (in vec3 p, in vec3 n, in float d) {\n\treturn dot (p, normalize (n)) + d;\n}\n\nfloat torusZ (in vec3 p, in float r1, in float r2) {\n\tvec2 q = vec2 (length (p.xy) - r1, p.z);\n\treturn length (q) - r2;\n}\n\nfloat cylinderX (in vec3 p, in float r) {\n \treturn length (p.yz) - r;\n}\n\nfloat cylinderY (in vec3 p, in float r) {\n \treturn length (p.xz) - r;\n}\n\nvec3 twistY (in vec3 p, in float k, in float angle) {\n\treturn vRotateY (p, angle + k * p.y);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p, out vec4 q) {\n\n\t// Ground\n\tvec3 q_ = p;\n\tq_.z += 0.8 * (sin (iTime + p.x * 0.5) + sin (p.y * 0.5));\n\tfloat dist = fixDistance (plane (q_, vec3 (-0.2, 0.0, 1.0), 5.0), 0.6, 0.8); // need to fix the distance because of the sine deformation\n\tq = vec4 (q_, 0.0);\n\n\t// Twisted box\n\tq_ = p;\n\tq_.x -= 5.0;\n\tq_ = twistY (q_, cos (iTime), iTime);\n\tfloat dist_ = fixDistance (box (q_, vec3 (1.0, 1.0, 1.0), 0.1), 0.2, 0.8); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 1.0);\n\t\tdist = dist_;\n\t}\n\n\t// Simple box\n\tq_ = p;\n\tq_.y -= 3.0;\n\tq_ = mRotate (vec3 (0.7, 0.0, -0.2)) * q_;\n\tdist_ = box (q_, vec3 (1.0, 0.5, 1.0), 0.3);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 2.0);\n\t\tdist = dist_;\n\t}\n\n\t// Sphere\n\tq_ = p + vec3 (3.0, -1.0, sin (iTime * 2.0) - 1.0);\n\tdist_ = sphere (q_, 1.0);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 3.0);\n\t\tdist = dist_;\n\t}\n\n\t// Twisted torus\n\tq_ = p;\n\tq_.y += 4.0;\n\tq_ = twistY (q_, 2.0, 0.0);\n\tdist_ = fixDistance (torusZ (q_, 1.0, 0.3), 0.8, 0.5); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 4.0);\n\t\tdist = dist_;\n\t}\n\n\t// Cylinders\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.y = mod (q_.y, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderX (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 5.0);\n\t\tdist = dist_;\n\t}\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.x = mod (q_.x, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderY (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 6.0);\n\t\tdist = dist_;\n\t}\n\n\t// Smallest distance\n\treturn dist;\n}\n\nvec3 getObjectColor (in vec4 q, out float reflection) {\n\tfloat tint = 0.6 + 0.4 * sin (q.x * 10.0) * sin (q.y * 10.0) * sin (q.z * 10.0);\n\tif (q.w < 0.5) {\n\t\treflection = 0.0;\n\t\treturn (0.6 + 0.4 * tint) * vec3 (0.2, 1.0, 1.0);\n\t}\n\tif (q.w < 1.5) {\n\t\treflection = 0.2;\n\t\treturn tint * vec3 (1.0, 0.0, 0.0);\n\t}\n\tif (q.w < 2.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (0.0, 0.0, 1.0);\n\t}\n\tif (q.w < 3.5) {\n\t\treflection = 0.5;\n\t\treturn tint * vec3 (1.0, 1.0, 0.0);\n\t}\n\tif (q.w < 4.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (1.0, 0.2, 0.5);\n\t}\n\treflection = 0.0;\n\treturn tint * vec3 (0.5, 0.5, 0.6);\n}\n\nvec3 getNormal (in vec3 p) {\n\tvec4 q;\n\tvec2 h = vec2 (DELTA, 0.0);\n\treturn normalize (vec3 (\n\t\tgetDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),\n\t\tgetDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),\n\t\tgetDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)\n\t));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Old monitor effect\n\tvec2 frag = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tfloat round = pow (length (frag * frag), 6.0);\n\tfrag.y *= 1.0 + round * 0.2;\n\tvec3 colorMonitor = vec3 (1.0 - round);\n\tcolorMonitor *= vec3 (0.8, 1.0 + abs (mod (frag.y, 0.04) / 0.04 - 0.5), 0.8);\n\n\t// Define the ray corresponding to this fragment\n\tfrag.x *= iResolution.x / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tfloat angle = M_PI * sin (0.1 * iTime);\n\tvec3 origin = vec3 (10.0 * cos (angle), 10.0 * sin (angle), 2.5);\n\tdirection = mRotate (vec3 (M_PI / 2.0 + 0.45, 0.0, angle - M_PI / 2.0)) * direction;\n\n\t// Compute the fragment color\n\tvec3 lightDirection = normalize (LIGHT);\n\tfloat moveAway = DELTA * 10.0;\n\n\tvec3 color = vec3 (0.0, 0.0, 0.0);\n\tfloat absorb = 1.0;\n\tfloat fade = 0.0;\n\tfor (int reflectionIndex = 0; reflectionIndex < REFLECT_COUNT; ++reflectionIndex) {\n\n\t\t// Ray marching\n\t\tvec4 objectInfo;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (origin, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += dist * direction;\n\t\t}\n\n\t\t// Combine colors\n\t\tif (reflectionIndex == 0) {\n\t\t\tfade = pow (max (0.0, 1.0 - rayLength / RAY_LENGTH_MAX), FADE_POWER);\n\t\t} else {\n\t\t\tcolor *= 1.0 - absorb;\n\t\t}\n\t\tif (rayLength > RAY_LENGTH_MAX) {\n\t\t\tcolor += BACK_COLOR * absorb;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the object color\n\t\tfloat reflection;\n\t\tvec3 objectColor = getObjectColor (objectInfo, reflection);\n\n\t\t// Lighting\n\t\tvec3 normal = getNormal (origin);\n\t\tdirection = reflect (direction, normal);\n\n\t\t#ifdef SHADOW\n\t\tvec3 p = origin + moveAway * lightDirection;\n\t\trayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (p, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp += dist * lightDirection;\n\t\t}\t\t\n\t\tif (rayLength < RAY_LENGTH_MAX) {\n\t\t\tobjectColor *= AMBIENT;\n\t\t}\n\t\telse\n\t\t#endif\n\t\t{\n\t\t\tfloat diffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat specular = pow (max (0.0, dot (direction, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tobjectColor = (AMBIENT + diffuse) * objectColor + specular;\n\t\t}\n\t\tcolor += objectColor * absorb;\n\n\t\t// Next ray...\n\t\tif (reflection < DELTA) {\n\t\t\tbreak;\n\t\t}\n\t\tabsorb *= reflection;\n\t\torigin += moveAway * direction;\n\t}\n\n\t// Fading\n\tcolor = mix (BACK_COLOR, color, fade);\n\n\t// Gamma correction\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tfragColor = vec4 (color * colorMonitor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MssSDM",
    "date": "1402650846",
    "viewed": 356,
    "name": "Sound experiment",
    "description": "Rework of https://www.shadertoy.com/view/MdsXWM",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sound"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGRr",
       "filepath": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// From https://www.shadertoy.com/view/MdsXWM\n\nconst float samples = 6.0;\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tp.x += 0.05 * cos (iTime + p.y * 20.0);\n\tvec3 color = vec3(0.0, 0.0, 0.2);\n\tfloat r = texture (iChannel0, vec2 (0.0)).x * 0.4;\n\tfor(float d = 0.0; d < 1.0; d += 1.0 / samples) {\n\t\tvec3 c = hsv2rgb (vec3 (d + iTime, 1.0, 1.0));\n\t\tfloat v = texture (iChannel0, vec2 (d, 0.0)).x * 0.7;\n\t\tfloat a = 2.0 * 3.14159 * d + iTime;\n\t\tvec2 o = r * vec2 (cos (a), sin (a));\n\t\tcolor += c * v / length (p - o);\n\t}\n\tcolor /= samples;\n\tcolor = mix (vec3 (length (color)), color, smoothstep (r + 0.02, r + 0.05, length (p)));\n\tfragColor = vec4 (pow (color, vec3 (0.6 + r)), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4slSzj",
    "date": "1404201285",
    "viewed": 2745,
    "name": "Glass Polyhedron",
    "description": "Forked from: https://www.shadertoy.com/view/ldfXzn\n\nThis is a simplification of my \"diamond\", to check about refraction and reflection...",
    "likes": 61,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "glass"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Forked from: https://www.shadertoy.com/view/ldfXzn\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t100\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.6\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t1.5\n#define LUMINOSITY_FACTOR\t2.0\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 k;\nfloat getDistance (in vec3 p) {\n\tfloat repeat = 20.0;\n\tvec3 q = p + repeat * 0.5;\n\tk = floor (q / repeat);\n\tq -= repeat * (k + 0.5);\n\tp = mRotate (k) * q;\n\n\tfloat top = p.y - 3.0;\n\tfloat angleStep = M_PI / max (2.0, abs (k.x + 2.0 * k.y + 4.0 * k.z));\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tfloat side = cos (angle) * p.z + sin (angle) * p.x - 2.0;\n\tfloat bottom = -p.y - 3.0;\n\n\treturn max (top, max (side, bottom));\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t}\n\t\telse {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lsBXDW",
    "date": "1412149017",
    "viewed": 5726,
    "name": "Dance floor",
    "description": "Simple test...",
    "likes": 41,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "color",
     "tiles"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRr",
       "filepath": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfrag *= 1.0 - 0.2 * cos (frag.yx) * sin (3.14159 * 0.5 * texture (iChannel0, vec2 (0.0)).x);\n\tfrag *= 5.0;\n\tfloat random = rand (floor (frag));\n\tvec2 black = smoothstep (1.0, 0.8, cos (frag * 3.14159 * 2.0));\n\tvec3 color = hsv2rgb (vec3 (random, 1.0, 1.0));\n\tcolor *= black.x * black.y * smoothstep (1.0, 0.0, length (fract (frag) - 0.5));\n\tcolor *= 0.5 + 0.5 * cos (random + random * iTime + iTime + 3.14159 * 0.5 * texture (iChannel0, vec2 (0.7)).x);\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MdjXRt",
    "date": "1415186636",
    "viewed": 322,
    "name": "LED Watch [Barcode]",
    "description": "Just a little experiment, to try mimic one of my LED watch.\n\nNote: The two bars on the left represent hours, the two on the right minutes. LEDs in the first bar count for 6, LEDs in the third bar count for 10; LEDs in the 2 other bars count for 1. :)",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "led",
     "watch"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// LED watch: the two bars on the left represent hours, the two on the\n// right minutes. LEDs in the first bar count for 6, LEDs in the third\n// bar count for 10; LEDs in the 2 other bars count for 1.\n\n#define M_PI 3.1415926535897932384626433832795\n#define VERTICAL\n#define HSV2RGB_FAST\n\nfloat boxDist (in vec2 p, in vec2 b) {\n\treturn length (max (abs (p) - b, 0.0));\n}\n\nfloat boxDist (in vec2 p, in vec3 b) {\n\treturn length (max (abs (p) - b.xy + b.z, 0.0)) - b.z;\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * M_PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the fragment's position in the watch space\n\t#ifndef VERTICAL\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\t#else\n\tvec2 frag = (2.0 * fragCoord.yx - iResolution.yx) / iResolution.y;\n\t#endif\n\tfrag *= 1.0 - vec2 (0.02, 0.04) * cos (frag.yx * 2.0) * max (0.0, 50.0 * sin (iTime * M_PI * 2.0 / 5.0) - 49.0);\n\t#ifndef VERTICAL\n\tfrag *= 8.0;\n\t#else\n\tfrag *= vec2 (6.0, -6.0);\n\t#endif\n\n\t// Define the panel and the border\n\tvec3 panelSize = vec3 (5.0, 2.2, 1.0);\n\tfloat panelDist = -boxDist (frag, panelSize);\n\tfloat borderDist = boxDist (frag, panelSize + 0.1);\n\n\t// Define the LEDs\n\tvec2 led = frag;\n\tled.x -= 0.5;\n\tvec2 ledId = floor (led);\n\tfloat random = rand (ledId);\n\tfloat ledThresholdBar2 = step (-1.5, ledId.y);\n\tfloat ledThresholdBar4 = step (0.5, ledId.y);\n\tfloat ledTimeModulo = 10.0 - 4.0 * ledThresholdBar2 - 2.0 * ledThresholdBar4;\n\tfloat ledMode = max (0.0, cos (iTime * 0.5));\n\tfloat ledIntensity = mix (0.8 * step (ledId.x + 6.0, mod (iDate.w / (60.0 + 540.0 * ledThresholdBar2 + 3000.0 * step (-0.5, ledId.y) + 18000.0 * ledThresholdBar4), ledTimeModulo)), 0.5 + 0.5 * cos (random + random * iTime + iTime), ledMode);\n\tfloat ledDist = boxDist (fract (led) - 0.5, vec2 (0.2, 0.03));\n\n\t// Create everything (panel, casing, small indicator and LEDs)\n\tvec3 color = vec3 (0.2, 0.2, 0.2) * (0.7 + 0.3 * cos (frag.x * M_PI / panelSize.x)) * smoothstep (0.1, 0.15, panelDist) * smoothstep (0.2, 0.25, abs (fract (frag.y) - 0.5));\n\tcolor += (0.4 + 0.2 * cos (frag.x + frag.y + iTime)) * smoothstep (0.1, 0.0, max (borderDist, panelDist));\n\tcolor += 0.3 * smoothstep (0.05, 0.0, boxDist (frag + vec2 (0.0, 1.9), vec3 (0.04, 0.1, 0.04)));\n\tcolor += mix (vec3 (0.1) * smoothstep (0.025, 0.0, ledDist), hsv2rgb (vec3 (random + iTime * 0.1, ledMode, 1.0)) * smoothstep (0.25, 0.0, ledDist), ledIntensity) * step (-4.5, frag.x) * step (5.5 - ledTimeModulo, -frag.x) * step (-2.0, -abs (frag.y));\n\n\t// Get the fragment's position in the background tile space\n\t#ifndef VERTICAL\n\tfrag = 15.0 * fragCoord.xy / iResolution.x;\n\t#else\n\tfrag = 15.0 * fragCoord.yx / iResolution.y;\n\t#endif\n\tfrag -= vec2 (iTime, sin (iTime));\n\n\t// Create the background tiles\n\trandom = rand (floor (frag));\n\tcolor += hsv2rgb (vec3 (random, 1.0, 1.0)) * smoothstep (0.6, 0.0, length (fract (frag) - 0.5)) * (0.2 + 0.2 * cos (random + random * iTime + iTime)) * smoothstep (0.0, 0.2, borderDist);\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MdSSDy",
    "date": "1415617779",
    "viewed": 367,
    "name": "LED Watch [Binary]",
    "description": "Another LED watch.\n\nNote: Yellow LEDs represent seconds, red ones minutes, and green ones hours; all numbers are shown in their binary format (LEDs values from right to left: 1, 2, 4, 8, 16 and 32).",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "led",
     "watch"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Yellow LEDs represent seconds, red ones minutes, and green ones\n// hours; all numbers are shown in their binary format (LEDs values\n// from right to left: 1, 2, 4, 8, 16 and 32).\n\n#define M_PI 3.14159265359\n#define HSV2RGB_FAST\n\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * M_PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\nfloat segDist (in vec2 p, in vec4 ab, in float cut) {\n\tp -= ab.xy;\n\tab.zw -= ab.xy;\n\tfloat l = dot (ab.zw, ab.zw);\n\tcut *= sqrt (l);\n\treturn length (p - ab.zw * clamp (dot (p, ab.zw), cut, l - cut) / l);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the fragment's position\n\tvec2 frag = 7.0 * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\n\t// Define the background lights\n\tvec3 lightColor = vec3(0.0, 0.0, 0.2);\n\tconst float lightCount = 5.0;\n\tfor(float lightId = 0.0; lightId < 1.0; lightId += 1.0 / lightCount) {\n\t\tfloat lightAngle = 2.0 * M_PI * lightId + iTime;\n\t\tlightColor += hsv2rgb (vec3 (lightId + iTime * 0.1, 1.0, 1.0)) / length (frag - 2.0 * vec2 (cos (lightAngle), sin (lightAngle))) * (3.0 + 2.0 * cos (iTime * (1.0 + lightId))) ;\n\t}\n\tlightColor /= lightCount;\n\n\t// Define the casing color\n\tfloat casingColor = 0.3 + 0.2 * cos (frag.x + frag.y + iTime);\n\n\t// Rotate the watch every 5s\n\tfloat fragAngle = 0.1 * sin (iTime * 2.0 * M_PI) * step (4.0, mod (iTime, 5.0));\n\tvec2 fragRotate = vec2 (cos (fragAngle), sin (fragAngle));\n\tfrag = mat2 (fragRotate.x, fragRotate.y, -fragRotate.y, fragRotate.x) * frag;\n\n\t// Define the panel and the border\n\tfloat panelDist = length (frag) - 3.5;\n\tfloat borderDist = panelDist - 0.05;\n\n\t// Define the LEDs\n\tfloat ledThresholdBar2 = step (-0.5, frag.y);\n\tfloat ledThresholdBar3 = step (0.5, frag.y);\n\tvec2 ledPosition = frag + vec2 (0.5 * ledThresholdBar3, 0.5);\n\tfloat ledDist = length (fract (ledPosition) - 0.5);\n\tfloat ledDisplay = step (ledThresholdBar3 * 0.5 - 3.0, -abs (frag.x)) * step (-1.5, -abs (frag.y));\n\n\tfloat ledTime = mod (iDate.w / (1.0 + 59.0 * ledThresholdBar2 + 3540.0 * ledThresholdBar3), 60.0 - 36.0 * ledThresholdBar3);\n\tvec3 ledColor = vec3 (1.0 - ledThresholdBar3, ledThresholdBar3 - ledThresholdBar2 + 1.0, 0.0);\n\tledColor *= step (0.5, fract (ledTime / exp2 (3.0 - floor (ledPosition.x))));\n\n\t// Define the indicators\n\tfloat indicatorDist = min (abs (length (frag - vec2 (-1.0, 1.7)) - 0.08), abs (length (frag - vec2 (-1.0, 1.84)) - 0.06));\n\tindicatorDist = min (indicatorDist, segDist (frag, vec4 (-1.0, 1.8, -1.0, 1.0), 0.3));\n\tindicatorDist = min (indicatorDist, segDist (frag, vec4 (-1.0, 1.0, -0.5, 0.0), 0.3));\n\tindicatorDist = min (indicatorDist, segDist (frag, vec4 (-0.5, 0.0, -0.5, -1.0), 0.3));\n\n\t// Create everything (lights, panel, casing, LEDs, indicators)\n\tvec3 color = lightColor * smoothstep (0.0, 0.2, borderDist);\n\tcolor += vec3 (0.1, 0.1, 0.3) * (0.7 + 0.3 * cos (frag.y * M_PI / 3.5)) * smoothstep (0.0, -0.1, panelDist) * (1.0 - smoothstep (0.15, 0.1, ledDist) * ledDisplay);\n\tcolor += casingColor * smoothstep (0.05, 0.0, max (borderDist, -panelDist));\n\tcolor += ledColor * smoothstep (0.25, 0.1, ledDist) * ledDisplay;\n\tcolor += 0.1 * smoothstep (0.05, 0.0, indicatorDist);\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XdSSWV",
    "date": "1415789503",
    "viewed": 200,
    "name": "Stupid Voxel",
    "description": "Just a very basic voxel and raymarcher, to demonstrate these methods.",
    "likes": 3,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "voxel"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define HACK // Hack to speed up the voxel (= reuse the raymarching position)\n\n#define CAMERA_FOCAL_LENGTH\t1.5\n#define DELTA\t\t\t\t0.01\n#define RAY_STEP_MAX\t\t80\n#define SQRT3\t\t\t\t1.73205080757\n#define PI\t\t\t\t\t3.14159265359\n\nfloat scene (in vec3 p) {\n\n\t// Just a sphere cropped by smaller spheres, into a big sphere\n\tfloat r1 = length (p);\n\tfloat r2 = length (abs (p) - 5.0);\n\treturn min (max (r1 - 8.5, 3.0 - r2), 32.0 - r1);\n}\n\nvec3 mapping (in vec3 position, in vec3 normal) {\n\tposition = cos (position * 2.0 * PI);\n\treturn (0.8 + 0.2 * position.x * position.y * position.z) * (0.4 + 0.6 * normal);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Set the camera\n\tvec3 origin = vec3 (20.0 * cos (iTime), 12.0 * sin (iTime * 0.5), 20.0 * sin (iTime));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (cos (iTime), 1.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tray = rotation * ray;\n\n\t// Raymarching\n\t#ifdef HACK\n\tfloat hack = 1.0 / 0.0;\n\t#endif\n\tvec3 rayPosition = origin;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = scene (rayPosition);\n\t\tif (dist < DELTA) {\n\t\t\tbreak;\n\t\t}\n\t\trayPosition += dist * ray;\n\n\t\t#ifdef HACK\n\t\thack = min (hack, dist);\n\t\torigin = mix (origin, rayPosition, step (SQRT3, hack));\n\t\t#endif\n\t}\n\tvec2 h = vec2 (DELTA, 0.0);\n\tvec3 normal = normalize (vec3 (\n\t\tscene (rayPosition + h.xyy) - scene (rayPosition - h.xyy),\n\t\tscene (rayPosition + h.yxy) - scene (rayPosition - h.yxy),\n\t\tscene (rayPosition + h.yyx) - scene (rayPosition - h.yyx)));\n\tvec3 colorRaymarching = mapping (rayPosition, normal);\n\n\t// Voxel\n\t#ifdef HACK\n\torigin -= SQRT3 * ray;\n\t#endif\n\tvec3 raySign = sign (ray);\n\tvec3 rayIncrement = raySign / ray;\n\tvec3 rayTime = (0.5 + raySign * (0.5 - fract (origin + 0.5))) * rayIncrement;\n\trayPosition = floor (origin + 0.5);\n\tvec3 rayAxis = vec3 (0.0);\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\trayAxis = step (rayTime.xyz, rayTime.yzx) * step (rayTime.xyz, rayTime.zxy);\n\t\trayPosition += rayAxis * raySign;\n\t\tif (scene (rayPosition) < DELTA) {\n\t\t\tbreak;\n\t\t}\n\t\trayTime += rayAxis * rayIncrement;\n\t}\n\tvec3 colorVoxel = mapping (origin + ray * min (rayTime.x, min (rayTime.y , rayTime.z)), -rayAxis * raySign);\n\n\t// Set the fragment color\n\tfragColor = vec4 (mix (colorRaymarching, colorVoxel, smoothstep (-0.2, 0.2, cos (iTime * 0.8))), 1.0);\n}",
     "name": "",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lsBXWK",
    "date": "1415936022",
    "viewed": 380,
    "name": "Touch pressure",
    "description": "Simulate a touch pressure.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "touch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define M_PI\t\t3.1415926535897932384626433832795\n#define ITERATION\t3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Inputs\n\tfloat touchPressure = step (0.0, iMouse.z) * (0.6 + 0.4 * cos (iTime * 4.0));\n\tconst float touchRadius = 0.3;\n\tconst float gridRadius = 0.5;\n\tconst float gridResolution = 30.0;\n\tvec4 gridColor = vec4 (1.0, 1.0 - touchPressure, 0.0, 1.0);\n\n\t// Get the position of this fragment\n\tvec3 frag = vec3 (fragCoord.xy / iResolution.y, 0.0);\n\n\t// Get the touch information\n\tvec2 touchPosition = iMouse.xy / iResolution.y;\n\tfloat touchDistance = length (frag.xy - touchPosition);\n\n\t// Raymarching\n\tvec3 ray = normalize (frag - vec3 (0.5 * iResolution.x / iResolution.y, 0.5, -10.0));\n\tfor (int i = 0; i < ITERATION; ++i)\n\t{\n\t\tfloat deformation = 0.5 + 0.5 * cos (M_PI * min (touchDistance / touchRadius, 1.0));\n\t\tfrag += (touchPressure * deformation - frag.z) * ray;\n\t\ttouchDistance = length (frag.xy - touchPosition);\n\t}\n\n\t// Get the color from the texture\n\tvec4 color = texture (iChannel0, vec2 (frag.x * iResolution.y / iResolution.x, -frag.y));\n\n\t// Add the grid\n\tvec2 gridPosition = smoothstep (0.05, 0.1, abs (fract (frag.xy * gridResolution) - 0.5));\n\tcolor = mix (color, gridColor, (1.0 - gridPosition.x * gridPosition.y) * smoothstep (gridRadius * touchPressure, 0.0, touchDistance));\n\n\t// Set the fragment color\n\tfragColor = color;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lsjSDd",
    "date": "1417505818",
    "viewed": 678,
    "name": "Light dot cylinder",
    "description": "Simple mapping of light dots over a cylinder.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "light",
     "cylinder",
     "dot"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGzn",
       "filepath": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Parameters\n#define CAMERA_FOCAL_LENGTH\t1.2\n#define DOT_COUNT\t\t\t100.0\n#define SOUND\n#define MOUSE\n#define HSV2RGB_FAST\n\n// Constants\n#define PI\t3.14159265359\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH);\n\n\t// Get the music info\n\t#ifdef SOUND\n\tfloat soundBass = texture (iChannel0, vec2 (0.0)).x;\n\tfloat soundTreble = texture (iChannel0, vec2 (0.9, 0.0)).x;\n\t#else\n\tfloat soundBass = 0.6 + 0.4 * cos (iTime * 0.2);\n\tfloat soundTreble = 0.5 + 0.5 * cos (iTime * 1.2);\n\t#endif\n\n\t// Define the number of rows\n\tfloat dotRowCount = floor (20.0 + 60.0 * soundTreble * soundBass) * 2.0;\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = cos (iTime * 2.0);\n\tfloat pitchAngle = 2.0 * PI * cos (iTime * 0.2 + soundTreble * 0.4);\n\t#ifdef MOUSE\n\tyawAngle += 2.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * (1.0 - iMouse.y / iResolution.y);\n\t#endif\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the position of the camera\n\tfloat cameraDist = -2.0 * (cos (iTime) * cos (iTime * 3.5) + soundBass);\n\tvec3 cameraPosition = cameraOrientation [2] * cameraDist;\n\n\t// Compute the intersection point (ray / cylinder)\n\tfloat a = dot (ray.xz, ray.xz);\n\tfloat b = dot (cameraPosition.xz, ray.xz);\n\tfloat c = b * b - a * (dot (cameraPosition.xz, cameraPosition.xz) - 1.0);\n\tfloat ok = step (0.0, c);\n\tc = sqrt (c);\n\tvec3 hit;\n\tif (b < -c) {\n\t\thit = cameraPosition - ray * (b + c) / a;\n\t\tif (abs (hit.y * DOT_COUNT / PI + 1.0) > dotRowCount) {\n\t\t\thit = cameraPosition - ray * (b - c) / a;\n\t\t}\n\t} else {\n\t\thit = cameraPosition - ray * (b - c) / a;\n\t}\n\tvec2 frag = vec2 ((atan (hit.z, hit.x) + PI) * DOT_COUNT, hit.y * DOT_COUNT + PI) / (2.0 * PI);\n\n\t// Compute the fragment color\n\tvec2 id = floor (frag);\n\tfloat random = rand (id);\n\tvec3 color = hsv2rgb (vec3 (iTime * 0.05 + id.y * 0.005, 1.0, 1.0));\n\tcolor += 0.5 * cos (random * vec3 (1.0, 2.0, 3.0));\n\tcolor *= smoothstep (0.5, 0.1, length (fract (frag) - 0.5));\n\tcolor *= 0.5 + 1.5 * step (0.9, cos (random * iTime * 5.0));\n\tcolor *= 0.5 + 0.5 * cos (random * iTime + PI * 0.5 * soundTreble);\n\tcolor *= smoothstep (dotRowCount, 0.0, (abs (id.y + 0.5) - 1.0) * 2.0);\n\tfragColor = vec4 (color * ok, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtlGRr",
    "date": "1418094040",
    "viewed": 1004,
    "name": "Voxel land",
    "description": "Experimenting with voxel... Use the mouse to rotate the camera.\nNote: the new PRNG function (hash) is from Dave_Hoskins (thanks!).",
    "likes": 22,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voxel"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Parameters\n#define CAMERA_FOCAL_LENGTH\t\t1.5\n#define REFLECT_COUNT \t\t\t1\n#define REFLECT_INDEX\t\t\t0.4\n#define VOXEL_STEP_INCIDENT\t\t80.0\n#define VOXEL_STEP_REFLECTED\t20.0\n#define SOUND\n#define MOUSE\n#define HSV2RGB_FAST\n\n// Constants\n#define PI\t\t3.14159265359\n#define SQRT2\t1.41421356237\n#define DELTA\t0.01\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Get the music info\n\t#ifdef SOUND\n\tfloat soundBass = texture (iChannel0, vec2 (0.0)).x;\n\tfloat soundTreble = texture (iChannel0, vec2 (0.9, 0.0)).x;\n\t#else\n\tfloat soundBass = 0.6 + 0.4 * cos (iTime * 0.2);\n\tfloat soundTreble = 0.5 + 0.5 * cos (iTime * 1.2);\n\t#endif\n\n\t// Set the camera\n\tvec3 origin = vec3 (0.0, 10.0 - 8.0 * cos (iTime * 0.3), iTime * 10.0);\n\tfloat cameraAngle = iTime * 0.1;\n\t#ifdef MOUSE\n\tcameraAngle += 2.0 * PI * iMouse.x / iResolution.x;\n\t#endif\n\tvec3 cameraForward = vec3 (cos (cameraAngle), cos (iTime * 0.3) - 1.5, sin (cameraAngle));\n\tvec3 cameraUp = vec3 (0.2 * cos (iTime * 0.7), 1.0, 0.0);\n\tmat3 cameraRotation;\n\tcameraRotation [2] = normalize (cameraForward);\n\tcameraRotation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraRotation [1] = cross (cameraRotation [2], cameraRotation [0]);\n\tray = cameraRotation * ray;\n\n\t// Handle reflections\n\tvec3 colorMixed = vec3 (0.0);\n\tfloat absorb = 1.0;\n\tfloat voxelStepStop = VOXEL_STEP_INCIDENT;\n\tfor (int reflectNumber = 0; reflectNumber <= REFLECT_COUNT; ++reflectNumber) {\n\n\t\t// Voxel\n\t\tvec2 voxelSign = sign (ray.xz);\n\t\tvec2 voxelIncrement = voxelSign / ray.xz;\n\t\tfloat voxelTimeCurrent = 0.0;\n\t\tvec2 voxelTimeNext = (0.5 + voxelSign * (0.5 - fract (origin.xz + 0.5))) * voxelIncrement;\n\t\tvec2 voxelPosition = floor (origin.xz + 0.5);\n\t\tfloat voxelHeight = 0.0;\n\t\tbool voxelDone = false;\n\t\tvec3 voxelNormal = vec3 (0.0);\n\t\tfor (float voxelStep = 1.0; voxelStep <= VOXEL_STEP_INCIDENT; ++voxelStep) {\n\n\t\t\t// Compute the height of this column\n\t\t\tvoxelHeight = 4.0 * rand (voxelPosition)* smoothstep (0.2, 0.8, soundBass) * sin (soundTreble * PI * 0.5 + voxelPosition.x * voxelPosition.y);\n\n\t\t\t// Check whether we hit the side of the column\n\t\t\tif (voxelDone = voxelHeight > origin.y + voxelTimeCurrent * ray.y) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Check whether we hit the top of the column\n\t\t\tfloat timeNext = min (voxelTimeNext.x, voxelTimeNext.y);\n\t\t\tfloat timeIntersect = (voxelHeight - origin.y) / ray.y;\n\t\t\tif (voxelDone = timeIntersect > voxelTimeCurrent && timeIntersect < timeNext) {\n\t\t\t\tvoxelTimeCurrent = timeIntersect;\n\t\t\t\tvoxelNormal = vec3 (0.0, 1.0, 0.0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Next voxel...\n\t\t\t#if REFLECT_COUNT > 0\n\t\t\tif (voxelStep >= voxelStepStop) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t#endif\n\t\t\tvoxelTimeCurrent = timeNext;\n\t\t\tvoxelNormal.xz = step (voxelTimeNext.xy, voxelTimeNext.yx);\n\t\t\tvoxelTimeNext += voxelNormal.xz * voxelIncrement;\n\t\t\tvoxelPosition += voxelNormal.xz * voxelSign;\n\t\t}\n\t\tif (!voxelDone) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += voxelTimeCurrent * ray;\n\n\t\t// Compute the local color\n\t\tvec3 mapping = origin;\n\t\tmapping.y -= voxelHeight + 0.5;\n\t\tmapping *= 1.0 - voxelNormal;\n\t\tmapping += 0.5;\n\t\tfloat id = rand (voxelPosition);\n\t\tvec3 color = hsv2rgb (vec3 (id + (iTime + floor (mapping.y)) * 0.05, 1.0, 0.7 + 0.3 * cos (id * iTime + PI * soundTreble)));\n\t\tcolor *= smoothstep (1.0 - 0.4 * cos (soundBass * PI), 0.1, length (fract (mapping) - 0.5));\n\t\tcolor *= 0.5 + smoothstep (0.5, 0.9, cos (id * 100.0 + iTime * 0.5));\n\t\tcolor *= 1.0 - voxelTimeCurrent / voxelStepStop * SQRT2;\n\n\t\t// Mix the colors\n\t\t#if REFLECT_COUNT == 0\n\t\tcolorMixed = color;\n\t\t#else\n\t\tcolorMixed += color * absorb;\n\t\tabsorb *= REFLECT_INDEX;\n\n\t\t// Reflection\n\t\tray = reflect (ray, voxelNormal);\n\t\torigin += ray * DELTA;\n\t\tvoxelStepStop = VOXEL_STEP_REFLECTED;\n\t\t#endif\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (colorMixed, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlfGR4",
    "date": "1418827414",
    "viewed": 1731,
    "name": "Voxel land 2",
    "description": "Rework of [url=https://www.shadertoy.com/view/XtlGRr]Voxel land[/url] to be faster on mobile devices (no reflection) and propose different colors...",
    "likes": 31,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voxel"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGzn",
       "filepath": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Parameters\n#define CAMERA_FOCAL_LENGTH\t1.5\n#define VOXEL_STEP\t\t\t50.0\n#define SOUND\n#define MOUSE\n#define HSV2RGB_FAST\n\n// Constants\n#define PI\t\t3.14159265359\n#define SQRT2\t1.41421356237\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Get the music info\n\t#ifdef SOUND\n\tfloat soundBass = texture (iChannel0, vec2 (0.0)).x;\n\tfloat soundTreble = texture (iChannel0, vec2 (0.9, 0.0)).x;\n\t#else\n\tfloat soundBass = 0.6 + 0.4 * cos (iTime * 0.2);\n\tfloat soundTreble = 0.5 + 0.5 * cos (iTime * 1.2);\n\t#endif\n\n\t// Set the camera\n\tvec3 origin = vec3 (0.0, 6.0 - 3.0 * cos (iTime * 0.3), iTime * 2.0 + 700.0 * (0.5 + 0.5 * sin (iTime * 0.1)));\n\tfloat cameraAngle = iTime * 0.1;\n\t#ifdef MOUSE\n\tcameraAngle += 2.0 * PI * iMouse.x / iResolution.x;\n\t#endif\n\tvec3 cameraForward = vec3 (cos (cameraAngle), cos (iTime * 0.3) - 1.5, sin (cameraAngle));\n\tvec3 cameraUp = vec3 (0.2 * cos (iTime * 0.7), 1.0, 0.0);\n\tmat3 cameraRotation;\n\tcameraRotation [2] = normalize (cameraForward);\n\tcameraRotation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraRotation [1] = cross (cameraRotation [2], cameraRotation [0]);\n\tray = cameraRotation * ray;\n\n\t// Voxel\n\tvec3 color = vec3 (0.0);\n\n    vec2 voxelSign = sign (ray.xz);\n\tvec2 voxelIncrement = voxelSign / ray.xz;\n\tfloat voxelTimeCurrent = 0.0;\n\tvec2 voxelTimeNext = (0.5 + voxelSign * (0.5 - fract (origin.xz + 0.5))) * voxelIncrement;\n\tvec2 voxelPosition = floor (origin.xz + 0.5);\n\tfloat voxelHeight = 0.0;\n\tbool voxelDone = false;\n\tvec3 voxelNormal = vec3 (0.0);\n\tfor (float voxelStep = 1.0; voxelStep <= VOXEL_STEP; ++voxelStep) {\n\n\t\t// Compute the height of this column\n\t\tvoxelHeight = 2.0 * rand (voxelPosition) * smoothstep (0.2, 0.5, soundBass) * sin (soundBass * 8.0 + voxelPosition.x * voxelPosition.y) - 5.0 * (0.5 + 0.5 * cos (voxelPosition.y * 0.15));\n\n\t\t// Check whether we hit the side of the column\n\t\tif (voxelDone = voxelHeight > origin.y + voxelTimeCurrent * ray.y) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check whether we hit the top of the column\n\t\tfloat timeNext = min (voxelTimeNext.x, voxelTimeNext.y);\n\t\tfloat timeIntersect = (voxelHeight - origin.y) / ray.y;\n\t\tif (voxelDone = timeIntersect > voxelTimeCurrent && timeIntersect < timeNext) {\n\t\t\tvoxelTimeCurrent = timeIntersect;\n\t\t\tvoxelNormal = vec3 (0.0, 1.0, 0.0);\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel...\n\t\tvoxelTimeCurrent = timeNext;\n\t\tvoxelNormal.xz = step (voxelTimeNext.xy, voxelTimeNext.yx);\n\t\tvoxelTimeNext += voxelNormal.xz * voxelIncrement;\n\t\tvoxelPosition += voxelNormal.xz * voxelSign;\n\t}\n\tif (voxelDone) {\n\t\torigin += voxelTimeCurrent * ray;\n\n\t\t// Compute the local color\n\t\tvec3 mapping = origin;\n\t\tmapping.y -= voxelHeight + 0.5;\n\t\tmapping *= 1.0 - voxelNormal;\n\t\tmapping += 0.5;\n\t\tfloat id = rand (voxelPosition);\n\t\tcolor = hsv2rgb (vec3 ((iTime + floor (mapping.y)) * 0.05 + voxelPosition.x * 0.01, smoothstep (0.2, 0.4, soundBass), 0.7 + 0.3 * cos (id * iTime + PI * soundTreble)));\n\t\tcolor *= smoothstep (0.8 - 0.6 * cos (soundBass * PI), 0.1, length (fract (mapping) - 0.5));\n\t\tcolor *= 0.5 + smoothstep (0.90, 0.95, cos (id * 100.0 + soundTreble * PI * 0.5 + iTime * 0.5));\n\t\tcolor *= 1.0 - voxelTimeCurrent / VOXEL_STEP * SQRT2;\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MlfGR4",
    "date": "1419250088",
    "viewed": 13455,
    "name": "Voxel Pac-Man",
    "description": "An attempt to do something like [url=https://upload.wikimedia.org/wikipedia/en/f/f0/PixelsOfficialPoster.jpg]this[/url]... Use the mouse to rotate when in 3D :).\n\nA slightly different version is [url=https://www.shadertoy.com/view/ltGyWz]there[/url]...",
    "likes": 116,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voxel",
     "pacman"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n//  GGGG IIIII  AAA  N   N TTTTT     PPPP   AAA   CCCC     M   M  AAA  N   N //\n// G       I   A   A NN  N   T       P   P A   A C         MM MM A   A NN  N //\n// G  GG   I   AAAAA N N N   T       PPPP  AAAAA C     --- M M M AAAAA N N N //\n// G   G   I   A   A N  NN   T       P     A   A C         M   M A   A N  NN //\n//  GGGG IIIII A   A N   N   T       P     A   A  CCCC     M   M A   A N   N //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n\n// Parameters\n#define VOXEL_RESOLUTION\t1.5\n#define VOXEL_LIGHTING\n#define SHADOW\n#define GROUND\n#define GHOST\n#define MOUSE\n#define HSV2RGB_FAST\n\n#define CAMERA_FOCAL_LENGTH\t8.0\n#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t500.0\n#define RAY_STEP_MAX\t\t100.0\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define SHADOW_LENGTH\t\t150.0\n#define SHADOW_POWER\t\t3.0\n#define FADE_POWER\t\t\t1.0\n#define BACKGROUND\t\t\t0.7\n#define GLOW\t\t\t\t0.4\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define PI\t\t3.14159265359\n#define SQRT3\t1.73205080757\n\n// Global variable to handle the glow effect\nfloat glowCounter;\n\n// PRNG (from https://www.shadertoy.com/view/4djSRW)\nfloat rand (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.3983, 5.4427, 6.9371));\n\tseed += dot (seed.yzx, seed.xyz + vec3 (21.5351, 14.3137, 15.3219));\n\treturn fract (seed.x * seed.y * seed.z * 95.4337);\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Rounded box\n\tconst float voxelRadius = 0.25;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, out vec3 P) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Scaling\n\tp *= VOXEL_RESOLUTION;\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = VOXEL_RESOLUTION * floor (iTime * 100.0 / VOXEL_RESOLUTION);\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Giant Pac-Man\n\tfloat body = length (p);\n\tbody = max (body - 32.0, 27.0 - body);\n\tfloat eyes = 6.0 - length (vec3 (abs (p.x) - 12.5, p.y - 19.5, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.07 + 0.07 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, 0.13);\n\tP = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0, -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = (q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1)) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\t#ifdef GHOST\n\tv = VOXEL_RESOLUTION * floor ((130.0 + 60.0 * cos (iTime * 3.0)) / VOXEL_RESOLUTION);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\tbody = max (body - 28.0, 22.0 - body);\n\teyes = 8.0 - length (vec3 (abs (q.x) - 12.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, 0.76);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Scaling\n\td.x /= VOXEL_RESOLUTION;\n\treturn d;\n}\n\n// Distance to the (voxelized?) scene\nvec4 dist (inout vec3 p, in vec3 ray, in float voxelized, in float rayLengthMax) {\n\tvec3 P = p;\n\tvec2 d = vec2 (1.0 / 0.0, 0.0);\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\td.x = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n\t\t\td = distScene (floor (p + 0.5), P);\n\t\t\tif (d.x < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\td.x = max (rayLengthInVoxel - rayLength, DELTA - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\td.x = DELTA + dNext;\n\t\t\t}\n\t\t} else {\n\t\t\td = distScene (p, P);\n\t\t\tif (voxelized > 0.5) {\n\t\t\t\tif (d.x < SQRT3 * 0.5) {\n\t\t\t\t\trayLengthCheckVoxel = rayLength + abs (d.x) + SQRT3 * 0.5;\n\t\t\t\t\td.x = max (rayLengthInVoxel - rayLength + DELTA, d.x - SQRT3 * 0.5);\n\t\t\t\t}\n\t\t\t} else if (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trayLength += d.x;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d.x * ray;\n\t}\n\treturn vec4 (d, rayLength, rand (P));\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, in float voxelized) {\n\tvec2 h = vec2 (DELTA, -DELTA);\n\tvec3 n;\n\tif (voxelized > 0.5) {\n\t\tp = fract (p + 0.5) - 0.5;\n\t\tn = h.xxx * distVoxel (p + h.xxx) +\n\t\t\th.xyy * distVoxel (p + h.xyy) +\n\t\t\th.yxy * distVoxel (p + h.yxy) +\n\t\t\th.yyx * distVoxel (p + h.yyx);\n\t} else {\n\t\tn = h.xxx * distScene (p + h.xxx, n).x +\n\t\t\th.xyy * distScene (p + h.xyy, n).x +\n\t\t\th.yxy * distScene (p + h.yxy, n).x +\n\t\t\th.yyx * distScene (p + h.yyx, n).x;\n\t}\n\treturn normalize (n);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\t// Define the rendering mode\n\tfloat modeTiming = iTime * 0.234;\n\tfloat modeAngle = PI * cos (iTime * 0.2);\n\tmodeAngle = dot (frag - vec2 (cos (iTime * 2.0), 0.0), vec2 (cos (modeAngle), sin (modeAngle)));\n\tfloat modeVoxel = step (0.5, fract (modeTiming / (4.0 * PI)));\n\tmodeTiming = cos (modeTiming);\n\tfloat mode3D = smoothstep (0.8, 0.5, modeTiming);\n\tfloat modeSwitch = smoothstep (0.995, 1.0, modeTiming) + smoothstep (0.02, 0.0, abs (modeAngle)) * modeVoxel;\n\tmodeVoxel = 1.0 + (step (0.0, modeAngle) - 1.0) * modeVoxel;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, mix (8.0, CAMERA_FOCAL_LENGTH, mode3D)));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\t#ifdef MOUSE\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n\t#endif\n\tyawAngle = mix (PI * 1.5, yawAngle, mode3D);\n\tpitchAngle *= mode3D;\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = mix (300.0, 195.0 + 150.0 * cos (iTime * 0.8), mode3D);\n\tvec3 origin = (vec3 (0.0, 0.0, 40.0 * sin (iTime * 0.2)) - cameraOrientation [2] * cameraDist) / VOXEL_RESOLUTION;\n\n\t// Compute the distance to the scene\n\tglowCounter = 0.0;\n\tvec4 d = dist (origin, ray, modeVoxel, RAY_LENGTH_MAX / VOXEL_RESOLUTION);\n\n\t// Set the background color\n\tvec3 finalColor = hsv2rgb (vec3 (0.2 * ray.y + 0.4 * modeVoxel - 0.37, 1.0, mode3D * BACKGROUND));\n\tvec3 glowColor = GLOW * vec3 (1.0, 0.3, 0.0) * glowCounter / RAY_STEP_MAX;\n\tif (d.x < DELTA) {\n\n\t\t// Set the object color\n\t\tvec3 color = hsv2rgb (vec3 (d.y + 0.1 * d.w * modeVoxel, 0.5 + 0.5 * modeVoxel, 1.0));\n\n\t\t// Lighting\n\t\tvec3 l = normalize (mix (vec3 (1.0, 0.0, 0.0), vec3 (1.25 + cos (iTime * 0.2), 1.0, 1.0), mode3D));\n\t\t#ifdef VOXEL_LIGHTING\n\t\tif (modeVoxel > 0.5) {\n\t\t\tvec3 n = normal (floor (origin + 0.5), 0.0);\n\t\t\tfloat diffuse = max (0.0, dot (n, l));\n\t\t\tfloat specular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\t\t}\n\t\t#endif\n\t\tvec3 n = normal (origin, modeVoxel);\n\t\tfloat diffuse = dot (n, l);\n\t\tfloat specular;\n\t\tif (diffuse < 0.0) {\n\t\t\tdiffuse = 0.0;\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\t#ifdef SHADOW\n\t\t\torigin += n * DELTA * 2.0;\n\t\t\tvec4 shadow = dist (origin, l, modeVoxel, SHADOW_LENGTH / VOXEL_RESOLUTION);\n\t\t\tif (shadow.x < DELTA) {\n\t\t\t\tshadow.z = pow (min (1.0, shadow.z * VOXEL_RESOLUTION / SHADOW_LENGTH), SHADOW_POWER);\n\t\t\t\tdiffuse *= shadow.z;\n\t\t\t\tspecular *= shadow.z;\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t\t// Fading\n\t\tfloat fade = pow (max (0.0, 1.0 - d.z * VOXEL_RESOLUTION / RAY_LENGTH_MAX), FADE_POWER);\n\t\tfinalColor = mix (finalColor, color, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = mix (pow (finalColor, vec3 (GAMMA)) + glowColor, vec3 (1.0), modeSwitch);\n\tfragColor = vec4 (finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ltX3Wr",
    "date": "1420705083",
    "viewed": 512,
    "name": "Je suis Charlie",
    "description": "Je suis Charlie. :|",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "charlie"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "// Quick & dirty, but...\n\n//#define EFFECT\n\nfloat line (vec2 p, vec2 a, vec2 b) {\n\tp -= a;\n\tb -= a;\n\ta = p - b * dot (p, b) / dot (b , b);\n\tb *= 0.5;\n\tp = abs (p - b) - abs (b);\n\treturn max (length (a), max (p.x, p.y));\n}\n\nfloat circle (vec2 p, vec2 o, float r) {\n\treturn abs (length (p - o) - r);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\tfrag = 3.0 * frag + vec2 (2.6, 1.1);\n\n\tfloat d1 = max (circle (frag, vec2 (0.4, 0.5), 0.5), frag.x - 0.4);\n\n\td1 = min (d1, line (frag, vec2 (0.8, 0.0), vec2 (0.8, 1.0)));\n\td1 = min (d1, line (frag, vec2 (1.3, 0.0), vec2 (1.3, 1.0)));\n\td1 = min (d1, line (frag, vec2 (0.8, 0.5), vec2 (1.3, 0.5)));\n\n\td1 = min (d1, line (frag, vec2 (1.7, 0.0), vec2 (1.9, 1.0)));\n\td1 = min (d1, line (frag, vec2 (2.3, 0.0), vec2 (2.1, 1.0)));\n\td1 = min (d1, line (frag, vec2 (1.8, 0.2), vec2 (2.2, 0.2)));\n\n\td1 = min (d1, max (circle (frag, vec2 (2.9, 0.7), 0.3), 2.8 - frag.x));\n\td1 = min (d1, line (frag, vec2 (2.7, 0.0), vec2 (2.7, 1.0)));\n\td1 = min (d1, line (frag, vec2 (2.9, 0.4), vec2 (3.2, 0.0)));\n\n\td1 = min (d1, line (frag, vec2 (3.6, 0.0), vec2 (3.6, 1.0)));\n\td1 = min (d1, line (frag, vec2 (3.6, 0.0), vec2 (4.0, 0.0)));\n\n\td1 = min (d1, line (frag, vec2 (4.4, 0.0), vec2 (4.4, 1.0)));\n\n\td1 = min (d1, line (frag, vec2 (4.8, 0.0), vec2 (4.8, 1.0)));\n\td1 = min (d1, line (frag, vec2 (4.8, 0.0), vec2 (5.3, 0.0)));\n\td1 = min (d1, line (frag, vec2 (4.8, 0.5), vec2 (5.3, 0.5)));\n\td1 = min (d1, line (frag, vec2 (4.8, 1.0), vec2 (5.3, 1.0)));\n\n\td1 -= 0.16;\n\n\tfloat d2 = max (circle (frag, vec2 (0.2, 1.7), 0.3), frag.y - 1.6);\n\td2 = min (d2, line (frag, vec2 (0.5, 1.8), vec2 (0.5, 2.2)));\n\n\td2 = min (d2, line (frag, vec2 (0.9, 1.4), vec2 (0.9, 2.2)));\n\td2 = min (d2, line (frag, vec2 (0.9, 1.4), vec2 (1.4, 1.4)));\n\td2 = min (d2, line (frag, vec2 (0.9, 1.8), vec2 (1.3, 1.8)));\n\td2 = min (d2, line (frag, vec2 (0.9, 2.2), vec2 (1.4, 2.2)));\n\n\td2 = min (d2, max (circle (frag, vec2 (4.9, 2.0), 0.2), frag.x - 4.8));\n\td2 = min (d2, max (circle (frag, vec2 (5.1, 1.6), 0.2), 5.2 - frag.x));\n\td2 = min (d2, line (frag, vec2 (5.0, 2.2), vec2 (5.15, 2.2)));\n\td2 = min (d2, line (frag, vec2 (4.99, 1.8), vec2 (5.01, 1.8)));\n\td2 = min (d2, line (frag, vec2 (4.75, 1.4), vec2 (5.0, 1.4)));\n\n\td2 = min (d2, line (frag, vec2 (4.3, 1.4), vec2 (4.3, 2.2)));\n\n\td2 = min (d2, line (frag, vec2 (3.9, 1.8), vec2 (3.9, 2.2)));\n\td2 = min (d2, line (frag, vec2 (3.3, 1.8), vec2 (3.3, 2.2)));\n\td2 = min (d2, max (circle (frag, vec2 (3.6, 1.7), 0.3), frag.y - 1.6));\n\n\td2 = min (d2, max (circle (frag, vec2 (2.5, 2.0), 0.2), frag.x - 2.4));\n\td2 = min (d2, max (circle (frag, vec2 (2.7, 1.6), 0.2), 2.8 - frag.x));\n\td2 = min (d2, line (frag, vec2 (2.6, 2.2), vec2 (2.75, 2.2)));\n\td2 = min (d2, line (frag, vec2 (2.59, 1.8), vec2 (2.61, 1.8)));\n\td2 = min (d2, line (frag, vec2 (2.35, 1.4), vec2 (2.6, 1.4)));\n\n\td2 -= 0.1;\n\n\t#ifdef EFFECT\n\td1 += 0.03 * sin (10.0 * sin (iTime * 0.1) * (frag.x + frag.y));\n\td2 *= 1.0 + 0.9 * sin ((iTime + frag.x + frag.y) * 20.0);\n\t#endif\n\n\tfloat tint = smoothstep (0.02, 0.0, min (d1, d2));\n\tif (d1 < d2) {\n\t\ttint *= 0.8;\n\t}\n\tfragColor = vec4 (tint, tint, tint, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "llXGD4",
    "date": "1422347978",
    "viewed": 750,
    "name": "[2TC 15] Voxel land",
    "description": "Remake of my [url=https://www.shadertoy.com/view/XlfGR4]Voxel land[/url].",
    "likes": 16,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2tc15"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// Created by Nicolas Robert (Nrx) - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Entry for [2TC 15] (= 280 chars or less, as counted by Shadertoy)\nvoid mainImage (out vec4 f, vec2 p) {\n\tf *= 0.;\n\tvec4 r = f, P = f, T;\n\tr.xy = p / iResolution.y - .8;\n\t++r.y;\n\tfor (int i = 0; i < 42; ++i)\n\t\tif ((p.x = cos (P.x * P.y + iTime * 4.) - 15.) < p.y)\n\t\t\tP += T = p.x > (p.y = min (f.x, f.y) * (r.y - 2.)) ? f - f : step (f, f.yxzw) * sign (r),\n\t\t\tf += T / r;\n\tf = .4 + .4 * sin (P) - .2 * T.x - .1 * T.y;\n}\n\n/*\n// Below: simplified version (206 chars)\nvoid mainImage (out vec4 f, vec2 p) {\n\tf *= 0.;\n\tvec4 r, P = f, T;\n\tr.xy = p / iResolution.y - .8;\n\t++r.y;\n\tfor (int i = 0; i < 42; ++i)\n\t\tif (cos (P.x * P.y + iTime * 4.) - 15. < min (f.x, f.y) * (r.y - 2.))\n\t\t\tP += T = step (f, f.yxzw) * sign (r),\n\t\t\tf += T / r;\n\tf = .6 + .4 * sin (P);\n}\n*/\n\n/*\n// Below: code to demonstrate how to move the camera (296 chars)\nvoid mainImage (out vec4 f, vec2 p) {\n\tfloat t = iTime * 4., m = t, h;\n\tvec4 N = vec4 (cos (t), t, -.8, .2),\n\t\tr = vec4 (p, p) / iResolution.y + N.zwxy,\n\t\tS = sign (r),\n\t\tT = (.5 + .5 * S - fract (N)) / r,\n\t\tP = floor (N);\n\tfor (int i = 0; i < 42; ++i)\n\t\tif ((h = cos (P.x * P.y + t) - 9.) < m)\n\t\t\tP += N = h > (m = min (T.x, T.y) * (r.y - 2.)) ? N - N : step (T, T.yxww) * S,\n\t\t\tT += N / r;\n\tf = cos (P) + N.x * .4 + N.y * .2;\n}\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Mtl3DN",
    "date": "1422273698",
    "viewed": 706,
    "name": "[2TC 15] Dance floor",
    "description": "Remake of my [url=https://www.shadertoy.com/view/lsBXDW]Dance floor[/url].",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2tc15"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRr",
       "filepath": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// Created by Nicolas Robert (Nrx) - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Entry for [2TC 15] (= 280 chars or less, as counted by Shadertoy)\n\n#define T(X) texture (iChannel0, vec2 (X)).x);\nvoid mainImage (out vec4 c, vec2 p) {\n\tvec3 R = iResolution, f = vec3 ((2. * p - R.xy) / R.y, 0);\n\tf *= 5. - cos (f.yxz) * sin (T (0)\n\tfloat r = cos (dot (floor (f), R));\n\tR = step (-.8, -cos (f * 6.3));\n\tc = 3. * fract (r + vec4 (0, .3, .7, 0)) * R.x * R.y * (1. - length (fract (f) - .5)) * cos (r * iDate.w + T (1)\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtX3D7",
    "date": "1422362337",
    "viewed": 375,
    "name": "[2TC 15] Dragooon",
    "description": "Remake of my [url=https://www.shadertoy.com/view/Msj3Wt]Dragoon[/url].",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2tc15"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "// Created by Nicolas Robert (Nrx) - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Entry for [2TC 15] (= 280 chars or less, as counted by Shadertoy)\n\nvoid mainImage (out vec4 f, vec2 w) {\n\tvec3 r = vec3 (w / iResolution.y - .5, 2), p = vec3 (-20, 30, 1), q;\n\tfloat d = .6, c = 0., l = c;\n\tr.y -= d;\n\tfor (int i = 0; i < 99; ++i)\n\t\tif (d > .1 && l < 99.)\n\t\t\tq = p + sin (p.z * .2 + iDate.w),\n\t\t\tl += d = (length (q.xy) - 4. + sin (abs (q.x * q.y) + p.z * 4.) * sin (p.z)) * .1,\n\t\t\tp += r * d,\n\t\t\tc += .01;\n\tf = c * vec4 (2, 1, 0, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lllGW7",
    "date": "1422636289",
    "viewed": 472,
    "name": "[2TC 15] Sound experiment",
    "description": "Remake of my [url=https://www.shadertoy.com/view/MssSDM]Sound experiment[/url].",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2tc15"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGzn",
       "filepath": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// Created by Nicolas Robert (Nrx) - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Entry for [2TC 15] (= 280 chars or less, as counted by Shadertoy)\n\n#define T(X) texture (iChannel0, vec2 (X, 0)).x\nvoid mainImage (out vec4 f, vec2 w) {\n\tfloat t = iTime, r = T (0) * .4, a = t;\n\tvec4 p = vec4 (w, 0, 1) / iResolution.y - .5, c = -p;\n\tfor (float d = 1.; d > 0.; d -= .1)\n\t\tf = c += fract (d + t + vec4 (0, .7, .3, 0))\n\t\t\t* .07 * T (d)\n\t\t\t/ length (p.xy - r * vec2 (cos (a += .63), sin (a)));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4lf3Rf",
    "date": "1423647425",
    "viewed": 24,
    "name": "Stereoscopic Dragoon",
    "description": "Remake of my [url=https://www.shadertoy.com/view/Msj3Wt]Dragoon[/url] for stereoscopic glasses.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "stereoscopic"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define DELTA\t\t\t0.01\n#define RAY_LENGTH_MAX\t300.0\n#define RAY_STEP_MAX\t200\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p) {\n\tp += vec3 (3.0 * sin (p.z * 0.2 + iTime * 2.0), sin (p.z * 0.3 + iTime), 0.0);\n\treturn fixDistance (length (p.xy) - 4.0 + 0.8 * sin (abs (p.x * p.y) + p.z * 4.0) * sin (p.z), 2.5, 0.2);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfloat stereo = sign (fragCoord.x - iResolution.x * 0.5); // STEREOSCOPIC EFFECT\n\tfrag.x -= stereo * 0.5 * iResolution.x / iResolution.y; // STEREOSCOPIC EFFECT\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((17.0 + 5.0 * sin (iTime)) * cos (iTime * 0.2), 12.0 * sin (iTime * 0.2), 0.0);\n\tvec3 forward = vec3 (-origin.x, -origin.y, 22.0 + 6.0 * cos (iTime * 0.2));\n\tvec3 up = vec3 (0.0, 1.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\torigin += rotation [0] * 1.0 * stereo; // STEREOSCOPIC EFFECT (need to adjust the value?)\n\n\t// Ray marching\n\tvec3 p = origin;\n\tfloat dist = RAY_LENGTH_MAX;\n\tfloat rayLength = 0.0;\n\tint stepCount = 0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (p);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = origin + direction * rayLength;\n\t\t++stepCount;\n\t}\n\n\t// Compute the fragment color\n\tvec4 color = vec4 (float (stepCount * 3) / float (RAY_STEP_MAX), float (stepCount) * 1.5 / float (RAY_STEP_MAX), 0.0, 1.0);\n\tvec3 LIGHT = normalize (vec3 (1.0, -3.0, -1.0));\n\tif (dist < DELTA) {\n\t\tvec2 h = vec2 (DELTA, 0.0);\n\t\tvec3 normal = normalize (vec3 (\n\t\t\tgetDistance (p + h.xyy) - getDistance (p - h.xyy),\n\t\t\tgetDistance (p + h.yxy) - getDistance (p - h.yxy),\n\t\t\tgetDistance (p + h.yyx) - getDistance (p - h.yyx)));\n\t\tcolor.rg += 0.5 * max (0.0, dot (normal, LIGHT));\n\t}\n\telse {\n\t\tcolor.b += 0.1 + 0.5 * max (0.0, dot (-direction, LIGHT));\n\t}\n\tcolor = mix (color, vec4 (1.0), smoothstep (0.05, 0.04, distance (frag, vec2 (0.0, 0.8)))); // STEREOSCOPIC EFFECT\n\tfragColor = color;\n}",
     "name": "",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Xt2GRm",
    "date": "1428677010",
    "viewed": 1237,
    "name": "VR City",
    "description": "Simple VR test (Google Cardboard, tested on iPhone 5S). The actual project uses the device's gyroscope to control the camera, here you can use the mouse instead. There is currently no correction of the lenses deformation as I couldn't find the specs...",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "vr"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Note: set \"VR\" to 0.0 for classic (non-VR) rendering / 1.0 for VR.\n// For VR, better increase \"FOV\".\n\n///////////////////\n// Shadertoy (1) //\n///////////////////\n\n// Rendering parameters\n#define FOV\t\t\t\t40.0\n#define IPD\t\t\t\t0.0005\n#define VR \t\t\t\t0.0\n#define headModel\t\tvec3 (0.0, 0.001, 0.0005)\n#define QUALITY_HIGH\n\n// Uniform variables\nvec3 resolution;\nfloat time;\nvec3 headPosition;\nmat3 headRotate;\n\n///////////\n// Unity //\n///////////\n\n// Rendering parameters (optional)\n#define HOLES\n#ifdef QUALITY_HIGH\n\t#define HOLLOW_THICKNESS_MIN\t0.001\n\t#define HOLLOW_THICKNESS_MAX\t0.1\n\t#define SHADOW_LENGTH\t\t\t20.0\n\t#define SHADOW_FACTOR\t\t\t250.0\n#endif\n#define HSV2RGB_FAST\n#define TEXTURE_SCALE\t\t\t\t2.0\n#define GLOW_FACTOR\t\t\t\t\t0.4\n\n// Rendering parameters (mandatory)\n#define RAY_LENGTH_MAX\t\t15.0\n#define RAY_STEP_MAX\t\t120.0\n#define AMBIENT\t\t\t\t0.1\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t2.0\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define DELTA\t0.0001\n#define PI\t\t3.14159265359\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\n// Identifier (color) of the ground\nfloat idGround (in vec2 p) {\n\t#ifdef TEXTURE_SCALE\n\treturn 0.2;\n\t#else\n\tp = fract (p * 19.0) - 0.5;\n\treturn p.x * p.y * 0.004 + 0.008;\n\t#endif\n}\n\n// Distance to the building\nfloat distBuilding (in vec3 p, out float id) {\n\n\t// Take note of the ground coordinates\n\tvec2 ground = p.xz;\n\n\t// Change coordinates to cell space, and get the id of this building\n\tp.xz += 0.5;\n\tid = rand (floor (p.xz));\n\tif (fract (id * 31.0) > 0.7) {\n\n\t\t// Ground (empty cell)\n\t\tid = idGround (ground);\n\t\treturn p.y;\n\t}\n\tp.xz = fract (p.xz) - 0.5;\n\n\t// Rotation\n\tfloat angle = id * PI * 0.5;\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\tp.xz = vec2 (c * p.x + s * p.z, c * p.z - s * p.x);\n\n\t// Translation\n\tangle = id * PI * 5.0;\n\tp.xz += 0.07 * vec2 (cos (angle), sin (angle));\n\n\t// Rounded box\n\tfloat boxHalfSize = 0.25 + 0.1 * cos (id * PI * 7.0);\n\tfloat boxHeight = 1.5 + id * 2.5;\n\tfloat boxRadius = boxHalfSize * (0.5 + 0.5 * cos (id * PI * 11.0));\n\tvec3 o = abs (p) - vec3 (boxHalfSize, boxHeight, boxHalfSize) + boxRadius;\n\tfloat dist = length (max (o, 0.0)) - boxRadius;\n\n\t// Carve this rounded box using other (signed) rounded boxes\n\t#ifdef HOLES\n\t#ifdef HOLLOW_THICKNESS_MIN\n\tfloat thickness = HOLLOW_THICKNESS_MIN + (HOLLOW_THICKNESS_MAX - HOLLOW_THICKNESS_MIN) * fract (id * 13.0);\n\tboxHalfSize -= thickness;\n\tboxHeight -= thickness;\n\tboxRadius = max (0.0, boxRadius - thickness);\n\to = abs (p) - vec3 (boxHalfSize, boxHeight, boxHalfSize) + boxRadius;\n\tdist = max (dist, boxRadius - min (max (o.x, max (o.y, o.z)), 0.0) - length (max (o, 0.0)));\n\tboxHalfSize += thickness;\n\t#endif\n\n\tfloat boxPeriod = boxHalfSize * 0.3 * (0.8 + 0.2 * cos (id * PI * 13.0));\n\tboxHalfSize = boxPeriod * 0.45 * (0.9 + 0.1 * cos (id * PI * 17.0));\n\tboxRadius = boxHalfSize * (0.5 + 0.5 * cos (id * PI * 19.0));\n\to = abs (mod (p, boxPeriod) - 0.5 * boxPeriod) - boxHalfSize + boxRadius;\n\tdist = max (dist, boxRadius - min (max (o.x, max (o.y, o.z)), 0.0) - length (max (o, 0.0)));\n\t#endif\n\n\t// Ground\n\tif (dist > p.y) {\n\t\tdist = p.y;\n\t\tid = idGround (ground);\n\t}\n\treturn dist;\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out float rayStepCount, out float shadow) {\n\n\t// Initialize the returned values\n\tvec3 hitPosition = rayOrigin;\n\trayLength = 0.0;\n\trayStepCount = 0.0;\n\tshadow = 1.0;\n\n\t// Initialize the tracking of the grid cells\n\tvec2 raySign = sign (rayDirection.xz);\n\tvec2 rayDeltaCell;\n\trayDeltaCell.x = rayDirection.x != 0.0 ? raySign.x / rayDirection.x : RAY_STEP_MAX;\n\trayDeltaCell.y = rayDirection.z != 0.0 ? raySign.y / rayDirection.z : RAY_STEP_MAX;\n\tvec2 rayDelta = (0.5 - raySign * (fract (rayOrigin.xz + 0.5) - 0.5)) * rayDeltaCell;\n\tfloat distMax = min (rayDelta.x, rayDelta.y);\n\n\t// Launch the ray\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Get the distance to the building in this grid cell\n\t\tfloat id;\n\t\tfloat dist = distBuilding (hitPosition, id);\n\t\tif (dist < DELTA) {\n\t\t\tshadow = 0.0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Soft shadow\n\t\t#ifdef SHADOW_FACTOR\n\t\tshadow = min (shadow, SHADOW_FACTOR * dist / rayLength);\n\t\t#endif\n\n\t\t// Make sure we haven't reached the next grid cell\n\t\tif (dist > distMax - rayLength) {\n\t\t\tdist = distMax - rayLength + DELTA;\n\t\t\trayDelta += step (rayDelta.xy, rayDelta.yx) * rayDeltaCell;\n\t\t\tdistMax = min (rayDelta.x, rayDelta.y);\n\t\t}\n\n\t\t// March...\n\t\trayLength += dist;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\thitPosition += dist * rayDirection;\n\t\t++rayStepCount;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, out float id) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n \t\th.xxx * distBuilding (p + h.xxx, id) +\n\t\th.xyy * distBuilding (p + h.xyy, id) +\n\t\th.yxy * distBuilding (p + h.yxy, id) +\n\t\th.yyx * distBuilding (p + h.yyx, id)\n\t);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid _main (out vec4 _gl_FragColor, in vec2 _gl_FragCoord) {\n\n\t// Change the position of the head\n\tvec3 headPositionModified = headPosition + vec3 (10.0 * cos (time * 0.1), 0.2 + 3.8 * smoothstep (0.5, -0.5, cos (time * 0.2)), 0.5);\n\n\t// Define the ray corresponding to this fragment\n\tfloat rayStereo = 0.5 * sign (_gl_FragCoord.x - resolution.x * 0.5) * step (0.5, VR);\n\tvec3 rayOrigin = headPositionModified + headRotate * (headModel + vec3 (rayStereo * IPD, 0.0, 0.0));\n\tvec3 rayDirection = headRotate * normalize (vec3 ((2.0 * _gl_FragCoord.x - (1.0 + rayStereo) * resolution.x), 2.0 * _gl_FragCoord.y - resolution.y, 0.5 * resolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tfloat hitStepCount;\n\tfloat hitShadow;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitStepCount, hitShadow);\n\n\t// Get the normal and ID\n\tfloat hitId;\n\tvec3 hitNormal = normal (hitPosition, hitId);\n\n\t// Lighting\n\tfloat lightYawAngle = PI * 0.1;\n\tfloat lightPitchAngle = time * 0.1;\n\tvec3 lightDirection = vec3 (sin (lightYawAngle) * sin (lightPitchAngle), cos (lightPitchAngle), cos (lightYawAngle) * sin (lightPitchAngle));\n\n\tfloat diffuse = 0.0;\n\tfloat specular = 0.0;\n\tif (lightDirection.y > 0.0) {\n\t\tdiffuse = max (0.0, dot (hitNormal, lightDirection));\n\t\tspecular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t#ifdef SHADOW_LENGTH\n\t\tfloat shadowDistance;\n\t\tfloat shadowStepCount;\n\t\tfloat shadow;\n\t\thit (hitPosition + hitNormal * DELTA * 2.0, lightDirection, SHADOW_LENGTH, shadowDistance, shadowStepCount, shadow);\n\t\tdiffuse *= shadow;\n\t\tspecular *= shadow;\n\t\t#endif\n\t}\n\n\t// Set the object color\n\tvec3 color = hsv2rgb (vec3 (hitId * 73.0, 0.8, 0.8));\n\t#ifdef TEXTURE_SCALE\n\tvec3 textureUV = hitPosition * TEXTURE_SCALE;\n\tvec3 textureFactor = abs (hitNormal);\n\tmat3 textureColor = mat3 (\n\t\ttexture (iChannel0, textureUV.yz).rgb,\n\t\ttexture (iChannel0, textureUV.zx).rgb,\n\t\ttexture (iChannel0, textureUV.xy).rgb\n\t\t);\n\tcolor *= textureColor * textureFactor / (textureFactor.x + textureFactor.y + textureFactor.z);\n\t#endif\n\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t// Set the sky color\n\tdiffuse = max (0.0, dot (rayDirection, lightDirection));\n\tfloat skyBelow = min (1.0, 1.0 + lightDirection.y);\n\tvec3 skyColor = mix (vec3 (1.0, 0.4, 0.2), vec3 (0.4, 0.4, 1.0), max (0.0, lightDirection.y));\n\tskyColor += vec3 (1.0, 0.9, 0.6) * pow (diffuse, 8.0);\n\tskyColor = mix (vec3 (0.0, 0.0, 0.1), skyColor, skyBelow);\n\tskyColor *= 0.3 + 0.7 * diffuse;\n\n\t// Blend the object and sky colors\n\tcolor = mix (skyColor, color, pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER));\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Add a glow effect\n\t#ifdef GLOW_FACTOR\n\tcolor += GLOW_FACTOR * (hitStepCount / RAY_STEP_MAX) * (1.0 - hitShadow) * (1.0 - skyBelow) * smoothstep (3.0, 0.0, hitPosition.y);\n\t#endif\n\n\t// Set the fragment color\n\t_gl_FragColor = vec4 (color, 1.0);\n}\n\n///////////////////\n// Shadertoy (2) //\n///////////////////\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Basic initialization\n\tresolution = iResolution;\n\ttime = iTime;\n\n\t// Set the position of the head\n\theadPosition = vec3 (0.0);\n\n\t// Set the orientation of the head\n\tfloat yawAngle = 4.0 * PI * iMouse.x / iResolution.x;\n\tfloat pitchAngle = PI * (0.5 - iMouse.y / iResolution.y);\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\theadRotate [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadRotate [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadRotate [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\t// Set the fragment color\n\t_main (fragColor, fragCoord);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "llB3WW",
    "date": "1429200618",
    "viewed": 887,
    "name": "VR Maze",
    "description": "Simple 3D maze, to be explored in VR. The goal was to make a shader simple enough to run fast on mobile devices. The actual Unity project passes the camera position and orientation to the shader (the orientation comes from the gyroscope).",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "maze",
     "vr"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Note: set \"VR\" to 0.0 for classic (non-VR) rendering / 1.0 for VR.\n// For VR, better set \"FOV\" to 96.0.\n\n// Video of what it looks like on device (iPhone 5S), when controlled by the gyroscope:\n// https://www.facebook.com/video.php?v=10153361200936052\n\n///////////////////\n// Shadertoy (1) //\n///////////////////\n\n// Rendering parameters\n#define FOV\t\t\t\t80.0\n#define IPD\t\t\t\t0.01\n#define VR \t\t\t\t0.0\n#define headModel\t\tvec3 (0.0, 0.02, 0.01)\n#define QUALITY_HIGH\n\n// Uniform variables\nvec3 resolution;\nfloat time;\nvec3 headPosition;\nmat3 headRotate;\nvec3 lightPosition;\nfloat ambientIntensity;\n\n///////////\n// Unity //\n///////////\n\n// Rendering parameters\n#define RAY_STEP_MAX\t\t20.0\n#define RAY_LENGTH_MAX\t\t10.0\n#define EDGE_LENGTH\t\t\t0.1\n#ifdef QUALITY_HIGH\n\t#define EDGE_FULL\n//\t#define TEXTURE\n\t#define SHADOW\n#endif\n#define BUMP_RESOLUTION\t\t500.0\n#define BUMP_INTENSITY\t\t0.3\n#define AMBIENT_NORMAL\t\t0.2\n#define AMBIENT_HIGHLIGHT\t2.5\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t1.5\n#define GAMMA\t\t\t\t0.8\n#define HSV2RGB_FAST\n\n// Math constants\n#define DELTA\t0.002\n#define PI\t\t3.14159265359\n\n// PRNG (unpredictable)\nfloat randUnpredictable (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.6789, 5.4321, 6.7890));\n\tseed += dot (seed.yzx, seed.zxy + vec3 (21.0987, 12.3456, 15.1273));\n\treturn fract (seed.x * seed.y * seed.z * 5.1337);\n}\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// Check whether there is a block at a given voxel edge\nfloat block (in vec3 p, in vec3 n) {\n\tvec3 block = floor (p + 0.5 + n * 0.5);\n\tvec3 blockEven = mod (block, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (block))) *\n\t\tstep (4.5, mod (block.x, 32.0)) *\n\t\tstep (2.5, mod (block.y, 16.0)) *\n\t\tstep (4.5, mod (block.z, 32.0));\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out vec3 hitNormal) {\n\n\t// Launch the ray\n\tvec3 hitPosition = rayOrigin;\n\tvec3 raySign = sign (rayDirection);\n\tvec3 rayInv = 1.0 / rayDirection;\n\tvec3 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Reach the edge of the voxel\n\t\trayLength = min (rayLengthNext.x, min (rayLengthNext.y, rayLengthNext.z));\n\t\thitNormal = step (rayLengthNext.xyz, rayLengthNext.yzx) * step (rayLengthNext.xyz, rayLengthNext.zxy) * raySign;\n\t\thitPosition = rayOrigin + rayLength * rayDirection;\n\n\t\t// Check whether we hit a block\n\t\tif (block (hitPosition, hitNormal) > 0.5 || rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid _main (out vec4 _gl_FragColor, in vec2 _gl_FragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tfloat rayStereo = 0.5 * sign (_gl_FragCoord.x - resolution.x * 0.5) * step (0.5, VR);\n\tvec3 rayOrigin = headPosition + headRotate * (headModel + vec3 (rayStereo * IPD, 0.0, 0.0));\n\tvec3 rayDirection = headRotate * normalize (vec3 ((2.0 * _gl_FragCoord.x - (1.0 + rayStereo) * resolution.x), 2.0 * _gl_FragCoord.y - resolution.y, 0.5 * resolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tvec3 hitNormal;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitNormal);\n\tvec3 hitUV = hitPosition * abs (hitNormal.yzx + hitNormal.zxy);\n\n\t// Basic edge detection\n\tvec3 edgeDistance = fract (hitUV + 0.5) - 0.5;\n\tvec3 edgeDirection = sign (edgeDistance);\n\tedgeDistance = abs (edgeDistance);\n\n\t#ifdef EDGE_FULL\n\tvec3 hitNormalAbs = abs (hitNormal);\n\tvec2 edgeSmooth = vec2 (dot (edgeDistance, hitNormalAbs.yzx), dot (edgeDistance, hitNormalAbs.zxy));\n\tfloat highlightIntensity = (1.0 - block (hitPosition + edgeDirection * hitNormalAbs.yzx, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.x);\n\thighlightIntensity = max (highlightIntensity, (1.0 - block (hitPosition + edgeDirection * hitNormalAbs.zxy, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.y));\n\thighlightIntensity = max (highlightIntensity, (1.0 - block (hitPosition + edgeDirection, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, min (edgeSmooth.x, edgeSmooth.y)));\n\t#else\n\tfloat highlightIntensity = 1.0 - block (hitPosition + step (edgeDistance.yzx, edgeDistance.xyz) * step (edgeDistance.zxy, edgeDistance.xyz) * edgeDirection, hitNormal);\n\thighlightIntensity *= smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, max (edgeDistance.x, max (edgeDistance.y, edgeDistance.z)));\n\t#endif\n\n\t// Texture\n\t#ifdef TEXTURE\n\tvec2 textureUV = vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy)) + 0.5;\n\tfloat textureIntensity = 1.0 - texture (texture, textureUV).a;\n\tfloat texturePhase = 2.0 * PI * randUnpredictable (floor (hitPosition + 0.5 + hitNormal * 1.5));\n\ttextureIntensity *= smoothstep (0.8, 1.0, cos (time * 0.2 + texturePhase));\n\thighlightIntensity = max (highlightIntensity, textureIntensity);\n\t#endif\n\n\t// Set the object color\n\tvec3 color = cos ((hitPosition + hitNormal * 0.5) * 0.05);\n\tcolor = hsv2rgb (vec3 (color.x + color.y + color.z + highlightIntensity * 0.05, 1.0, 1.0));\n\n\t// Lighting\n\tvec3 lightDirection = hitPosition - lightPosition;\n\tfloat lightDistance = length (lightDirection);\n\tlightDirection /= lightDistance;\n\n\tfloat lightIntensity = min (1.0, 1.0 / lightDistance);\n\t#ifdef SHADOW\n\tfloat lightHitDistance;\n\tvec3 lightHitNormal;\n\thit (hitPosition - hitNormal * DELTA, -lightDirection, lightDistance, lightHitDistance, lightHitNormal);\n\tlightIntensity *= step (lightDistance, lightHitDistance);\n\t#endif\n\n\t// Bump mapping\n\tvec3 bumpUV = floor (hitUV * BUMP_RESOLUTION) / BUMP_RESOLUTION;\n\thitNormal = normalize (hitNormal + (1.0 - highlightIntensity) * BUMP_INTENSITY * (hitNormal.yzx * (randUnpredictable (bumpUV) - 0.5) + hitNormal.zxy * (randUnpredictable (bumpUV + 1.0) - 0.5)));\n\n\t// Shading\n\tfloat ambient = mix (AMBIENT_NORMAL, AMBIENT_HIGHLIGHT, highlightIntensity) * ambientIntensity;\n\tfloat diffuse = max (0.0, dot (hitNormal, lightDirection));\n\tfloat specular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\tcolor = (ambient + diffuse * lightIntensity) * color + specular * lightIntensity;\n\tcolor *= pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER);\n\n\t// Light source\n\tlightDirection = lightPosition - rayOrigin;\n\tif (dot (rayDirection, lightDirection) > 0.0) {\n\t\tlightDistance = length (lightDirection);\n\t\tif (lightDistance < hitDistance) {\n\t\t\tvec3 lightNormal = cross (rayDirection, lightDirection);\n\t\t\tcolor += smoothstep (0.001, 0.0, dot (lightNormal, lightNormal));\n\t\t}\n\t}\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\t_gl_FragColor = vec4 (color, 1.0);\n}\n\n///////////////////\n// Shadertoy (2) //\n///////////////////\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Basic initialization\n\tresolution = iResolution;\n\ttime = iTime;\n\n\t// Set the position of the head\n\theadPosition = vec3 (64.0 * cos (iTime * 0.1), 9.0 + 9.25 * cos (iTime * 0.5), 2.0 + 2.25 * cos (iTime));\n\n\t// Set the orientation of the head\n\tfloat yawAngle;\n\tfloat pitchAngle;\n\tif (iMouse.z > 0.5) {\n\t\tyawAngle = 4.0 * PI * iMouse.x / iResolution.x;\n\t\tpitchAngle = -4.0 * PI * iMouse.y / iResolution.y;\n\t} else {\n\t\tyawAngle = iTime;\n\t\tpitchAngle = iTime * 0.2;\n\t}\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\theadRotate [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadRotate [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadRotate [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\t// Lighting\n\tlightPosition = headPosition + headRotate * vec3 (0.2 * sin (iTime * 2.0), 0.2 * sin (iTime * 3.0), 0.2 * sin (iTime) + 0.5);\n\tambientIntensity = max (step (1.0, mod (time, 10.0)), step (0.25, randUnpredictable (vec3 (time))));\n\n\t// Set the fragment color\n\t_main (fragColor, fragCoord);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MljGDy",
    "date": "1432205468",
    "viewed": 302,
    "name": "dFdx misunderstanding",
    "description": "That's a little experiment to investigate a problem I'm facing with the functions dFdx and dFdy, which don't return what I expect.",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "derivatives",
     "dfdx"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "// Little experiment to investigate a problem I'm facing with the functions dFdx and dFdy, which don't\n// return what I expect (I must misunderstand something... but I don't know what!)\n\n// A bit more explanations:\n\n// I know the GPU actually computes fragments 4 by 4, using groups of 2x2 pixels. The dFdx function (and\n// other similar functions) allows a fragment to access information stored by the fragment next to it in this\n// 2x2 block (note: it can only gets the value of another fragment in the same block, not adjacent blocks).\n\n// Also, if we have the following fragments to render:\n//  ---------\n// | a b c d |\n// | e f g h |\n// | i j k l |\n// | m n o p |\n//  ---------\n// ...they will actually be grouped and computed this way:\n//  -----+-----\n// | a b | c d |\n// | e f | g h |\n// +-----+-----+\n// | i j | k l |\n// | m n | o p |\n//  -----+-----\n// ... and my understanding is that the dFdx function will return the following:\n// dFdx (variable) [fragment a] = variable value [fragment b] - variable value [fragment a]\n// dFdx (variable) [fragment b] = variable value [fragment b] - variable value [fragment a]\n// dFdx (variable) [fragment c] = variable value [fragment d] - variable value [fragment c]\n// dFdx (variable) [fragment d] = variable value [fragment d] - variable value [fragment c]\n// dFdx (variable) [fragment e] = variable value [fragment f] - variable value [fragment e]\n// dFdx (variable) [fragment f] = variable value [fragment f] - variable value [fragment e]\n// (etc.)\n\n// Also, if a variable has the following values in a 2x2 block, the dFdx at each fragment will be:\n// 0 1   =>    1  1\n// 0 1   =>    1  1\n//\n// 1 0   =>   -1 -1\n// 1 0   =>   -1 -1\n//\n// 0 1   =>    1  1\n// 1 0   =>   -1 -1\n//\n// 1 0   =>   -1 -1\n// 0 1   =>    1  1\n\n// ..and so, whatever the case, the program below shall always return:\n// .5 .5\n// .5 .5\n// (= grey color on the right side of the screen)\n\n// PROBLEM (at least, on my Mac - there might be a different behavior with other GPU?):\n// - It works with a vertical strip pattern (cases 1 & 2 above),\n// - It does NOT work with a checkboard pattern (cases 3 and 4).\n\n#define CHECKBOARD // Checkboard pattern that exhibits the problem\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Define the color: it is either 0 or 1:\n\t// - Either in a checkboard fashion (all neighboring pixels are different)\n\t// - Or with vertical strips (neighboring pixels on the X axis are always different)\n\t#ifdef CHECKBOARD\n\tfloat color = step (1.0, mod (fragCoord.x + fragCoord.y + iTime, 2.0));\n\t#else\n\tfloat color = step (1.0, mod (fragCoord.x + iTime, 2.0));\n\t#endif\n\n\t// Take the partial derivate of \"color\" using dFdx\n\tfloat derivative = dFdx (color);\n\n\t// Since dFdx actually returns the same number for the left and right fragment in the 2x2 block,\n\t// invert it depending on the oddity of the fragment\n\tderivative *= sign (mod (fragCoord.x, 2.0) - 1.0);\n\n\t// Correct the color using the derivative, so that every fragment is the average of its value and\n\t// the value of its neighbor\n\tfloat correctedColor = color - 0.5 * derivative;\n\n\t// Display \"color\" on the left side of the screen, and \"correctedColor\" on the right\n\t// Here, we expect the right side to be fully grey... but:\n\t// - It's ok with vertical strips\n\t// - It doesn't work with the checkboard pattern (only 1 row over 2 is grey)?!?\n\tif (fragCoord.x > 0.5 * iResolution.x) {\n\t\tcolor = correctedColor;\n\t}\n\tfragColor = vec4 (vec3 (color), 1.0);\n}",
     "name": "",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtB3Dt",
    "date": "1433413020",
    "viewed": 16,
    "name": "Color lottery",
    "description": "A kind of color lottery (rendering part only).",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "color",
     "hsv"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xdf3Rn",
       "filepath": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm",
       "type": "video",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "///////////\n// Unity //\n///////////\n\n// Precision setting (shared between the vertex shader and the fragment shader)\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Constants shared by the vertex shader and the fragment shader\nconst float RING_RADIUS_MIN = 0.4;\nconst float RING_RADIUS_MAX = 0.8;\nconst float GOAL_RADIUS = 0.08;\nconst float GOAL_THICKNESS = 0.01;\nconst float RESULT_THICKNESS = 0.02;\nconst float RESULT_SIZE = 0.1;\nconst float RESULT_MOVEMENT = 0.02;\nconst float OUTLINE = 0.02;\nconst float BLUR = 0.02;\nconst float PI = 3.14159265359;\n\n// Variables shared between the OpenGL ES environment and the vertex & fragment shaders (uniform)\nvec2 resolution = iResolution.xy;\nfloat time = iTime;\n#define video iChannel0\nvec2 videoResolution = iChannelResolution [0].xy;\nvec4 videoRotation = vec4 (1.0, 0.0, 0.0, 1.0);\nfloat videoDisplay;\nfloat videoError;\nfloat goal;\nfloat result;\n\n// Variables shared between the vertex shader and the fragment shader (varying)\nvec2 videoScale;\nfloat resultScale;\nvec2 resultPoint1;\nvec2 resultPoint2;\nvec2 resultPoint3;\nvec2 resultPoint4;\nvec2 resultOffset;\n\n// Main function (vertex shader)\nvoid mainVertex () {\n\n\t// Video\n\tfloat screenRatio = resolution.x / resolution.y;\n\tfloat videoRatio = videoResolution.x / videoResolution.y;\n\tvideoScale = vec2 (screenRatio, videoRatio) / max (screenRatio, videoRatio);\n\tvideoScale *= min (resolution.x, resolution.y) / resolution;\n\n\t// Result\n\tresultScale = 1.0 - videoError;\n\tfloat offsetNear = RESULT_MOVEMENT * cos (time * 20.0) * resultScale;\n\tfloat offsetFar = offsetNear + RESULT_SIZE * resultScale;\n\tvec2 direction = vec2 (sin (result - goal), cos (result - goal));\n\tresultPoint1 = (RING_RADIUS_MIN - offsetNear) * direction;\n\tresultPoint2 = (RING_RADIUS_MIN - offsetFar) * direction;\n\tresultPoint3 = (RING_RADIUS_MAX + offsetNear) * direction;\n\tresultPoint4 = (RING_RADIUS_MAX + offsetFar) * direction;\n\tresultOffset = vec2 (direction.y, -direction.x) * 0.5 * RESULT_SIZE * resultScale;\n\n\t// Position\n//\tgl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n}\n\n// Segment\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Main function (fragment shader)\nvoid mainFragment (out vec4 _gl_FragColor, in vec2 _gl_FragCoord) {\n\n\t// Get the fragment position\n\tvec2 frag = (2.0 * _gl_FragCoord.xy - resolution) / min (resolution.x, resolution.y);\n\n\t// Deformation\n\tfloat dist = length (frag);\n\tfloat ringOutside = step (RING_RADIUS_MAX, dist);\n\tvec2 fragDeformed = frag * (1.0 + ringOutside * 0.03 * cos (dist * 5.0 + time * 10.0));\n\n\t// Wave background\n\tvec3 color =  hsv2rgb (vec3 (goal / (2.0 * PI), 0.3 - 0.3 * frag.y, 0.8));\n\tcolor = mix (color, vec3 (1.0), smoothstep (0.5, 1.0, cos (frag.y * 20.0 + 5.0 * cos (frag.x + time))));\n\n\t// Video\n\tvec2 fragVideo = 0.5 + 0.5 * mat2 (videoRotation) * (videoScale * fragDeformed);\n\tcolor = mix (color, texture (video, fragVideo).rgb, videoDisplay);\n\n\t// Error\n\tcolor = mix (color, vec3 (0.3) * smoothstep (-0.5, 0.5, cos (30.0 * fragDeformed.x) * cos (30.0 * fragDeformed.y)), videoDisplay * videoError * ringOutside);\n\n\t// Ring\n\tdist = max (dist - RING_RADIUS_MAX, RING_RADIUS_MIN - dist);\n\tcolor = mix (color, vec3 (0.0), smoothstep (OUTLINE + BLUR, OUTLINE, dist));\n\tcolor = mix (color, hsv2rgb (vec3 ((goal + atan (frag.x, frag.y)) / (2.0 * PI), 0.8, 1.0)), smoothstep (BLUR, 0.0, dist));\n\n\t// Result\n\tfloat halfThickness = RESULT_THICKNESS * 0.5 * resultScale;\n\tdist = segDist (frag, resultPoint1, resultPoint2 - resultOffset);\n\tdist = min (dist, segDist (frag, resultPoint1, resultPoint2 + resultOffset));\n\tdist = min (dist, segDist (frag, resultPoint3, resultPoint4 - resultOffset));\n\tdist = min (dist, segDist (frag, resultPoint3, resultPoint4 + resultOffset));\n\tcolor = mix (color, vec3 (0.0), videoDisplay * resultScale * smoothstep (halfThickness + OUTLINE + BLUR, halfThickness + OUTLINE, dist));\n\tcolor = mix (color, vec3 (resultScale), videoDisplay * resultScale * smoothstep (halfThickness + BLUR, halfThickness, dist));\n\n\t// Goal\n\tdist = abs (segDist (frag, vec2 (0.0, RING_RADIUS_MIN), vec2 (0.0, RING_RADIUS_MAX)) - GOAL_RADIUS);\n\tcolor = mix (color, vec3 (0.0), smoothstep (GOAL_THICKNESS * 0.5 + OUTLINE + BLUR, GOAL_THICKNESS * 0.5 + OUTLINE, dist));\n\tcolor = mix (color, hsv2rgb (vec3 (goal / (2.0 * PI), 0.8, 1.0)), smoothstep (GOAL_THICKNESS * 0.5 + BLUR, GOAL_THICKNESS * 0.5, dist));\n\n\t// Set the fragment color\n\t_gl_FragColor = vec4 (color, 1.0);\n}\n\n///////////////\n// Shadertoy //\n///////////////\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Set the uniform variables\n\tvideoDisplay = 0.5 + 0.5 * cos (iTime);\n\tvideoError = 0.5 + 0.5 * cos (iTime * 0.3);\n\tgoal = 6.0 * (iTime + cos (iTime));\n\tresult = PI * cos (iTime * 0.2);\n\n\t// Set the fragment color\n\tmainVertex ();\n\tmainFragment (fragColor, fragCoord);\n}",
     "name": "",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlsSR4",
    "date": "1434895946",
    "viewed": 537,
    "name": "Psycho dots",
    "description": "Simple effect that my daughter asked me for ;).",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PIXELS 40.0\n\nconst float PI = 3.14159;\n\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.6789, 5.4321));\n\tseed += dot (seed.yx, seed + vec2 (12.3456, 15.1273));\n\treturn fract (seed.x * seed.y * 5.1337);\n}\n\nvec3 hsv2rgb (in float h, in float s, in float v) {\n\treturn v * (1.0 + 0.5 * s * (cos (2.0 * PI * (h + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\t#ifdef PIXELS\n\tvec2 pixels = frag * PIXELS;\n\tfrag = (floor (pixels) + 0.5) / PIXELS;\n\tpixels = fract (pixels) - 0.5;\n\t#endif\n\n\tfloat radius = max (length (frag), 0.3);\n\tfrag *= 1.0 + 0.1 * cos (radius * 3.0 - iTime * 7.0) / radius;\n\tfloat light = smoothstep (-0.7, 0.7, cos (iTime * 0.4));\n\tvec3 colorBackground = hsv2rgb (radius * 0.4 - iTime * 1.5, 0.5, light);\n\n\tfloat angle = 2.0 * PI * cos (iTime * 0.2 + 0.5 * PI * cos (iTime * 0.1));\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\tfrag = (4.0 + 1.5 * cos (iTime)) * mat2 (c, s, -s, c) * frag;\n\tfrag += 5.0 * vec2 (s, c);\n\n\tfloat random = rand (floor (frag));\n\tfrag = fract (frag) - 0.5;\n\tangle = atan (frag.y, frag.x);\n\tradius = length (frag);\n\tradius *= 1.0 + (0.3 + 0.3 * cos (angle * 5.0 + PI * cos (random * PI * 2.0 + iTime * 5.0))) * smoothstep (-0.5, 0.5, cos (random * PI * 2.0 + iTime * 2.0));\n\n\tvec3 colorShape = hsv2rgb (radius * 0.6 + random * 13.0 - iTime, 0.5, 1.0 - light);\n\tfloat display = smoothstep (0.5, 0.4, radius);\n\tdisplay *= smoothstep (-0.5, 0.5, cos (random * PI * 2.0 + iTime * 1.5));\n\n\tfragColor = vec4 (mix (colorBackground, colorShape, display), 1.0);\n\t#ifdef PIXELS\n\tfragColor *= 1.0 - dot (pixels, pixels);\n\t#endif\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4llXWn",
    "date": "1436456714",
    "viewed": 5,
    "name": "Ghost",
    "description": "Simple ghost view effect.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "camera"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sf3zn",
       "filepath": "/presets/webcam.png",
       "type": "webcam",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    // Get the fragment position\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\t// Deformation\n\tfrag *= 1.0 + 0.03 * cos (length (frag) * 5.0 + iTime * 10.0);\n\n\t// Video\n\tvec2 fragVideo = 0.5 + 0.5 * frag * iResolution.y / iResolution.xy;\n\tfragColor = smoothstep (vec4 (1.5 + 0.5 * cos (iTime)), vec4 (0.2 + 0.05 * cos (iTime * 2.0)), texture (iChannel0, fragVideo));\n}",
     "name": "",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ltfXDM",
    "date": "1437023412",
    "viewed": 7186,
    "name": "A lonely diamond...",
    "description": "Variation of my original [url=https://www.shadertoy.com/view/ldfXzn]Diamonds are Forever[/url].\nUse the mouse (X axis) to change the shape.",
    "likes": 91,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "transparency"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t40\n#define COLOR\t\t\t\tvec3 (0.8, 0.8, 0.9)\n#define ALPHA\t\t\t\t0.9\n#define REFRACT_INDEX\t\tvec3 (2.407, 2.426, 2.451)\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n\n// Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n// Rotation matrix\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\n// Rotation matrix (rotation on the Y axis)\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n// Distance to the scene\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\nfloat getDistance (in vec3 p) {\n\tp = mRotate (vec3 (iTime)) * p;\n\n\tfloat topCut = p.y - 1.0;\n\tfloat angleStep = PI / (iMouse.z < 0.5 ? 8.0 : 2.0 + floor (18.0 * iMouse.x / iResolution.x));\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tvec3 q = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.5;\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\n\tq = vRotateY (p, angle);\n\tfloat topB = dot (q, normalTopB) - 1.85;\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistance (p + h.xxx) +\n\t\th.xyy * getDistance (p + h.xyy) +\n\t\th.yxy * getDistance (p + h.yxy) +\n\t\th.yyx * getDistance (p + h.yyx)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nfloat raycast (in vec3 origin, in vec3 direction, in vec4 normal, in float color, in vec3 channel) {\n\n\t// The ray continues...\n\tcolor *= 1.0 - ALPHA;\n\tfloat intensity = ALPHA;\n\tfloat distanceFactor = 1.0;\n\tfloat refractIndex = dot (REFRACT_INDEX, channel);\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tvec3 refraction = refract (direction, normal.xyz, distanceFactor > 0.0 ? 1.0 / refractIndex : refractIndex);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t}\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\tnormal.w += distMin;\n\t\t\tif (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (dist >= 0.0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tnormal.xyz = distanceFactor * getNormal (origin);\n\n\t\t// Basic lighting\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat localColor = (AMBIENT + relfectionDiffuse) * dot (COLOR, channel) + relfectionSpecular;\n\t\t\tcolor += localColor * (1.0 - ALPHA) * intensity;\n\t\t\tintensity *= ALPHA;\n\t\t}\n\t}\n\n\t// Get the background color\n\tfloat backColor = dot (texture (iChannel0, direction).rgb, channel);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * intensity;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = 7.0 * vec3 ((cos (iTime * 0.1)), sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tfloat dist = RAY_LENGTH_MAX;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (origin);\n\t\tfloat distMin = max (dist, DELTA);\n\t\tnormal.w += distMin;\n\t\tif (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * distMin;\n\t}\n\n\t// Check whether we hit something\n\tif (dist >= 0.0) {\n\t\tfragColor.rgb = texture (iChannel0, direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * COLOR + relfectionSpecular;\n\n\t\t// Cast a ray for each color channel\n\t\tfragColor.r = raycast (origin, direction, normal, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\tfragColor.g = raycast (origin, direction, normal, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\tfragColor.b = raycast (origin, direction, normal, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XllXRf",
    "date": "1438600995",
    "viewed": 1048,
    "name": "A glass of rosé",
    "description": "Summer time! A glass of rosé anyone? (Or else, you can get [url=https://www.shadertoy.com/view/llsXzf]a cup of champagne[/url]!)\nNote: Click to get the Holy Grail instead :).",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "transparency"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t80\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n\n// Rendering options (for those who have a slow GPU)\n//#define ICE_CUBE\n#define PROPAGATION\n#define DISPERSION\n\n// Macros used to handle color channels\n#ifdef DISPERSION\n\t#define COLOR float\n\t#define CHANNEL(x) dot (x, channel)\n#else\n\t#define COLOR vec3\n\t#define CHANNEL(x) x\n#endif\n\n// Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n// Smooth minimum\nfloat smin (in float a, in float b, in float k) {\n\tfloat h = clamp (0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n\treturn mix (a, b, h) - k * h * (1.0 - h);\n}\n\n// Materials\nstruct Material {\n\tvec3 color;\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\n\tvec3 refractIndex; // not used if behavior < 0.0\n};\nMaterial getMaterial (in int materialIndex) {\n\tMaterial material;\n\tif (materialIndex == 0) { // Glass\n\t\tmaterial = Material (vec3 (0.8, 0.8, 1.0), iMouse.z < 0.5 ? 0.9 : -0.9, vec3 (1.50, 1.55, 1.60));\n\t} else if (materialIndex == 1) { // Wine\n\t\tmaterial = Material (vec3 (0.7, 0.0, 0.1), iMouse.z < 0.5 ? 0.8 : 0.4, vec3 (1.20, 1.21, 1.22));\n\t} else if (materialIndex == 2) { // Table\n\t\tmaterial = Material (vec3 (0.5, 0.5, 1.0), iMouse.z < 0.5 ? -0.5 : 0.5, vec3 (2.0, 2.1, 2.2));\n\t} else { // materialIndex == 3 // Ice cube\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.9, vec3 (1.31, 1.31, 1.31));\n\t}\n\treturn material;\n}\n\n// Distance to the glass\nfloat getDistanceGlass (in vec3 p, in float d, in float dxz) {\n\td = max (max (d - 1.45, 1.4 - d), p.y - 0.5);\n\td = min (d, max (dxz - 1.0, p.y + 3.0));\n\td = smin (d, max (dxz - 0.2, p.y + 1.4), iMouse.z < 0.5 ? 0.2 : 0.05);\n\treturn max (d, -p.y - 3.05);\n}\n\n// Distance to the wine\nfloat getDistanceWine (in vec3 p, in float d) {\n\treturn max (d - 1.4, p.y + p.x * 0.1 * cos (iTime * 2.0));\n}\n\n// Distance to the table\nfloat getDistanceTable (in vec3 p, in float dxz) {\n\treturn max (max (dxz - 2.0, p.y + 3.05), -p.y - 4.0);\n}\n\n// Distance to the ice cube\nfloat getDistanceIceCube (in vec3 p) {\n\tfloat a = 0.2 * cos (iTime);\n\tp = vec3 (p.x, mat2 (cos (a), sin (a), -sin(a), cos(a)) * p.yz);\n\tp += vec3 (0.5, 0.25 - 0.1 * cos (iTime * 1.5), 0.0);\n\tconst float r = 0.08;\n\tvec3 o = abs (p) - 0.3 + r;\n\tfloat d = length (max (o, 0.0)) + min (max (o.x, max (o.y, o.z)), 0.0) - r;\n\treturn d + 0.03 * cos (p.x * 9.0) * cos (p.y * 9.0 + 3.0) * cos (p.z * 9.0 + 6.0);\n}\n\n// Distance to a given material\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\n\tfloat materialDist;\n\tif (materialIndex == 0) {\n\t\tmaterialDist = getDistanceGlass (p, length (p), length (p.xz));\n\t} else if (materialIndex == 1) {\n\t\tmaterialDist = getDistanceWine (p, length (p));\n\t} else if (materialIndex == 2) {\n\t\tmaterialDist = getDistanceTable (p, length (p.xz));\n\t} else { // materialIndex == 3\n\t\tmaterialDist = getDistanceIceCube (p);\n\t}\n\treturn materialDist;\n}\n\n// Distance to the scene\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\n\tfloat d = length (p);\n\tfloat dxz = length (p.xz);\n\n\t// Air\n\tmaterialTo = -1;\n\tfloat sceneDist = RAY_LENGTH_MAX;\n\n\t// Wine\n\tfloat materialDist = getDistanceWine (p, d);\n\tMATERIAL_PROCESS (1)\n\n\t// Ice cube\n\t#ifdef ICE_CUBE\n\tif (iMouse.z < 0.5) {\n\t\tmaterialDist = getDistanceIceCube (p);\n\t\tMATERIAL_PROCESS (3)\n\t}\n\t#endif\n\n\t// Glass\n\tmaterialDist = getDistanceGlass (p, d, dxz);\n\tMATERIAL_PROCESS (0)\n\n\t// Table\n\tmaterialDist = getDistanceTable (p, dxz);\n\tMATERIAL_PROCESS (2)\n\n\t// Return the distance\n\treturn sceneDist;\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p, in int materialIndex) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\n\n\t// Check the behavior of the material\n\tMaterial material = getMaterial (materialTo);\n\tfloat alpha = abs (material.behavior);\n\tcolor *= 1.0 - alpha;\n\n\t// The ray continues...\n\tint materialFrom = -1;\n\tfloat refractIndexFrom = 1.0;\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tfloat refractIndexTo;\n\t\tvec3 refraction;\n\t\tif (materialTo == -1) {\n\t\t\trefractIndexTo = 1.0;\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\n\t\t} else {\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\n\t\t}\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tmaterialFrom = materialTo;\n\t\t\trefractIndexFrom = refractIndexTo;\n\t\t}\n\n\t\t// Ray marching\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\n\t\t\tnormal.w += dist;\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * dist;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (materialFrom == materialTo) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tif (materialTo == -1) {\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\n\t\t} else {\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t\t// Basic lighting\n\t\t\tmaterial = getMaterial (materialTo);\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\n\t\t\tfloat localAlpha = abs (material.behavior);\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\n\t\t\talpha *= localAlpha;\n\t\t}\n\t}\n\n\t// Get the background color\n\tCOLOR backColor = CHANNEL (texture (iChannel0, direction).rgb);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * alpha;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 4.0));\n\n\t// Set the camera\n\tvec3 origin = 6.0 * vec3 (cos (iTime * 0.1), 0.3 + 0.7 * sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\torigin.y -= 1.0;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tint materialTo = -1;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\n\t\tnormal.w += dist;\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * dist;\n\t}\n\n\t// Check whether we hit something\n\tif (materialTo == -1) {\n\t\tfragColor.rgb = texture (iChannel0, direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\n\n\t\t// The ray continues...\n\t\t#ifdef PROPAGATION\n\t\t\t#ifdef DISPERSION\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t\t\t#else\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\n\t\t\t#endif\n\t\t#endif\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "llsXzf",
    "date": "1438695279",
    "viewed": 708,
    "name": "A cup of champagne",
    "description": "That's for those who don't like [url=https://www.shadertoy.com/view/XllXRf]rosé[/url] (but who like [url=https://www.shadertoy.com/view/ltfXDM]diamonds[/url]?) ;).",
    "likes": 12,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "transparency"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t80\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define DEFORMATION\t\t\t2.2\n\n// Rendering options (for those who have a slow GPU)\n#define PROPAGATION\n#define DISPERSION\n\n// Macros used to handle color channels\n#ifdef DISPERSION\n\t#define COLOR float\n\t#define CHANNEL(x) dot (x, channel)\n#else\n\t#define COLOR vec3\n\t#define CHANNEL(x) x\n#endif\n\n// Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n// Smooth minimum\nfloat smin (in float a, in float b, in float k) {\n\tfloat h = clamp (0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n\treturn mix (a, b, h) - k * h * (1.0 - h);\n}\n\n// Materials\nstruct Material {\n\tvec3 color;\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\n\tvec3 refractIndex; // not used if behavior < 0.0\n};\nMaterial getMaterial (in int materialIndex) {\n\tMaterial material;\n\tif (materialIndex == 0) { // Glass\n\t\tmaterial = Material (vec3 (0.8, 0.8, 0.8), 0.9, vec3 (1.50, 1.55, 1.60));\n\t} else if (materialIndex == 1) { // Champagne\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.0), 0.8, vec3 (1.50, 1.55, 1.60));\n    } else { // materialIndex == 2 // Table\n\t\tmaterial = Material (vec3 (0.5, 0.5, 1.0), -0.5, vec3 (2.0, 2.1, 2.2));\n\t}\n\treturn material;\n}\n\n// Distance to the glass\nfloat getDistanceGlass (in vec3 p, in float d, in float dxz) {\n\td = max (max (d - 1.45, 1.4 - d) / DEFORMATION, p.y - 0.4);\n\td = min (d, max (dxz - 0.5, p.y + 2.5));\n\td = smin (d, max (dxz - 0.08, p.y + 1.4), 0.1);\n\treturn max (d, -p.y - 2.55);\n}\n\n// Distance to the champagne\nfloat getDistanceChampagne (in vec3 p, in float d) {\n\td = max ((d - 1.4) / DEFORMATION, p.y + p.x * 0.1 * cos (iTime * 2.0));\n\treturn max (d, 0.015 - length (mod (p - vec3 (0.0, iTime, 0.0), 0.4) - 0.2));\n}\n\n// Distance to the table\nfloat getDistanceTable (in vec3 p, in float dxz) {\n\treturn max (max (dxz - 1.6, p.y + 2.55), -p.y - 3.2);\n}\n\n// Distance to a given material\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\n\tfloat materialDist;\n\tif (materialIndex == 0) {\n\t\tmaterialDist = getDistanceGlass (p, length (p * vec3 (DEFORMATION, 1.0, DEFORMATION)), length (p.xz));\n\t} else if (materialIndex == 1) {\n\t\tmaterialDist = getDistanceChampagne (p, length (p * vec3 (DEFORMATION, 1.0, DEFORMATION)));\n    } else { // materialIndex == 2\n\t\tmaterialDist = getDistanceTable (p, length (p.xz));\n\t}\n\treturn materialDist;\n}\n\n// Distance to the scene\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\n\tfloat d = length (p * vec3 (DEFORMATION, 1.0, DEFORMATION));\n\tfloat dxz = length (p.xz);\n\n\t// Air\n\tmaterialTo = -1;\n\tfloat sceneDist = RAY_LENGTH_MAX;\n\n\t// Champagne\n\tfloat materialDist = getDistanceChampagne (p, d);\n\tMATERIAL_PROCESS (1)\n\n\t// Glass\n\tmaterialDist = getDistanceGlass (p, d, dxz);\n\tMATERIAL_PROCESS (0)\n\n\t// Table\n\tmaterialDist = getDistanceTable (p, dxz);\n\tMATERIAL_PROCESS (2)\n\n\t// Return the distance\n\treturn sceneDist;\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p, in int materialIndex) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\n\n\t// Check the behavior of the material\n\tMaterial material = getMaterial (materialTo);\n\tfloat alpha = abs (material.behavior);\n\tcolor *= 1.0 - alpha;\n\n\t// The ray continues...\n\tint materialFrom = -1;\n\tfloat refractIndexFrom = 1.0;\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tfloat refractIndexTo;\n\t\tvec3 refraction;\n\t\tif (materialTo == -1) {\n\t\t\trefractIndexTo = 1.0;\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\n\t\t} else {\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\n\t\t}\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tmaterialFrom = materialTo;\n\t\t\trefractIndexFrom = refractIndexTo;\n\t\t}\n\n\t\t// Ray marching\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\n\t\t\tnormal.w += dist;\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * dist;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (materialFrom == materialTo) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tif (materialTo == -1) {\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\n\t\t} else {\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t\t// Basic lighting\n\t\t\tmaterial = getMaterial (materialTo);\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\n\t\t\tfloat localAlpha = abs (material.behavior);\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\n\t\t\talpha *= localAlpha;\n\t\t}\n\t}\n\n\t// Get the background color\n\tCOLOR backColor = CHANNEL (texture (iChannel0, direction).rgb);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * alpha;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 4.0));\n\n\t// Set the camera\n\tvec3 origin = 5.0 * vec3 (cos (iTime * 0.1), 0.2 + 0.8 * sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\torigin.y -= 1.0;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tint materialTo = -1;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\n\t\tnormal.w += dist;\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * dist;\n\t}\n\n\t// Check whether we hit something\n\tif (materialTo == -1) {\n\t\tfragColor.rgb = texture (iChannel0, direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\n\n\t\t// The ray continues...\n\t\t#ifdef PROPAGATION\n\t\t\t#ifdef DISPERSION\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t\t\t#else\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\n\t\t\t#endif\n\t\t#endif\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "llfXDB",
    "date": "1545576824",
    "viewed": 5,
    "name": "Dragon Ball",
    "description": "Test...",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "reflection",
     "refraction"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t80\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n\n// Rendering options (for those who have a slow GPU)\n#define PROPAGATION\n#define DISPERSION\n\n// Macros used to handle color channels\n#ifdef DISPERSION\n\t#define COLOR float\n\t#define CHANNEL(x) dot (x, channel)\n#else\n\t#define COLOR vec3\n\t#define CHANNEL(x) x\n#endif\n\n// Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n// Smooth minimum\nfloat smin (in float a, in float b, in float k) {\n\tfloat h = clamp (0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n\treturn mix (a, b, h) - k * h * (1.0 - h);\n}\n\n// Materials\nstruct Material {\n\tvec3 color;\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\n\tvec3 refractIndex; // not used if behavior < 0.0\n};\nMaterial getMaterial (in int materialIndex) {\n\tMaterial material;\n\tif (materialIndex == 0) { // Inner ball\n\t\tmaterial = Material (vec3 (1.0, 0.3, 0.0), 0.4, vec3 (1.50, 1.55, 1.60));\n\t} else if (materialIndex == 1) { // Outter ball\n\t\tmaterial = Material (vec3 (1.0, 0.0, 0.0), 0.7, vec3 (1.20, 1.25, 1.30));\n\t} else { // materialIndex == 2 // Star\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.5), -0.5, vec3 (1.31, 1.31, 1.31));\n\t}\n\treturn material;\n}\n\n// Distance to the inner ball\nfloat getDistanceInnerBall (in vec3 p, in float d) {\n\treturn d - 0.7;\n}\n\n// Distance to the outter ball\nfloat getDistanceOutterBall (in vec3 p, in float d) {\n\treturn d - 0.9;\n}\n\n// Distance to the star\nfloat getDistanceStar (in vec3 p, in float d) {\n\treturn max (length (p.xy) - 0.25 - 0.05 * cos (atan (p.y, p.x) * 5.0), d - 0.72);\n}\n\n// Distance to a given material\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\n\tfloat d = length (p);\n\tfloat materialDist;\n\tif (materialIndex == 0) {\n\t\tmaterialDist = getDistanceInnerBall (p, d);\n\t} else if (materialIndex == 1) {\n\t\tmaterialDist = getDistanceOutterBall (p, d);\n\t} else { // materialIndex == 2\n\t\tmaterialDist = getDistanceStar (p, d);\n\t}\n\treturn materialDist;\n}\n\n// Distance to the scene\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\n\tfloat d = length (p);\n\n\t// Air\n\tmaterialTo = -1;\n\tfloat sceneDist = RAY_LENGTH_MAX;\n\n\t// Outter ball\n\tfloat materialDist = getDistanceOutterBall (p, d);\n\tMATERIAL_PROCESS (1)\n\n\t// Star\n\tmaterialDist = getDistanceStar (p, d);\n\tMATERIAL_PROCESS (2)\n\n\t// Inner ball\n\tmaterialDist = getDistanceInnerBall (p, d);\n\tMATERIAL_PROCESS (0)\n\n\t// Return the distance\n\treturn sceneDist;\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p, in int materialIndex) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\n\n\t// Check the behavior of the material\n\tMaterial material = getMaterial (materialTo);\n\tfloat alpha = abs (material.behavior);\n\tcolor *= 1.0 - alpha;\n\n\t// The ray continues...\n\tint materialFrom = -1;\n\tfloat refractIndexFrom = 1.0;\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tfloat refractIndexTo;\n\t\tvec3 refraction;\n\t\tif (materialTo == -1) {\n\t\t\trefractIndexTo = 1.0;\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\n\t\t} else {\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\n\t\t}\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tmaterialFrom = materialTo;\n\t\t\trefractIndexFrom = refractIndexTo;\n\t\t}\n\n\t\t// Ray marching\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\n\t\t\tnormal.w += dist;\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * dist;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (materialFrom == materialTo) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tif (materialTo == -1) {\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\n\t\t} else {\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t\t// Basic lighting\n\t\t\tmaterial = getMaterial (materialTo);\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\n\t\t\tfloat localAlpha = abs (material.behavior);\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\n\t\t\talpha *= localAlpha;\n\t\t}\n\t}\n\n\t// Get the background color\n\tCOLOR backColor = CHANNEL (texture (iChannel0, direction).rgb);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * alpha;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 4.0));\n\n\t// Set the camera\n\tvec3 origin = 4.0 * vec3 (cos (iTime * 0.1), sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tint materialTo = -1;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\n\t\tnormal.w += dist;\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * dist;\n\t}\n\n\t// Check whether we hit something\n\tif (materialTo == -1) {\n\t\tfragColor.rgb = texture (iChannel0, direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\n\n\t\t// The ray continues...\n\t\t#ifdef PROPAGATION\n\t\t\t#ifdef DISPERSION\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t\t\t#else\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\n\t\t\t#endif\n\t\t#endif\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XljXRG",
    "date": "1444638173",
    "viewed": 10927,
    "name": "Cloudy stuff",
    "description": "Study of how to render cloudy stuff... I basically simplified Duke's [url=https://www.shadertoy.com/view/MljXDw]Cloudy spikeball[/url] and merged it with the model I used for my [url=https://www.shadertoy.com/view/XdBGDd]Love Tunnel[/url].",
    "likes": 67,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// From https://www.shadertoy.com/view/XdBGDd\n// From https://www.shadertoy.com/view/MljXDw (from Duke)\n\n// Rendering parameters\n#define CAMERA_FOCAL_LENGTH\t3.0\n#define RAY_STEP_MAX\t\t100.0\n#define RAY_LENGTH_MAX\t\t150.0\n#define NOISE_FACTOR\t\t2.0\n#define DIST_CORRECTION\t\t0.6\n#define DIST_MIN\t\t\t0.6\n#define DENSITY_FACTOR_STEP\t0.01\n#define DENSITY_FACTOR_DIST\t0.3\n\n// Math constants\n#define PI\t3.14159265359\n\n// Rotation on the Z axis\nvec3 vRotateZ (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x + s * p.y, c * p.y - s * p.x, p.z);\n}\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel0, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n\treturn noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0;\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Distance to the scene\nfloat distScene (in vec3 p, out float hue) {\n\n\t// Global deformation\n\tp.xy += vec2 (3.0 * sin (p.z * 0.1 + 2.0 * iTime), 2.0 * sin (p.z * 0.2 + iTime));\n\n\t// Cylinder\n\tfloat cylinder = 6.0 - length (p.xy) + sin (atan (p.y, p.x) * 6.0) * sin (p.z);\n\tfloat d = max (cylinder, -cylinder - 6.0);\n\thue = 0.3 + 0.3 * noise (p * 0.2);\n\n\t// Rotating spheres\n\tvec3 q = vRotateZ (p, sin (iTime * 4.0));\n\tq.xy = mod (q.xy, 6.5) - 0.5 * 6.5;\n\tq.z = mod (q.z + 0.5 * 32.0, 32.0) - 0.5 * 32.0;\n\tfloat sphereTorus = max (length (q) - 3.0, -cylinder);\n\n\t// Torus\n\tq.xy = vec2 (length (p.xy) - 6.0, q.z);\n\tsphereTorus = min (sphereTorus, length (q.xy) - 3.0);\n\tif (sphereTorus < d) {\n\t\td = sphereTorus;\n\t\thue = 0.3;\n\t}\n\n\t// Return the distance\n\treturn d;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the position and orientation of the camera\n\tvec3 rayOrigin = vec3 (6.0 * cos (iTime * 1.5) + 0.1 * cos (iTime * 10.0), 0.1 * cos (iTime * 20.0), iTime * 20.0 + 5.0 * cos (iTime * 2.0));\n\tvec3 cameraForward = vec3 (-rayOrigin.xy, 15.0 * cos (iTime * 0.6));\n\tvec3 cameraUp = vRotateZ (vec3 (0.0, 1.0, 0.0), PI * sin (iTime) * sin (iTime * 0.2));\n\tmat3 cameraOrientation;\n\tcameraOrientation [2] = normalize (cameraForward);\n\tcameraOrientation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraOrientation [1] = cross (cameraOrientation [2], cameraOrientation [0]);\n\tvec3 rayDirection = cameraOrientation * normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Set the background color\n\tvec3 colorBackground = vec3 (0.0);\n\n\t// Ray marching\n\tfloat densityTotal = 0.0;\n\tvec3 colorTotal = vec3 (0.0);\n\tfloat rayLength = 0.0;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Compute the maximum density\n\t\tfloat densityMax = 1.0 - rayLength / RAY_LENGTH_MAX - rayStep * DENSITY_FACTOR_STEP;\n\t\tif (densityTotal > densityMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the scene information\n\t\tvec3 p = rayOrigin + rayDirection * rayLength;\n\t\tfloat hue;\n\t\tfloat dist = (distScene (p, hue) + NOISE_FACTOR * (fbm (p) - 0.5)) * DIST_CORRECTION;\n\t\tif (dist < 0.0) {\n\n\t\t\t// Compute the local density\n\t\t\tfloat densityLocal = (densityTotal - densityMax) * dist * DENSITY_FACTOR_DIST;\n\t\t\tdensityTotal += densityLocal;\n\n\t\t\t// Update the color\n\t\t\tvec3 colorLocal = hsv2rgb (vec3 (hue, 0.5, 0.8));\n\t\t\tcolorTotal += colorLocal * densityLocal;\n\t\t}\n\n\t\t// Go ahead\n\t\trayLength += max (dist, DIST_MIN);\n\t}\n\tcolorTotal += colorBackground * (1.0 - densityTotal);\n\n\t// Set the fragment color\n\tfragColor = vec4 (colorTotal, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MtjSzG",
    "date": "1444723738",
    "viewed": 643,
    "name": "Cotton candy Pac-Man",
    "description": "Quite the same as [url=https://www.shadertoy.com/view/XljXRG]this[/url] (= study of how to render cloudy stuff), but using [url=https://www.shadertoy.com/view/MlfGR4]this model[/url] instead.",
    "likes": 19,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "pacman"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// From https://www.shadertoy.com/view/MlfGR4\n// From https://www.shadertoy.com/view/MljXDw (from Duke)\n\n// Rendering parameters\n#define GROUND\n#define GHOST\n\n#define CAMERA_FOCAL_LENGTH\t3.0\n#define RAY_STEP_MAX\t\t100\n#define RAY_LENGTH_MAX\t\t500.0\n#define DIST_CORRECTION\t\t0.8\n#define DIST_MIN\t\t\t1.5\n\n// Math constants\n#define PI\t3.14159265359\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel0, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n\treturn noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, in float noiseFactor) {\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = iTime * 100.0;\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Pac-Man\n\tfloat body = length (p);\n\tbody = max (body - 32.0, 27.0 - body);\n\tfloat eyes = 10.0 - length (vec3 (abs (p.x) - 15.0, p.y - 20.0, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.07 + 0.07 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, 0.13);\n\tvec3 P = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0 * min (p.z / 20.0, 1.0), -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1);\n\tground = max (ground, -6.0 - ground) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\t#ifdef GHOST\n\tv = 130.0 + 60.0 * cos (iTime * 3.0);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\tbody = max (body - 28.0, 22.0 - body);\n\teyes = 10.0 - length (vec3 (abs (q.x) - 14.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, 0.76);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// FBM\n\td.x += noiseFactor * (fbm (P * 0.5) - 1.4);\n\td.y += 0.3 * noise (P * 0.5) - 0.15;\n\treturn d;\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the position of the camera\n\tfloat cameraDist = 125.0 + 60.0 * cos (iTime * 0.8);\n\tvec3 rayOrigin;\n\tif (iMouse.z < 0.5) {\n\t\trayOrigin = vec3 (cameraDist * cos (iTime), 5.0 + 70.0 * sin (iTime * 0.5), cameraDist * sin (iTime));\n\t} else {\n\t\tfloat cameraAngle = 4.0 * PI * iMouse.x / iResolution.x;\n\t\trayOrigin = vec3 (cameraDist * sin (cameraAngle), 5.0 + 70.0 * (1.0 - 2.0 * iMouse.y / iResolution.y), cameraDist * cos (cameraAngle));\n\t}\n\n\t// Define the orientation of the camera\n\tvec3 cameraLookAt = vec3 (10.0 * cos (iTime * 0.8), 10.0 + 10.0 * sin (iTime * 0.2), 20.0 * sin (iTime * 0.5) - 10.0);\n\tvec3 cameraForward = cameraLookAt - rayOrigin;\n\tvec3 cameraUp = vec3 (0.2 * cos (iTime * 0.1), 1.0, 0.2 * sin (iTime * 0.1));\n\tmat3 cameraOrientation;\n\tcameraOrientation [2] = normalize (cameraForward);\n\tcameraOrientation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraOrientation [1] = cross (cameraOrientation [2], cameraOrientation [0]);\n\tvec3 rayDirection = cameraOrientation * normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Define the sun direction\n\tfloat sunYawAngle = PI * 0.25;\n\tfloat sunPitchAngle = iTime * 0.1;\n\tvec3 sunDirection = vec3 (sin (sunYawAngle) * sin (sunPitchAngle), cos (sunPitchAngle), cos (sunYawAngle) * sin (sunPitchAngle));\n\n\t// Set the sky color\n\tvec3 skyColor = mix (vec3 (0.8, 0.4, 0.4), vec3 (0.4, 0.4, 0.6), smoothstep (0.0, 0.5, sunDirection.y));\n\tskyColor += vec3 (0.8, 0.6, 0.4) * pow (max (0.0, dot (rayDirection, sunDirection)), 12.0);\n\tskyColor = mix (vec3 (0.15, 0.15, 0.24), skyColor, min (1.0, 1.0 + sunDirection.y));\n\n\t// Set the noise and density factors\n\tfloat candyControl = smoothstep (0.4, 0.6, sin (iTime * 0.7));\n\tfloat noiseFactor = mix (4.0, 8.0, candyControl);\n\tfloat densityFactor = mix (0.1, 0.5, candyControl);\n\n\t// Ray marching\n\tfloat densityTotal = 0.0;\n\tvec3 colorTotal = vec3 (0.0);\n\tfloat rayLength = 0.0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Compute the maximum density\n\t\tfloat densityMax = 1.0 - rayLength / RAY_LENGTH_MAX;\n\t\tif (densityTotal > densityMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the scene information\n\t\tvec3 p = rayOrigin + rayDirection * rayLength;\n\t\tvec2 data = distScene (p, noiseFactor);\n\t\tfloat dist = data.x * DIST_CORRECTION;\n\t\tif (dist < 0.0) {\n\n\t\t\t// Compute the local density\n\t\t\tfloat densityLocal = (densityTotal - densityMax) * dist * densityFactor;\n\t\t\tdensityTotal += densityLocal;\n\n\t\t\t// Update the color\n\t\t\tvec3 colorLocal = hsv2rgb (vec3 (data.y, 0.2, 1.0));\n\t\t\tcolorTotal += colorLocal * densityLocal;\n\t\t}\n\n\t\t// Go ahead\n\t\trayLength += max (dist, DIST_MIN);\n\t}\n\tcolorTotal += skyColor * (1.0 - densityTotal);\n\n\t// Set the fragment color\n\tfragColor = vec4 (colorTotal, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4l2Szd",
    "date": "1445940743",
    "viewed": 804,
    "name": "Dark corridors",
    "description": "Simple 2D lighting in a procedural tile map. (Click to move the light freely.)",
    "likes": 24,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "light"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGRn",
       "filepath": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// Rendering parameters\n#define MAZE_DENSITY\t0.5\n#define MAZE_ZOOM\t\t5.0\n#define TEXTURE_ZOOM\t0.25\n#define RAY_LENGTH\t\t5.0\n#define FADE_POWER\t\t1.5\n#define AMBIENT\t\t\t0.0\n\n// Animation parameters\n#define LIGHT_SPEED_X\t\t1.7\n#define LIGHT_MOVE_X\t\t3.0\n#define LIGHT_MOVE_Y\t\t4.3\n#define LIGHT_FREQUENCY_X\t0.2\n#define LIGHT_FREQUENCY_Y1\t0.3\n#define LIGHT_FREQUENCY_Y2\t0.5\n#define FADE_VARIATION\t\t0.2\n#define FADE_FREQUENCY\t\t3.0\n\n// Math constants\n#define SQRT2\t1.41421356237\n#define DELTA\t0.001\n\n// Animation formulas\n#define LIGHT_Y(t) LIGHT_MOVE_Y * cos (LIGHT_FREQUENCY_Y1 * (t)) * cos (LIGHT_FREQUENCY_Y2 * (t))\n#define LIGHT_DY(t) LIGHT_MOVE_Y * (LIGHT_FREQUENCY_Y1 * sin (LIGHT_FREQUENCY_Y1 * (t)) * cos (LIGHT_FREQUENCY_Y2 * (t)) + LIGHT_FREQUENCY_Y2 * cos (LIGHT_FREQUENCY_Y1 * (t)) * sin (LIGHT_FREQUENCY_Y2 *(t)))\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y));\n}\n\n// Check whether there is a wall on a given tile edge\nfloat wallCheck (in vec2 p) {\n\tvec2 tile = floor (p + 0.5);\n\tfloat wall = step (1.0 - MAZE_DENSITY, rand (tile));\n\twall *= step (max (1.0, abs (LIGHT_DY (tile.x))), abs (LIGHT_Y (tile.x) - tile.y));\n\treturn wall;\n}\n\n// Return the distance to the nearest wall\nfloat wallDistance (in vec2 rayOrigin, in vec2 rayDirection) {\n\n\t// Launch the ray\n\tvec2 raySign = sign (rayDirection);\n\tvec2 rayInv = 1.0 / rayDirection;\n\tfloat rayLength = 0.0;\n\tvec2 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_LENGTH * SQRT2; ++rayStep) {\n\n\t\t// Reach the edge of the tile\n\t\trayLength = min (rayLengthNext.x, rayLengthNext.y);\n\t\tvec2 hitNormal = step (rayLengthNext.xy, rayLengthNext.yx) * raySign;\n\n\t\t// Check whether we hit a wall\n\t\tif (wallCheck (rayOrigin + rayLength * rayDirection + hitNormal * 0.5) > 0.5) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next tile\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the distance to the hit point\n\treturn rayLength;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the coordinates\n\tfloat cameraX = LIGHT_SPEED_X * iTime;\n\tvec2 rayOrigin = MAZE_ZOOM * (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\trayOrigin.x += cameraX;\n\n\t// Lighting\n\tvec2 lightPosition;\n\tif (iMouse.z < 0.5) {\n\t\tlightPosition.x = cameraX + LIGHT_MOVE_X * cos (LIGHT_FREQUENCY_X * iTime);\n\t\tlightPosition.y = LIGHT_Y (lightPosition.x);\n\t} else {\n\t\tlightPosition = MAZE_ZOOM * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\t\tlightPosition.x += cameraX;\n\t}\n\tvec2 lightDirection = lightPosition - rayOrigin;\n\tfloat lightDistance = length (lightDirection);\n\tfloat lightIntensity = pow (max (0.0, 1.0 - lightDistance / RAY_LENGTH), FADE_POWER + FADE_VARIATION * cos (FADE_FREQUENCY * iTime));\n\tif (wallCheck (rayOrigin) < 0.5) {\n\n\t\t// Corridor\n\t\tif (lightDistance < RAY_LENGTH) {\n\t\t\tlightIntensity *= step (lightDistance + DELTA, wallDistance (rayOrigin, lightDirection / lightDistance));\n\t\t}\n\t\tfragColor = texture (iChannel0, rayOrigin * TEXTURE_ZOOM);\n\t} else {\n\n\t\t// Wall\n\t\tfragColor = texture (iChannel1, rayOrigin * TEXTURE_ZOOM);\n\t}\n\tfragColor *= mix (lightIntensity, 1.0, AMBIENT);\n\tfragColor += smoothstep (0.2, 0.0, lightDistance) * step (0.2, rand (vec2 (iTime)));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Ml2XWd",
    "date": "1447490647",
    "viewed": 445,
    "name": "Paris, debout",
    "description": ":(",
    "likes": 18,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "paris"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2 (1.3, 0.8) * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfloat d1 = abs (length (uv - vec2 (0.0, -1.0)) - 0.55);\n\tfloat d2 = abs (length (uv - vec2 (-1.95, 0.8)) - 1.95);\n\tfloat d3 = max (abs (length (uv - vec2 (1.95, 0.8)) - 1.95), 0.075 - uv.x);\n\tfloat d = max (min (d1, min (d2, d3)), abs (uv.y) - 0.65);\n\tvec3 color = mix ((d1 < d2 && d1 < d3) ? vec3 (0.9) : d2 < d3 ? vec3 (0.4, 0.4, 1.0) : vec3 (1.0, 0.4, 0.4), vec3 (0.2 * (uv.y + 0.5) * (0.7 + 0.3 * cos (iTime))), smoothstep (0.02 - 0.01 * uv.y, 0.04, d));\n\tfragColor = vec4 (color * smoothstep (1.2, 0.0, abs (uv.x)), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MdyGRD",
    "date": "1453443592",
    "viewed": 711,
    "name": "Lost",
    "description": "Use the mouse to rotate the camera; reset the time if you get stuck in the maze ;).",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "game",
     "maze",
     "collisions"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rn",
       "filepath": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define FOV\t\t\t\t\t80.0\n#define RAY_STEP_MAX\t\t20.0\n#define RAY_LENGTH_MAX\t\t10.0\n#define EDGE_LENGTH\t\t\t0.1\n#define EDGE_FULL\n#define TEXTURE\n#define SHADOW\n#define BUMP_RESOLUTION\t\t100.0\n#define BUMP_INTENSITY\t\t0.1\n#define AMBIENT_NORMAL\t\t0.2\n#define AMBIENT_HIGHLIGHT\t2.5\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t1.5\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define DELTA\t0.002\n#define PI\t\t3.14159265359\n\n// PRNG (unpredictable)\nfloat randUnpredictable (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.6789, 5.4321, 6.7890));\n\tseed += dot (seed.yzx, seed.zxy + vec3 (21.0987, 12.3456, 15.1273));\n\treturn fract (seed.x * seed.y * seed.z * 5.1337);\n}\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// PRNG (2D only)\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Check whether there is a block at a given voxel edge\nfloat blockCheck (in vec3 p, in vec3 n) {\n\tvec3 blockPosition = floor (p + 0.5 + n * 0.5);\n\tvec3 blockEven = mod (blockPosition, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (blockPosition))) *\n\t\tstep (4.5, mod (blockPosition.x, 32.0)) *\n\t\tstep (2.5, mod (blockPosition.y, 16.0)) *\n\t\tstep (4.5, mod (blockPosition.z, 32.0));\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out vec3 hitNormal) {\n\n\t// Launch the ray\n\tvec3 hitPosition = rayOrigin;\n\tvec3 raySign = sign (rayDirection);\n\tvec3 rayInv = 1.0 / rayDirection;\n\tvec3 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Reach the edge of the voxel\n\t\trayLength = min (rayLengthNext.x, min (rayLengthNext.y, rayLengthNext.z));\n\t\thitNormal = step (rayLengthNext.xyz, rayLengthNext.yzx) * step (rayLengthNext.xyz, rayLengthNext.zxy) * raySign;\n\t\thitPosition = rayOrigin + rayLength * rayDirection;\n\n\t\t// Check whether we hit a block\n\t\tif (blockCheck (hitPosition, hitNormal) > 0.5 || rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Read the data\n\tvec3 headPosition;\n\tmat3 headOrientation;\n\tvec3 lightPosition;\n\n\tif (iFrame < 5) {\n\t\theadPosition = vec3 (13.05, 1.5, 13.0);\n\t\tlightPosition = vec3 (13.0, 1.0, 13.0);\n\t\theadOrientation [0] = vec3 (0.0, 0.0, -1.0);\n\t\theadOrientation [1] = vec3 (1.0, 0.0, 0.0);\n\t} else {\n\t\tvec4 data = texture (iChannel0, vec2 (0.5, 0.5) / iResolution.xy);\n\t\theadPosition = data.xyz;\n\t\theadOrientation [1].x = data.w;\n\t\tdata = texture (iChannel0, vec2 (2.5, 0.5) / iResolution.xy);\n\t\tlightPosition = data.xyz;\n\t\theadOrientation [1].y = data.w;\n\t\tdata = texture (iChannel0, vec2 (4.5, 0.5) / iResolution.xy);\n\t\theadOrientation [0] = data.xyz;\n\t\theadOrientation [1].z = data.w;\n\t}\n\theadOrientation [2] = cross (headOrientation [0], headOrientation [1]);\n\n\t// Animate the ambient lighting\n\tfloat ambientIntensity = max (step (1.0, mod (iTime, 10.0)), step (0.25, randUnpredictable (vec3 (iTime))));\n\n\t// Define the ray corresponding to this fragment\n\tvec3 rayOrigin = headPosition;\n\tvec3 rayDirection = headOrientation * normalize (vec3 (2.0 * fragCoord - iResolution.xy, 0.5 * iResolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tvec3 hitNormal;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitNormal);\n\tvec3 hitUV = hitPosition * abs (hitNormal.yzx + hitNormal.zxy);\n\n\t// Basic edge detection\n\tvec3 edgeDistance = fract (hitUV + 0.5) - 0.5;\n\tvec3 edgeDirection = sign (edgeDistance);\n\tedgeDistance = abs (edgeDistance);\n\n\t#ifdef EDGE_FULL\n\tvec3 hitNormalAbs = abs (hitNormal);\n\tvec2 edgeSmooth = vec2 (dot (edgeDistance, hitNormalAbs.yzx), dot (edgeDistance, hitNormalAbs.zxy));\n\tfloat highlightIntensity = (1.0 - blockCheck (hitPosition + edgeDirection * hitNormalAbs.yzx, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.x);\n\thighlightIntensity = max (highlightIntensity, (1.0 - blockCheck (hitPosition + edgeDirection * hitNormalAbs.zxy, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.y));\n\thighlightIntensity = max (highlightIntensity, (1.0 - blockCheck (hitPosition + edgeDirection, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, min (edgeSmooth.x, edgeSmooth.y)));\n\t#else\n\tfloat highlightIntensity = 1.0 - blockCheck (hitPosition + step (edgeDistance.yzx, edgeDistance.xyz) * step (edgeDistance.zxy, edgeDistance.xyz) * edgeDirection, hitNormal);\n\thighlightIntensity *= smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, max (edgeDistance.x, max (edgeDistance.y, edgeDistance.z)));\n\t#endif\n\n\t// Texture\n\t#ifdef TEXTURE\n\tvec2 textureUV = fract (vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy)) + 0.5);\n\ttextureUV.x = (textureUV.x + mod (floor (iTime * 20.0), 6.0)) * 40.0 / 256.0;\n\tfloat textureIntensity = 1.0 - texture (iChannel1, textureUV).r;\n\tfloat texturePhase = 2.0 * PI * randUnpredictable (floor (hitPosition + 0.5 + hitNormal * 1.5));\n\ttextureIntensity *= smoothstep (0.8, 1.0, cos (iTime * 0.2 + texturePhase));\n\thighlightIntensity = max (highlightIntensity, textureIntensity);\n\t#endif\n\n\t// Set the object color\n\tvec3 color = cos ((hitPosition + hitNormal * 0.5) * 0.05);\n\tcolor = hsv2rgb (vec3 (color.x + color.y + color.z + highlightIntensity * 0.05, 1.0, 1.0));\n\n\t// Lighting\n\tvec3 lightDirection = hitPosition - lightPosition;\n\tfloat lightDistance = length (lightDirection);\n\tlightDirection /= lightDistance;\n\n\tfloat lightIntensity = min (1.0, 1.0 / lightDistance);\n\t#ifdef SHADOW\n\tfloat lightHitDistance;\n\tvec3 lightHitNormal;\n\thit (hitPosition - hitNormal * DELTA, -lightDirection, lightDistance, lightHitDistance, lightHitNormal);\n\tlightIntensity *= step (lightDistance, lightHitDistance);\n\t#endif\n\n\t// Bump mapping\n\tvec2 bumpUV = BUMP_RESOLUTION * vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy));\n\tvec4 bumpID = floor (vec4 (bumpUV, bumpUV + 1.0));\n\tbumpUV = fract (bumpUV);\n\tfloat bump = mix (\n\t\tmix (rand (bumpID.xy), rand (bumpID.zy), bumpUV.x),\n\t\tmix (rand (bumpID.xw), rand (bumpID.zw), bumpUV.x),\n\t\tbumpUV.y);\n\thitNormal = normalize (hitNormal + hitNormal.yzx * (1.0 - highlightIntensity) * BUMP_INTENSITY * (bump - 0.5));\n\n\t// Shading\n\tfloat ambient = mix (AMBIENT_NORMAL, AMBIENT_HIGHLIGHT, highlightIntensity) * ambientIntensity;\n\tfloat diffuse = max (0.0, dot (hitNormal, lightDirection));\n\tfloat specular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\tcolor = (ambient + diffuse * lightIntensity) * color + specular * lightIntensity;\n\tcolor *= pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER);\n\n\t// Light source\n\tlightDirection = lightPosition - rayOrigin;\n\tif (dot (rayDirection, lightDirection) > 0.0) {\n\t\tlightDistance = length (lightDirection);\n\t\tif (lightDistance < hitDistance) {\n\t\t\tvec3 lightNormal = cross (rayDirection, lightDirection);\n\t\t\tcolor += smoothstep (0.001, 0.0, dot (lightNormal, lightNormal));\n\t\t}\n\t}\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Physics parameters\n#define GRAVITY vec3 (0.0, -3.0, 0.0) // Feel free to comment this out to explore the maze freely :)\n\n// Math constants\n#define DELTA\t0.002\n#define PI \t\t3.14159265359\n\n// Element\nstruct Element {\n\tvec3 position;\n\tvec3 speed;\n\tvec3 force;\n\tfloat friction;\n\tfloat radius;\n\tfloat elasticity;\n};\n\n// Head\nstruct Head {\n\tElement element;\n\tmat3 orientation;\n\tfloat forceOrientation;\n};\n\n// Light ball\nstruct LightBall {\n\tElement element;\n\tfloat aheadDistance;\n\tfloat movementAmplitude;\n\tfloat forceSpringStiffness;\n\tfloat forceMaxSqr;\n\tfloat collisionTimer;\n\tfloat collisionTimerMax;\n};\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// Check whether there is a block at a given position\nfloat blockCheck (in vec3 blockPosition) {\n\tvec3 blockEven = mod (blockPosition, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (blockPosition))) *\n\t\tstep (4.5, mod (blockPosition.x, 32.0)) *\n\t\tstep (2.5, mod (blockPosition.y, 16.0)) *\n\t\tstep (4.5, mod (blockPosition.z, 32.0));\n}\n\n// React to collisions\nvoid collisionReact (inout Element element, in vec3 relativePosition) {\n\n\t// Compute the position relative to the actual hit point\n\trelativePosition -= 0.5 * sign (relativePosition);\n\n\t// Make sure there is a hit\n\tfloat distance = length (relativePosition);\n\tif (distance < element.radius) {\n\n\t\t// Compute the normalized direction of the hit\n\t\trelativePosition /= distance;\n\n\t\t// Upate the position\n\t\tdistance -= element.radius;\n\t\telement.position -= relativePosition * distance;\n\n\t\t// Update the speed\n\t\telement.speed -= (1.0 + element.elasticity) * dot (element.speed, relativePosition) * relativePosition;\n\t}\n}\n\n// Detect collisions (here, \"element\" is a sphere, and the environment is made of cubes)\nvoid collisionDetect (inout Element element) {\n\n\t// Get the position of the current block\n\tvec3 blockPosition = floor (element.position + 0.5);\n\n\t// There is no collision if we are inside a block already\n\tif (blockCheck (blockPosition) > 0.5) {\n\t\treturn;\n\t}\n\n\t// Compute the relative position within the block\n\tvec4 relativePosition = vec4 (element.position - blockPosition, 0.0);\n\n\t// Check whether we are close to a side of the current block\n\tvec3 check = step (0.5 - element.radius, abs (relativePosition.xyz));\n\tif (check.x + check.y + check.z < 0.5) {\n\t\treturn;\n\t}\n\n\t// Prepare to check nearby blocks\n\tvec4 blockDelta = sign (relativePosition);\n\n\t// Handle collisions with the sides\n\tif (check.x > 0.5 && blockCheck (blockPosition + blockDelta.xww) > 0.5) {\n\t\tcheck.x = 0.0;\n\t\tcollisionReact (element, relativePosition.xww);\n\t}\n\tif (check.y > 0.5 && blockCheck (blockPosition + blockDelta.wyw) > 0.5) {\n\t\tcheck.y = 0.0;\n\t\tcollisionReact (element, relativePosition.wyw);\n\t}\n\tif (check.z > 0.5 && blockCheck (blockPosition + blockDelta.wwz) > 0.5) {\n\t\tcheck.z = 0.0;\n\t\tcollisionReact (element, relativePosition.wwz);\n\t}\n\n\t// Take note of whether we have to check the collision with the corner\n\tfloat checkXYZ = check.x * check.y * check.z;\n\n\t// Handle collisions with the edges\n\tif (check.x * check.y > 0.5 && blockCheck (blockPosition + blockDelta.xyw) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.xyw);\n\t}\n\tif (check.y * check.z > 0.5 && blockCheck (blockPosition + blockDelta.wyz) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.wyz);\n\t}\n\tif (check.z * check.x > 0.5 && blockCheck (blockPosition + blockDelta.xwz) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.xwz);\n\t}\n\n\t// Handle the collision with the corner\n\tif (checkXYZ > 0.5 && blockCheck (blockPosition + blockDelta.xyz) > 0.5) {\n\t\tcollisionReact (element, relativePosition.xyz);\n\t}\n}\n\n// Handle movements\nvoid move (inout Element element, in bool collide) {\n\n\t// Handle the friction\n\telement.force -= element.speed * element.friction;\n\n\t// Update the speed\n\telement.speed += element.force * iTimeDelta;\n\n\t// Compute the movement\n\tfloat speed = length (element.speed);\n\tfloat movementLength = speed * iTimeDelta;\n\tvec3 movementDirection = element.speed / speed;\n\n\t// Move towards the destination by small increments, to make sure we detect all collisions\n\t// Note: we could optimize this by going faster when within the inner part of a block, far from the sides\n\t// ...but this isn't really needed, so let's keep it simple\n\tif (collide && element.radius > 0.0) {\n\t\tfor (int iteration = 0; iteration < 8; ++iteration) {\n\t\t\tif (movementLength > element.radius) {\n\t\t\t\telement.position += element.radius * movementDirection;\n\t\t\t\tmovementLength -= element.radius;\n\t\t\t\tcollisionDetect (element);\n\t\t\t}\n\t\t}\n\t}\n\telement.position += movementLength * movementDirection;\n\tif (collide) {\n\t\tcollisionDetect (element);\n\t}\n}\n\n// Get the orientation of the head\nmat3 headOrientationGet () {\n\n\tfloat yawAngle = 3.0 * PI * (iMouse.x / iResolution.x - 0.5);\n\tfloat pitchAngle = PI * (0.5 - iMouse.y / iResolution.y);\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 headOrientation;\n\theadOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\treturn headOrientation;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time...\n\tif (fragCoord.x > 5.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Define the head\n\tHead head;\n\thead.element.friction = 1.0;\n\thead.element.radius = 0.1;\n\thead.element.elasticity = 0.5;\n\thead.forceOrientation = 2.0;\n\n\t// Define the light ball\n\tLightBall lightBall;\n\tlightBall.element.friction = 1.0;\n\tlightBall.element.radius = 0.03;\n\tlightBall.element.elasticity = 0.5;\n\tlightBall.aheadDistance = 0.5;\n\tlightBall.movementAmplitude = 0.1;\n\tlightBall.forceSpringStiffness = 15.0;\n\tlightBall.forceMaxSqr = 900.0;\n\tlightBall.collisionTimerMax = 5.0;\n\n\t// Initialize the position and speed of both the head and the light ball\n\tif (iFrame < 5) {\n\t\thead.element.position = vec3 (13.05, 1.5, 13.0);\n\t\thead.element.speed = vec3 (0.0);\n\t\tlightBall.element.position = vec3 (13.0, 1.0, 13.0);\n\t\tlightBall.element.speed = vec3 (0.0);\n\t\tlightBall.collisionTimer = 0.0;\n\t} else {\n\t\thead.element.position = texture (iChannel0, vec2 (0.5, 0.5) / iResolution.xy).xyz;\n\t\thead.element.speed = texture (iChannel0, vec2 (1.5, 0.5) / iResolution.xy).xyz;\n\t\tlightBall.element.position = texture (iChannel0, vec2 (2.5, 0.5) / iResolution.xy).xyz;\n\t\tvec4 data = texture (iChannel0, vec2 (3.5, 0.5) / iResolution.xy);\n\t\tlightBall.element.speed = data.xyz;\n\t\tlightBall.collisionTimer = data.w;\n\t}\n\n\t// Move the head\n\thead.orientation = headOrientationGet ();\n\thead.element.force = head.orientation [2] * head.forceOrientation;\n\t#ifdef GRAVITY\n\tfloat gravitySqr = dot (GRAVITY, GRAVITY);\n\tif (gravitySqr > DELTA) {\n\t\thead.element.force += (1.0 - dot (head.element.force, GRAVITY) / gravitySqr) * GRAVITY;\n\t}\n\t#endif\n\tmove (head.element, true);\n\n\t// Move the light ball (using a spring force)\n\tvec3 lightBallPositionTarget = lightBall.movementAmplitude * vec3 (sin (iTime * 2.0), sin (iTime * 3.0), sin (iTime));\n\tlightBallPositionTarget.z += lightBall.aheadDistance;\n\tlightBallPositionTarget = head.element.position + head.orientation * lightBallPositionTarget;\n\tlightBall.element.force = (lightBallPositionTarget - lightBall.element.position) * lightBall.forceSpringStiffness;\n\tif (dot (lightBall.element.force, lightBall.element.force) < lightBall.forceMaxSqr) {\n\t\tlightBall.collisionTimer = 0.0;\n\t} else {\n\t\tlightBall.collisionTimer += iTimeDelta;\n\t}\n\tmove (lightBall.element, lightBall.collisionTimer < lightBall.collisionTimerMax);\n\n\t// Store the data\n\tif (fragCoord.x < 1.0) {\n\t\tfragColor = vec4 (head.element.position, head.orientation [1].x);\n\t} else if (fragCoord.x < 2.0) {\n\t\tfragColor = vec4 (head.element.speed, 0.0);\n\t} else if (fragCoord.x < 3.0) {\n\t\tfragColor = vec4 (lightBall.element.position, head.orientation [1].y);\n\t} else if (fragCoord.x < 4.0) {\n\t\tfragColor = vec4 (lightBall.element.speed, lightBall.collisionTimer);\n\t} else {\n\t\tfragColor = vec4 (head.orientation [0], head.orientation [1].z);\n\t}\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4sK3zm",
    "date": "1454077386",
    "viewed": 1389,
    "name": "Liquid stuff",
    "description": "This is an attempt to simulate liquid in 2D, using particles.\n- Mouse: draw colliders;\n- LEFT & RIGHT: rotate the gravity;\n- SPACE: invert the gravity;\n- R: reset the scene.",
    "likes": 57,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fluid",
     "liquid",
     "physics"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Display particles and colliders\n\n#define RADIUS_PARTICLE\t\t\t1.5\n//#define GLOW_THICKNESS\t\t1.0 // Choose either GLOW_THICKNESS *or* PARTICLE_COUNT_MIN\n#define PARTICLE_COUNT_MIN\t\t2.0\n#define VELOCITY_COLOR_FACTOR\t0.02\n\n#define FLOOR(x) float (int (x)) // To workaround a bug with Firefox on Windows...\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvec3 particleColor (in float particleVelocity) {\n\treturn mix (vec3 (0.5, 0.5, 1.0), vec3 (1.0), particleVelocity * VELOCITY_COLOR_FACTOR);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check whether there is a collider here\n\tvec4 data = texture (iChannel1, fragCoord / iResolution.xy);\n\tvec3 color;\n\tif (data.a > 0.5) {\n\n\t\t// Collider (wood)\n\t\tvec2 uv = 0.02 * fragCoord;\n\t\tuv = uv.y * 13.0 + sin (uv * 17.0) * sin (uv.yx * 7.0) * sin (iTime * 0.2 + uv);\n\t\tcolor = vec3 (0.8, 0.6, 0.4) * (1.0 - 0.5 * length (fract (uv) - 0.5));\n\t} else {\n\n\t\t// Background (light squares)\n\t\tvec2 uv = 0.05 * fragCoord;\n\t\tuv += 0.5 * cos (uv.yx + iTime);\n\t\tfloat angle = rand (floor (uv)) * 3.14159;\n\t\tvec3 hsv = vec3 (0.6 + 0.1 * cos (angle), 1.0, 0.2 + 0.1 * cos (angle * iTime));\n\t\tcolor = hsv2rgb (hsv) * smoothstep (1.0, 0.2, length (fract (uv) - 0.5));\n\n\t\t// Check whether there is a particle here\n\t\tfloat particleVelocity = data.b;\n\t\tif (particleVelocity >= 0.0) {\n\t\t\tcolor += particleColor (particleVelocity);\n\t\t} else {\n\n\t\t\t// Look around (spiral loop from the current position)\n\t\t\tvec2 offset = vec2 (0.0);\n\t\t\tvec2 direction = vec2 (1.0, 0.0);\n#if defined (GLOW_THICKNESS) && !defined (PARTICLE_COUNT_MIN)\n\t\t\tconst float radiusGlow = FLOOR (RADIUS_PARTICLE + GLOW_THICKNESS);\n\t\t\tfor (float n = 1.0; n < (2.0 * radiusGlow + 1.0) * (2.0 * radiusGlow + 1.0); ++n) {\n\t\t\t\toffset += direction;\n\t\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t\t}\n\t\t\t\tparticleVelocity = texture (iChannel1, (fragCoord + offset) / iResolution.xy).b;\n\t\t\t\tif (particleVelocity >= 0.0) {\n\t\t\t\t\tcolor += particleColor (particleVelocity) * smoothstep (RADIUS_PARTICLE + GLOW_THICKNESS, RADIUS_PARTICLE, length (offset));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#elif !defined (GLOW_THICKNESS) && defined (PARTICLE_COUNT_MIN)\n\t\t\tfloat count = 0.0;\n\t\t\tfor (float n = 1.0; n < (2.0 * FLOOR (RADIUS_PARTICLE) + 1.0) * (2.0 * FLOOR (RADIUS_PARTICLE) + 1.0); ++n) {\n\t\t\t\toffset += direction;\n\t\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t\t}\n\t\t\t\tif (dot (offset, offset) <= RADIUS_PARTICLE * RADIUS_PARTICLE) {\n\t\t\t\t\tparticleVelocity = texture (iChannel1, (fragCoord + offset) / iResolution.xy).b;\n\t\t\t\t\tif (particleVelocity >= 0.0 && ++count >= PARTICLE_COUNT_MIN) {\n\t\t\t\t\t\tcolor += particleColor (particleVelocity);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\t// Display the direction of the gravity\n\tdata = texture (iChannel2, vec2 (1.5, 0.5) / iResolution.xy);\n\tfloat gravityTimer = data.g;\n\tif (gravityTimer > 0.0) {\n\t\tfloat gravityDirection = data.r;\n\t\tvec2 frag = fragCoord - 0.5 * iResolution.xy;\n\t\tvec2 direction = vec2 (cos (gravityDirection), sin (gravityDirection));\n\t\tvec2 pointA = 25.0 * direction;\n\t\tvec2 pointB = 15.0 * direction;\n\t\tvec2 offset = 10.0 * vec2 (direction.y, -direction.x);\n\t\tfloat dist = segDist (frag, -pointA, pointA);\n\t\tdist = min (dist, segDist (frag, pointA, pointB + offset));\n\t\tdist = min (dist, segDist (frag, pointA, pointB - offset));\n\t\tcolor = mix (color, vec3 (smoothstep (4.0, 3.0, dist)), gravityTimer * smoothstep (6.0, 5.0, dist));\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Update the velocity and position of each particle\n\n#define COLLISION_SPRING_STIFFNESS_COLLIDER\t5000.0\n#define COLLISION_SPRING_STIFFNESS_PARTICLE\t1500.0\n#define COLLISION_SPRING_DAMPING\t\t\t10.0\n#define RADIUS_COLLIDER\t\t\t\t\t\t0.5\n#define RADIUS_PARTICLE\t\t\t\t\t\t1.0\n#define PACKED\n#define GRAVITY\t\t\t\t\t\t\t\t10.0\n#define TIME_STEP_MAX\t\t\t\t\t\t0.01\n#define VELOCITY_MAX\t\t\t\t\t\t1.0\n#define SPAWN_VELOCITY\t\t\t\t\t\tvec2 (-200.0, 0.0)\n#define SPAWN_POSITION\t\t\t\t\t\tiResolution.xy - 12.5\n#define SQRT3\t\t\t\t\t\t\t\t1.732\n\n#define CEIL(x) float (int (x + 0.9999)) // To workaround a bug with Firefox on Windows...\n\nvec2 particleVelocity;\nvec2 particlePosition;\nvec2 particleForce;\nvec2 particleIdCheck;\n\nvoid collide (in vec2 offset) {\n\n\t// Get the position of the cell\n\tvec2 cellPosition = floor (particlePosition + offset) + 0.5;\n\n\t// Get the particle ID and the collider\n\tvec4 data = texture (iChannel1, cellPosition / iResolution.xy);\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Check whether there is a particle here\n\tif (offset == vec2 (0.0)) {\n\n\t\t// This is the current particle\n\t\tparticleIdCheck = particleId;\n\t}\n\telse if (particleId.x > 0.0) {\n\n\t\t// Get the velocity and position of this other particle\n\t\tdata = texture (iChannel0, particleId / iResolution.xy);\n\t\tvec2 otherParticleVelocity = data.rg;\n\t\tvec2 otherParticlePosition = data.ba;\n\n\t\t// Compute the distance between these 2 particles\n\t\tvec2 direction = otherParticlePosition - particlePosition;\n\t\tfloat distSquared = dot (direction, direction);\n\n\t\t// Check whether these 2 particles touch each other\n\t\tif (distSquared < 4.0 * RADIUS_PARTICLE * RADIUS_PARTICLE) {\n\n\t\t\t// Normalize the direction\n\t\t\tfloat dist = sqrt (distSquared);\n\t\t\tdirection /= dist;\n\n\t\t\t// Apply the collision force (spring)\n\t\t\tfloat compression = 2.0 * RADIUS_PARTICLE - dist;\n\t\t\tparticleForce -= direction * (compression * COLLISION_SPRING_STIFFNESS_PARTICLE - dot (otherParticleVelocity - particleVelocity, direction) * COLLISION_SPRING_DAMPING);\n\t\t}\n\t}\n\n\t// Collision with a collider?\n\tif (collider > 0.5) {\n\n\t\t// Compute the distance between the center of the particle and the collider\n\t\tvec2 direction = cellPosition - particlePosition;\n\t\tvec2 distCollider = max (abs (direction) - RADIUS_COLLIDER, 0.0);\n\t\tfloat distSquared = dot (distCollider, distCollider);\n\n\t\t// Check whether the particle touches the collider\n\t\tif (distSquared < RADIUS_PARTICLE * RADIUS_PARTICLE) {\n\n\t\t\t// Normalize the direction\n\t\t\tfloat dist = sqrt (distSquared);\n\t\t\tdirection = sign (direction) * distCollider / dist;\n\n\t\t\t// Apply the collision force (spring)\n\t\t\tfloat compression = RADIUS_PARTICLE - dist;\n\t\t\tparticleForce -= direction * (compression * COLLISION_SPRING_STIFFNESS_COLLIDER + dot (particleVelocity, direction) * COLLISION_SPRING_DAMPING);\n\t\t}\n\t}\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check for a reset\n\tbool reset = iFrame == 0 || texture (iChannel2, vec2 (0.5) / iResolution.xy).a > 0.5;\n\n\t// Define the particle data\n\tif (reset) {\n\n\t\t// Define the particle spawning area\n\t\tfloat liquid =\n\t\t\tstep (abs (fragCoord.x - iResolution.x * 0.5), iResolution.x * 0.5 - 5.0 - RADIUS_PARTICLE)\n\t\t\t* step (iResolution.y * 0.5, fragCoord.y)\n\t\t\t* step (fragCoord.y, iResolution.y - 5.0 - RADIUS_PARTICLE)\n#ifndef PACKED\n\t\t\t* step (mod (fragCoord.x + SQRT3 * fragCoord.y, ceil (2.0 * RADIUS_PARTICLE)), 1.0)\n\t\t\t* step (mod (fragCoord.y, ceil (SQRT3 * RADIUS_PARTICLE)), 1.0);\n#else\n\t\t\t* step (mod (fragCoord.x + fragCoord.y, 2.0), 0.5);\n#endif\n\t\tfloat rand = 0.01 * cos (fragCoord.x * 13.37 + fragCoord.y * 17.73);\n\n\t\t// Initialize the particle\n\t\tparticleVelocity = vec2 (0.0);\n\t\tparticlePosition = liquid > 0.5 ? fragCoord + rand: vec2 (-1.0);\n\t} else {\n\n\t\t// Get the particle data\n\t\tvec4 data = texture (iChannel0, fragCoord / iResolution.xy);\n\t\tparticleVelocity = data.rg;\n\t\tparticlePosition = data.ba;\n\t\tif (particlePosition.x > 0.0) {\n\n\t\t\t// Get the gravity\n\t\t\tfloat gravityDirection = texture (iChannel2, vec2 (1.5, 0.5) / iResolution.xy).r;\n\t\t\tparticleForce = GRAVITY * vec2 (cos (gravityDirection), sin (gravityDirection));\n\n\t\t\t// Check for collisions with nearby particles and colliders\n\t\t\tconst float collisionRadius = CEIL (RADIUS_PARTICLE * 2.0);\n\t\t\tfor (float i = -collisionRadius; i <= collisionRadius; ++i) {\n\t\t\t\tfor (float j = -collisionRadius; j <= collisionRadius; ++j) {\n\t\t\t\t\tcollide (vec2 (i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure the particle is still tracked\n\t\t\tif (particleIdCheck != fragCoord) {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticlePosition = vec2 (-1.0);\n\t\t\t} else {\n\n\t\t\t\t// Limit the time step\n\t\t\t\tfloat timeStep = min (iTimeDelta, TIME_STEP_MAX);\n\n\t\t\t\t// Update the velocity of the particle\n\t\t\t\tparticleVelocity += particleForce * timeStep;\n\n\t\t\t\t// Limit the velocity (to avoid losing track of the particle)\n\t\t\t\tvec2 delta = particleVelocity * timeStep;\n\t\t\t\tfloat dist = length (delta);\n\t\t\t\tif (dist > VELOCITY_MAX) {\n\t\t\t\t\tparticleVelocity *= VELOCITY_MAX / dist;\n\t\t\t\t}\n\n\t\t\t\t// Update the position of the particle\n\t\t\t\tparticlePosition += particleVelocity * timeStep;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Spawn a new particle?\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tif (fragCoord == particleId) {\n\t\t\t\tparticleVelocity = SPAWN_VELOCITY;\n\t\t\t\tparticlePosition = SPAWN_POSITION;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleVelocity, particlePosition);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Track the particles\n\n#define VELOCITY_MAX\t1.0\n#define SPAWN_POSITION\tiResolution.xy - 12.5\n\n#define CEIL(x) float (int (x + 0.9999)) // To workaround a bug with Firefox on Windows...\n\nbool reset;\nvec2 particleIdFound;\nfloat particleVelocity;\n\nfloat track (in vec2 fragCoord, in vec2 offset) {\n\n\t// Get the particle ID and collider\n\tvec2 cellPosition = fragCoord + offset;\n\tvec4 data;\n\tif (reset) {\n\n\t\t// Define the colliders\n\t\tvec2 midScreen = 0.5 * iResolution.xy;\n\t\tvec2 dist = abs (fragCoord - midScreen);\n\t\tvec2 container = step (midScreen - 5.0, dist);\n\t\tcontainer.y *= step (iResolution.y * 0.03, dist.x);\n\t\tfloat obstacle = step (length (fragCoord - iResolution.xy * vec2 (0.5, 0.3)), iResolution.y * 0.1);\n\n\t\t// Set the initial data\n\t\tdata = vec4 (cellPosition, 0.0, container.x + container.y + obstacle);\n\t} else {\n\n\t\t// Get the exisiting data\n\t\tdata = texture (iChannel1, cellPosition / iResolution.xy);\n\t}\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Get the position of this particle\n\tif (particleId.x > 0.0) {\n\t\tdata = texture (iChannel0, particleId / iResolution.xy);\n\t\tvec2 particlePosition = data.ba;\n\n\t\t// Check whether this particle is the one to track\n\t\tvec2 delta = floor (particlePosition - fragCoord + 0.5);\n\t\tif (delta == vec2 (0.0)) {\n\n\t\t\t// Take note of the particle ID and its velocity\n\t\t\tparticleIdFound = particleId;\n\t\t\tparticleVelocity = length (data.rg);\n\t\t}\n\t}\n\n\t// Return the collider\n\treturn collider;\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Initialization\n\tparticleIdFound = vec2 (-1.0);\n\tparticleVelocity = -1.0;\n\tfloat collider = 0.0;\n\n\t// Check the player inputs\n\tvec4 data = texture (iChannel2, vec2 (0.5) / iResolution.xy);\n\n\t// Allow to add colliders (removing particles)\n\tif (iMouse.z > 0.5) {\n\t\tfloat dist;\n\t\tif (data.b < 0.5) {\n\t\t\tdist = length (fragCoord - iMouse.xy);\n\t\t} else {\n\t\t\tdist = segDist (fragCoord, data.rg, iMouse.xy);\n\t\t}\n\t\tcollider = step (dist, 3.0);\n\t}\n\tif (collider < 0.5) {\n\n\t\t// Check the current position\n\t\treset = iFrame == 0 || data.a > 0.5;\n\t\tvec2 offset = vec2 (0.0);\n\t\tcollider = track (fragCoord, offset);\n\n\t\t// Track the particle (spiral loop from the current position)\n\t\tvec2 direction = vec2 (1.0, 0.0);\n\t\tfor (float n = 1.0; n < (2.0 * CEIL (VELOCITY_MAX) + 1.0) * (2.0 * CEIL (VELOCITY_MAX) + 1.0); ++n) {\n\t\t\tif (particleIdFound.x > 0.0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += direction;\n\t\t\ttrack (fragCoord, offset);\n\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t}\n\t\t}\n\n\t\t// Spawn a new particle?\n\t\tif (particleIdFound.x < 0.0 && fragCoord == SPAWN_POSITION) {\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tvec2 particlePosition = texture (iChannel0, particleId / iResolution.xy).ba;\n\t\t\tif (particlePosition == fragCoord) {\n\t\t\t\tparticleIdFound = particleId;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleIdFound, particleVelocity, collider);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Handle player inputs\n\n#define KEY_R\t\t(vec2 (82.5, 0.5) / 256.0)\n#define KEY_LEFT\t(vec2 (37.5, 0.5) / 256.0)\n#define KEY_RIGHT\t(vec2 (39.5, 0.5) / 256.0)\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n#define PI\t\t\t3.14159265359\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time\n\tif (fragCoord.x > 2.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Get the status of the reset (R) key\n\tfloat reset = texture (iChannel3, KEY_R).r;\n\n\t// Check what to do\n\tif (fragCoord.x < 1.0) {\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (iMouse.xyz, reset);\n\t} else {\n\n\t\t// Set the direction of the gravity\n\t\tfloat gravityDirection;\n\t\tfloat gravityTimer;\n\t\tif (iFrame == 0 || reset > 0.5) {\n\n\t\t\t// Reset the gravity\n\t\t\tgravityDirection = -PI * 0.5;\n\t\t\tgravityTimer = 0.0;\n\t\t} else {\n\n\t\t\t// Get the current values\n\t\t\tvec2 data = texture (iChannel2, fragCoord / iResolution.xy).rg;\n\t\t\tgravityDirection = data.r;\n\t\t\tgravityTimer = data.g;\n\n\t\t\t// Get the status of the left, right and space keys\n\t\t\tfloat keyLeft = texture (iChannel3, KEY_LEFT).r;\n\t\t\tfloat keyRight = texture (iChannel3, KEY_RIGHT).r;\n\t\t\tfloat keySpace = texture (iChannel3, KEY_SPACE).r;\n\t\t\tif (keyLeft + keyRight + keySpace < 0.5) {\n\t\t\t\tgravityTimer = max (0.0, gravityTimer - iTimeDelta * 5.0);\n\t\t\t} else {\n\t\t\t\tif (keyLeft > 0.5) {\n\t\t\t\t\tgravityDirection -= PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (keyRight > 0.5) {\n\t\t\t\t\tgravityDirection += PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (gravityTimer == 0.0) {\n\t\t\t\t\tgravityDirection += PI;\n\t\t\t\t}\n\t\t\t\tgravityTimer = 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (gravityDirection, gravityTimer, 0.0, 0.0);\n\t}\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ldy3D1",
    "date": "1454407846",
    "viewed": 2176,
    "name": "Liquid stuff 2",
    "description": "Similar to [url=https://www.shadertoy.com/view/4sK3zm]Liquid stuff[/url], but with better physics.\n\n- Mouse: draw colliders;\n- Mouse + SPACE: erase colliders;\n- LEFT / RIGHT: rotate the gravity;\n- DOWN: invert the gravity;\n- R: reset the scene.",
    "likes": 64,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "game",
     "fluid",
     "liquid",
     "physics"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Display particles and colliders\n\n// iChannel0 = [nothing]\n// iChannel1 = [nothing]\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define PARTICLE_RADIUS\t\t\t\t3.5\n#define PARTICLE_VELOCITY_FACTOR\t0.02\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvec3 particleColor (in float particleVelocity) {\n\treturn mix (vec3 (0.5, 0.6, 0.8), vec3 (0.9, 0.9, 1.0), particleVelocity * PARTICLE_VELOCITY_FACTOR);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check whether there is a collider here\n\tvec4 data = texture (iChannel2, fragCoord / iResolution.xy);\n\tvec3 color;\n\tif (data.a > 0.5) {\n\n\t\t// Display the collider (wood)\n\t\tvec2 uv = 0.02 * fragCoord;\n\t\tuv = uv.y * 13.0 + sin (uv * 11.0) * sin (uv.yx * 3.0);\n\t\tcolor = vec3 (0.8, 0.6, 0.4) * (1.0 - 0.5 * length (fract (uv) - 0.5));\n\t} else {\n\n\t\t// Display the background (light squares)\n\t\tvec2 uv = 0.05 * fragCoord;\n\t\tuv += 0.5 * cos (uv.yx + iTime);\n\t\tfloat angle = rand (floor (uv)) * 3.14159;\n\t\tvec3 hsv = vec3 (0.6 + 0.1 * cos (angle), 1.0, 0.2 + 0.1 * cos (angle * iTime));\n\t\tcolor = hsv2rgb (hsv) * smoothstep (1.0, 0.2, length (fract (uv) - 0.5));\n\n\t\t// Check whether there is a particle here\n\t\tfloat particleVelocity = data.b;\n\t\tfloat weightTotal = step (0.0, particleVelocity);\n\t\tfloat weightedVelocity = weightTotal * particleVelocity;\n\n\t\t// Check for nearby particles\n\t\tconst float displayRadius = CEIL (PARTICLE_RADIUS);\n\t\tfor (float i = -displayRadius; i <= displayRadius; ++i) {\n\t\t\tfor (float j = -displayRadius; j <= displayRadius; ++j) {\n\t\t\t\tvec2 offset = vec2 (i, j);\n\t\t\t\tif (offset != vec2 (0.0)) {\n\t\t\t\t\tparticleVelocity = texture (iChannel2, (fragCoord + offset) / iResolution.xy).b;\n\t\t\t\t\tif (particleVelocity >= 0.0) {\n\t\t\t\t\t\tfloat weight = max (0.0, 1.0 - (length (offset) - 1.0) / PARTICLE_RADIUS);\n\t\t\t\t\t\tweightTotal += weight;\n\t\t\t\t\t\tweightedVelocity += weight * particleVelocity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Display the particle\n\t\tif (weightTotal > 0.0) {\n\t\t\tcolor += particleColor (weightedVelocity / weightTotal) * min (weightTotal * weightTotal, 1.0);\n\t\t}\n\t}\n\n\t// Display the direction of the gravity\n\tdata = texture (iChannel3, vec2 (1.5, 0.5) / iResolution.xy);\n\tfloat gravityTimer = data.g;\n\tif (gravityTimer > 0.0) {\n\t\tfloat gravityDirection = data.r;\n\t\tvec2 frag = fragCoord - 0.5 * iResolution.xy;\n\t\tvec2 direction = vec2 (cos (gravityDirection), sin (gravityDirection));\n\t\tvec2 pointA = 25.0 * direction;\n\t\tvec2 pointB = 15.0 * direction;\n\t\tvec2 offset = 10.0 * vec2 (direction.y, -direction.x);\n\t\tfloat dist = segDist (frag, -pointA, pointA);\n\t\tdist = min (dist, segDist (frag, pointA, pointB + offset));\n\t\tdist = min (dist, segDist (frag, pointA, pointB - offset));\n\t\tcolor = mix (color, vec3 (smoothstep (4.0, 3.0, dist)), gravityTimer * smoothstep (6.0, 5.0, dist));\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Update the density of each particle\n\n// iChannel0 = Buf A (density)\n// iChannel1 = Buf B (velocity & position)\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define PARTICLE_RADIUS\t\t\t2.5\n#define PARTICLE_DENSITY_REST\t0.4\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n\nfloat particleDensity;\nvec2 particlePosition;\nvec2 particleIdCheck;\n\nvoid densityUpdate (in vec2 offset) {\n\n\t// Get the position of the cell\n\tvec2 cellPosition = floor (particlePosition + offset) + 0.5;\n\n\t// Get the particle ID\n\tvec2 particleId = texture (iChannel2, cellPosition / iResolution.xy).rg;\n\n\t// Check whether there is a particle here\n\tif (offset == vec2 (0.0)) {\n\n\t\t// This is the current particle\n\t\tparticleIdCheck = particleId;\n\t} else if (particleId.x > 0.0) {\n\n\t\t// Get the position of this other particle\n\t\tvec2 otherParticlePosition = texture (iChannel1, particleId / iResolution.xy).ba;\n\n\t\t// Check whether these 2 particles touch each other\n\t\tfloat dist = length (otherParticlePosition - particlePosition);\n\t\tif (dist < 2.0 * PARTICLE_RADIUS) {\n\n\t\t\t// Compute the density\n\t\t\tfloat compression = 1.0 - dist / (2.0 * PARTICLE_RADIUS);\n\t\t\tparticleDensity += compression * compression * compression;\n\t\t}\n\t}\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check for a reset\n\tbool reset = iFrame == 0 || texture (iChannel3, vec2 (0.5) / iResolution.xy).a > 0.5;\n\n\t// Define the density\n\tif (reset) {\n\t\tparticleDensity = 1.0;\n\t} else {\n\n\t\t// Get the particle data\n\t\tparticlePosition = texture (iChannel1, fragCoord / iResolution.xy).ba;\n\t\tif (particlePosition.x > 0.0) {\n\t\t\tparticleDensity = 1.0;\n\n\t\t\t// Check for nearby particles\n\t\t\tparticleIdCheck = vec2 (-1.0);\n\t\t\tconst float collisionRadius = CEIL (PARTICLE_RADIUS * 2.0);\n\t\t\tfor (float i = -collisionRadius; i <= collisionRadius; ++i) {\n\t\t\t\tfor (float j = -collisionRadius; j <= collisionRadius; ++j) {\n\t\t\t\t\tdensityUpdate (vec2 (i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure the particle is still tracked\n\t\t\tif (particleIdCheck != fragCoord) {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticleDensity = 0.0;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// The particle is lost...\n\t\t\tparticleDensity = 0.0;\n\t\t}\n\t}\n\n\t// Compute the \"density factor\" to ease the computation of the pressure force\n\tfloat particleDensityFactor = (particleDensity - PARTICLE_DENSITY_REST) / (particleDensity * particleDensity);\n\n\t// Update the fragment\n\tfragColor = vec4 (particleDensity, particleDensityFactor, 0.0, 0.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Update the velocity and position of each particle\n\n// iChannel0 = Buf A (density)\n// iChannel1 = Buf B (velocity & position)\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define GRAVITY_NORM\t\t\t\t100.0\n#define PARTICLE_RADIUS\t\t\t\t2.5\n#define PARTICLE_PRESSURE_FACTOR\t3000.0\n#define PARTICLE_VISCOSITY_FACTOR\t4.0\n#define PARTICLE_VELOCITY_MAX\t\t1.5\n#define PARTICLE_SPAWN_VELOCITY\t\tvec2 (-200.0, 0.0)\n#define PARTICLE_SPAWN_POSITION\t\tiResolution.xy - 12.5\n#define COLLIDER_RADIUS\t\t\t\t0.75\n#define COLLIDER_SPRING_STIFFNESS\t4000.0\n#define COLLIDER_SPRING_DAMPING\t\t4.0\n#define TIME_STEP_MAX\t\t\t\t0.02\n#define SQRT3\t\t\t\t\t\t1.732\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n#define MAX(x,y) ((x) > (y) ? (x) : (y))\n\nfloat particleDensity;\nfloat particleDensityFactor;\nvec2 particleAcceleration;\nvec2 particleVelocity;\nvec2 particlePosition;\nvec2 particleIdCheck;\n\nvec2 rand (in vec2 seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nvoid accelerationUpdate (in vec2 offset) {\n\n\t// Get the position of the cell\n\tvec2 cellPosition = floor (particlePosition + offset) + 0.5;\n\n\t// Get the particle ID and the collider\n\tvec4 data = texture (iChannel2, cellPosition / iResolution.xy);\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Check whether there is a particle here\n\tif (offset == vec2 (0.0)) {\n\n\t\t// This is the current particle\n\t\tparticleIdCheck = particleId;\n\t} else if (particleId.x > 0.0) {\n\n\t\t// Get the position of this other particle\n\t\tdata = texture (iChannel1, particleId / iResolution.xy);\n\t\tvec2 otherParticlePosition = data.ba;\n\n\t\t// Compute the distance between these 2 particles\n\t\tvec2 direction = otherParticlePosition - particlePosition;\n\t\tfloat dist = length (direction);\n\n\t\t// Check whether these 2 particles touch each other\n\t\tif (dist < 2.0 * PARTICLE_RADIUS) {\n\n\t\t\t// Normalize the direction\n\t\t\tdirection /= dist;\n\t\t\tdist /= 2.0 * PARTICLE_RADIUS;\n\n\t\t\t// Get the velocity and density of this other particle\n\t\t\tvec2 otherParticleVelocity = data.rg;\n\t\t\tdata = texture (iChannel0, particleId / iResolution.xy);\n\t\t\tfloat otherParticleDensity = data.r;\n\t\t\tfloat otherParticleDensityFactor = data.g;\n\n\t\t\t// Apply the pressure and viscosity forces (SPH)\n\t\t\tfloat compression = 1.0 - dist;\n\t\t\tfloat pressure = PARTICLE_PRESSURE_FACTOR * (particleDensityFactor + otherParticleDensityFactor);\n\t\t\tfloat viscosity = PARTICLE_VISCOSITY_FACTOR * max (0.0, dot (particleVelocity - otherParticleVelocity, direction)) / ((particleDensity + otherParticleDensity) * dist);\n\t\t\tparticleAcceleration -= direction * (pressure + viscosity) * 3.0 * compression * compression;\n\t\t}\n\t}\n\n\t// Collision with a collider?\n\tif (collider > 0.5) {\n\n\t\t// Compute the signed distance between the center of the particle (circle) and the border of the collider (square)\n\t\tvec2 direction = cellPosition - particlePosition;\n\t\tvec2 distCollider = abs (direction) - COLLIDER_RADIUS;\n\t\tfloat dist = length (max (distCollider, 0.0)) + min (max (distCollider.x, distCollider.y), 0.0);\n\n\t\t// Check whether the particle touches the collider\n\t\tif (dist < PARTICLE_RADIUS) {\n\n\t\t\t// Normalize the direction\n\t\t\tdirection = sign (direction) * (dist > 0.0 ? distCollider / dist : step (distCollider.yx, distCollider));\n\n\t\t\t// Apply the collision force (spring)\n\t\t\tfloat compression = 1.0 - (dist + COLLIDER_RADIUS) / (PARTICLE_RADIUS + COLLIDER_RADIUS);\n\t\t\tparticleAcceleration -= direction * (compression * COLLIDER_SPRING_STIFFNESS + dot (particleVelocity, direction) * COLLIDER_SPRING_DAMPING);\n\t\t}\n\t}\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check for a reset\n\tbool reset = iFrame == 0 || texture (iChannel3, vec2 (0.5) / iResolution.xy).a > 0.5;\n\n\t// Define the particle data\n\tif (reset) {\n\n\t\t// Define the particle spawning area\n\t\tfloat liquid =\n\t\t\tstep (abs (fragCoord.x - iResolution.x * 0.5), iResolution.x * 0.5 - 5.0 - PARTICLE_RADIUS)\n\t\t\t* step (iResolution.y * 0.5, fragCoord.y)\n\t\t\t* step (fragCoord.y, iResolution.y - 5.0 - PARTICLE_RADIUS)\n\t\t\t* step (mod (fragCoord.x + SQRT3 * fragCoord.y, ceil (2.0 * PARTICLE_RADIUS)), 1.0)\n\t\t\t* step (mod (fragCoord.y, ceil (SQRT3 * PARTICLE_RADIUS)), 1.0);\n\n\t\t// Initialize the particle\n\t\tparticleVelocity = vec2 (0.0);\n\t\tparticlePosition = liquid > 0.5 ? fragCoord + 0.01 * rand (fragCoord): vec2 (-1.0);\n\t} else {\n\n\t\t// Get the particle data\n\t\tvec4 data = texture (iChannel0, fragCoord / iResolution.xy);\n\t\tparticleDensity = data.r;\n\t\tif (particleDensity > 0.5) {\n\t\t\tparticleDensityFactor = data.g;\n\t\t\tdata = texture (iChannel1, fragCoord / iResolution.xy);\n\t\t\tparticleVelocity = data.rg;\n\t\t\tparticlePosition = data.ba;\n\n\t\t\t// Initialize the acceleration\n\t\t\tfloat gravityDirection = texture (iChannel3, vec2 (1.5, 0.5) / iResolution.xy).r;\n\t\t\tparticleAcceleration = GRAVITY_NORM * vec2 (cos (gravityDirection), sin (gravityDirection));\n\n\t\t\t// Check for collisions with nearby particles and colliders\n\t\t\tparticleIdCheck = vec2 (-1.0);\n\t\t\tconst float collisionRadius = CEIL (PARTICLE_RADIUS + MAX (PARTICLE_RADIUS, COLLIDER_RADIUS));\n\t\t\tfor (float i = -collisionRadius; i <= collisionRadius; ++i) {\n\t\t\t\tfor (float j = -collisionRadius; j <= collisionRadius; ++j) {\n\t\t\t\t\taccelerationUpdate (vec2 (i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure the particle is still tracked\n\t\t\tif (particleIdCheck != fragCoord) {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticlePosition = vec2 (-1.0);\n\t\t\t} else {\n\n\t\t\t\t// Limit the time step\n\t\t\t\tfloat timeStep = min (iTimeDelta, TIME_STEP_MAX);\n\n\t\t\t\t// Update the velocity of the particle\n\t\t\t\tparticleVelocity += particleAcceleration * timeStep;\n\n\t\t\t\t// Limit the velocity (to avoid losing track of the particle)\n\t\t\t\tfloat dist = length (particleVelocity * timeStep);\n\t\t\t\tif (dist > PARTICLE_VELOCITY_MAX) {\n\t\t\t\t\tparticleVelocity *= PARTICLE_VELOCITY_MAX / dist;\n\t\t\t\t}\n\n\t\t\t\t// Update the position of the particle\n\t\t\t\tparticlePosition += particleVelocity * timeStep;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Check the particle ID\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tif (fragCoord == particleId) {\n\n\t\t\t\t// Spawn a new particle\n\t\t\t\tparticleVelocity = PARTICLE_SPAWN_VELOCITY;\n\t\t\t\tparticlePosition = floor (PARTICLE_SPAWN_POSITION) + 0.5;\n\t\t\t} else {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticlePosition = vec2 (-1.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleVelocity, particlePosition);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Track the particles\n\n// iChannel0 = [nothing]\n// iChannel1 = Buf B (velocity & position)\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define PARTICLE_VELOCITY_MAX\t1.5\n#define PARTICLE_SPAWN_POSITION\tiResolution.xy - 12.5\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n\nbool reset;\nvec2 particleIdFound;\nfloat particleVelocity;\n\nfloat track (in vec2 fragCoord, in vec2 offset) {\n\n\t// Get the particle ID and collider\n\tvec2 cellPosition = fragCoord + offset;\n\tvec4 data;\n\tif (reset) {\n\n\t\t// Define the colliders\n\t\tfloat collider = step (fragCoord.x, 5.0);\n\t\tcollider += step (iResolution.x - 5.0, fragCoord.x);\n\t\tcollider += step (fragCoord.y, 5.0);\n\t\tcollider += step (iResolution.y - 5.0, fragCoord.y) * step (0.9 * iResolution.x, fragCoord.x);\n\t\tcollider += step (length (fragCoord - iResolution.xy * vec2 (0.5, 0.3)), iResolution.y * 0.1);\n\n\t\t// Set the initial data\n\t\tdata = vec4 (cellPosition, 0.0, collider);\n\t} else {\n\n\t\t// Get the exisiting data\n\t\tdata = texture (iChannel2, cellPosition / iResolution.xy);\n\t}\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Get the position of this particle\n\tif (particleId.x > 0.0) {\n\t\tdata = texture (iChannel1, particleId / iResolution.xy);\n\t\tvec2 particlePosition = data.ba;\n\n\t\t// Check whether this particle is the one to track\n\t\tvec2 delta = floor (particlePosition - fragCoord + 0.5);\n\t\tif (delta == vec2 (0.0)) {\n\n\t\t\t// Take note of the particle ID and its velocity\n\t\t\tparticleIdFound = particleId;\n\t\t\tparticleVelocity = length (data.rg);\n\t\t}\n\t}\n\n\t// Return the collider\n\treturn collider;\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Initialization\n\tparticleIdFound = vec2 (-1.0);\n\tparticleVelocity = -1.0;\n\tfloat collider = 0.0;\n\n\t// Check the player inputs\n\tvec4 data = texture (iChannel3, vec2 (0.5) / iResolution.xy);\n\treset = iFrame == 0 || data.a > 0.5;\n\n\t// Check the current position\n\tvec2 offset = vec2 (0.0);\n\tcollider = track (fragCoord, offset);\n\n\t// Allow to add colliders (removing particles)\n\tif (iMouse.z > 0.5) {\n\t\tfloat dist;\n\t\tif (data.b < 0.5) {\n\t\t\tdist = length (fragCoord - iMouse.xy);\n\t\t} else {\n\t\t\tdist = segDist (fragCoord, data.rg, iMouse.xy);\n\t\t}\n\t\tif (dist < 3.0) {\n\t\t\tcollider = texture (iChannel3, vec2 (1.5, 0.5) / iResolution.xy).b;\n\t\t}\n\t}\n\tif (collider < 0.5) {\n\n\t\t// Track the particle (spiral loop from the current position)\n\t\tvec2 direction = vec2 (1.0, 0.0);\n\t\tfor (float n = 1.0; n < (2.0 * CEIL (PARTICLE_VELOCITY_MAX) + 1.0) * (2.0 * CEIL (PARTICLE_VELOCITY_MAX) + 1.0); ++n) {\n\t\t\tif (particleIdFound.x > 0.0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += direction;\n\t\t\ttrack (fragCoord, offset);\n\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t}\n\t\t}\n\n\t\t// Spawn a new particle?\n\t\tif (particleIdFound.x < 0.0 && fragCoord == floor (PARTICLE_SPAWN_POSITION) + 0.5) {\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tvec2 particlePosition = texture (iChannel1, particleId / iResolution.xy).ba;\n\t\t\tif (particlePosition == fragCoord) {\n\t\t\t\tparticleIdFound = particleId;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleIdFound, particleVelocity, collider);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Handle player inputs\n\n// iChannel0 = Keyboard\n// iChannel1 = [nothing]\n// iChannel2 = [nothing]\n// iChannel3 = Buf D (inputs)\n\n#define KEY_R\t\t(vec2 (82.5, 0.5) / 256.0)\n#define KEY_LEFT\t(vec2 (37.5, 0.5) / 256.0)\n#define KEY_RIGHT\t(vec2 (39.5, 0.5) / 256.0)\n#define KEY_DOWN\t(vec2 (40.5, 0.5) / 256.0)\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n#define PI\t\t\t3.14159265359\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time\n\tif (fragCoord.x > 2.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Get the status of the reset (R) key\n\tfloat reset = texture (iChannel0, KEY_R).r;\n\n\t// Check what to do\n\tif (fragCoord.x < 1.0) {\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (iMouse.xyz, reset);\n\t} else {\n\n\t\t// Set the direction of the gravity\n\t\tfloat gravityDirection;\n\t\tfloat gravityTimer;\n\t\tif (iFrame == 0 || reset > 0.5) {\n\n\t\t\t// Reset the gravity\n\t\t\tgravityDirection = -PI * 0.5;\n\t\t\tgravityTimer = 0.0;\n\t\t} else {\n\n\t\t\t// Get the current values\n\t\t\tvec2 data = texture (iChannel3, fragCoord / iResolution.xy).rg;\n\t\t\tgravityDirection = data.r;\n\t\t\tgravityTimer = data.g;\n\n\t\t\t// Get the status of the left, right and down keys\n\t\t\tfloat keyLeft = texture (iChannel0, KEY_LEFT).r;\n\t\t\tfloat keyRight = texture (iChannel0, KEY_RIGHT).r;\n\t\t\tfloat keyDown = texture (iChannel0, KEY_DOWN).r;\n\t\t\tif (keyLeft + keyRight + keyDown < 0.5) {\n\t\t\t\tgravityTimer = max (0.0, gravityTimer - iTimeDelta * 5.0);\n\t\t\t} else {\n\t\t\t\tif (keyLeft > 0.5) {\n\t\t\t\t\tgravityDirection -= PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (keyRight > 0.5) {\n\t\t\t\t\tgravityDirection += PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (gravityTimer == 0.0) {\n\t\t\t\t\tgravityDirection += PI;\n\t\t\t\t}\n\t\t\t\tgravityTimer = 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// Get the status of the space key\n\t\tfloat keySpace = texture (iChannel0, KEY_SPACE).r;\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (gravityDirection, gravityTimer, 1.0 - keySpace, 0.0);\n\t}\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4sKGDK",
    "date": "1456463598",
    "viewed": 938,
    "name": "Hot liquid metal",
    "description": "A variation of [url=https://www.shadertoy.com/view/ldy3D1]Liquid stuff 2[/url]...\n\nControls:\n- Mouse: draw colliders;\n- Mouse + SPACE: erase colliders;\n- LEFT / RIGHT: rotate the gravity;\n- DOWN: invert the gravity;\n- R: reset the scene.",
    "likes": 23,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "fluid",
     "liquid",
     "physics"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGRn",
       "filepath": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Display particles and colliders\n\n// iChannel0 = Background texture\n// iChannel1 = [nothing]\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define PARTICLE_RADIUS\t\t\t\t3.5\n#define PARTICLE_VELOCITY_FACTOR\t0.02\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvec3 particleColor (in float particleVelocity) {\n\treturn mix (vec3 (0.8, 0.2, 0.2), vec3 (1.0, 1.0, 0.5), particleVelocity * PARTICLE_VELOCITY_FACTOR);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the background texture\n\tvec3 color = texture (iChannel0, fragCoord / iResolution.xy).rgb;\n\n\t// Check whether there is a collider here\n\tvec4 data = texture (iChannel2, fragCoord / iResolution.xy);\n\tfloat collider = data.a;\n\tif (collider < 0.5) {\n\n\t\t// Darken the background\n\t\tcolor *= 0.4;\n\n\t\t// Check whether there is a particle here\n\t\tfloat particleVelocity = data.b;\n\t\tfloat weightTotal = step (0.0, particleVelocity);\n\t\tfloat weightedVelocity = weightTotal * particleVelocity;\n\n\t\t// Check for nearby particles\n\t\tconst float displayRadius = CEIL (PARTICLE_RADIUS);\n\t\tfor (float i = -displayRadius; i <= displayRadius; ++i) {\n\t\t\tfor (float j = -displayRadius; j <= displayRadius; ++j) {\n\t\t\t\tvec2 offset = vec2 (i, j);\n\t\t\t\tif (offset != vec2 (0.0)) {\n\t\t\t\t\tparticleVelocity = texture (iChannel2, (fragCoord + offset) / iResolution.xy).b;\n\t\t\t\t\tif (particleVelocity >= 0.0) {\n\t\t\t\t\t\tfloat weight = max (0.0, 1.0 - (length (offset) - 1.0) / PARTICLE_RADIUS);\n\t\t\t\t\t\tweightTotal += weight;\n\t\t\t\t\t\tweightedVelocity += weight * particleVelocity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Display the particle\n\t\tif (weightTotal > 0.0) {\n\t\t\tcolor += particleColor (weightedVelocity / weightTotal) * min (weightTotal * weightTotal, 1.0);\n\t\t}\n\t}\n\n\t// Display the direction of the gravity\n\tdata = texture (iChannel3, vec2 (1.5, 0.5) / iResolution.xy);\n\tfloat gravityTimer = data.g;\n\tif (gravityTimer > 0.0) {\n\t\tfloat gravityDirection = data.r;\n\t\tvec2 frag = fragCoord - 0.5 * iResolution.xy;\n\t\tvec2 direction = vec2 (cos (gravityDirection), sin (gravityDirection));\n\t\tvec2 pointA = 25.0 * direction;\n\t\tvec2 pointB = 15.0 * direction;\n\t\tvec2 offset = 10.0 * vec2 (direction.y, -direction.x);\n\t\tfloat dist = segDist (frag, -pointA, pointA);\n\t\tdist = min (dist, segDist (frag, pointA, pointB + offset));\n\t\tdist = min (dist, segDist (frag, pointA, pointB - offset));\n\t\tcolor = mix (color, vec3 (smoothstep (4.0, 3.0, dist)), gravityTimer * smoothstep (6.0, 5.0, dist));\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Update the density of each particle\n\n// iChannel0 = Buf A (density)\n// iChannel1 = Buf B (velocity & position)\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define PARTICLE_RADIUS\t\t\t2.5\n#define PARTICLE_DENSITY_REST\t0.4\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n\nfloat particleDensity;\nvec2 particlePosition;\nvec2 particleIdCheck;\n\nvoid densityUpdate (in vec2 offset) {\n\n\t// Get the position of the cell\n\tvec2 cellPosition = floor (particlePosition + offset) + 0.5;\n\n\t// Get the particle ID\n\tvec2 particleId = texture (iChannel2, cellPosition / iResolution.xy).rg;\n\n\t// Check whether there is a particle here\n\tif (offset == vec2 (0.0)) {\n\n\t\t// This is the current particle\n\t\tparticleIdCheck = particleId;\n\t} else if (particleId.x > 0.0) {\n\n\t\t// Get the position of this other particle\n\t\tvec2 otherParticlePosition = texture (iChannel1, particleId / iResolution.xy).ba;\n\n\t\t// Check whether these 2 particles touch each other\n\t\tfloat dist = length (otherParticlePosition - particlePosition);\n\t\tif (dist < 2.0 * PARTICLE_RADIUS) {\n\n\t\t\t// Compute the density\n\t\t\tfloat compression = 1.0 - dist / (2.0 * PARTICLE_RADIUS);\n\t\t\tparticleDensity += compression * compression * compression;\n\t\t}\n\t}\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check for a reset\n\tbool reset = iFrame == 0 || texture (iChannel3, vec2 (0.5) / iResolution.xy).a > 0.5;\n\n\t// Define the density\n\tif (reset) {\n\t\tparticleDensity = 1.0;\n\t} else {\n\n\t\t// Get the particle data\n\t\tparticlePosition = texture (iChannel1, fragCoord / iResolution.xy).ba;\n\t\tif (particlePosition.x > 0.0) {\n\t\t\tparticleDensity = 1.0;\n\n\t\t\t// Check for nearby particles\n\t\t\tparticleIdCheck = vec2 (-1.0);\n\t\t\tconst float collisionRadius = CEIL (PARTICLE_RADIUS * 2.0);\n\t\t\tfor (float i = -collisionRadius; i <= collisionRadius; ++i) {\n\t\t\t\tfor (float j = -collisionRadius; j <= collisionRadius; ++j) {\n\t\t\t\t\tdensityUpdate (vec2 (i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure the particle is still tracked\n\t\t\tif (particleIdCheck != fragCoord) {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticleDensity = 0.0;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// The particle is lost...\n\t\t\tparticleDensity = 0.0;\n\t\t}\n\t}\n\n\t// Compute the \"density factor\" to ease the computation of the pressure force\n\tfloat particleDensityFactor = (particleDensity - PARTICLE_DENSITY_REST) / (particleDensity * particleDensity);\n\n\t// Update the fragment\n\tfragColor = vec4 (particleDensity, particleDensityFactor, 0.0, 0.0);\n}",
     "name": "Buf A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Update the velocity and position of each particle\n\n// iChannel0 = Buf A (density)\n// iChannel1 = Buf B (velocity & position)\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define GRAVITY_NORM\t\t\t\t100.0\n#define PARTICLE_RADIUS\t\t\t\t2.5\n#define PARTICLE_PRESSURE_FACTOR\t4000.0\n#define PARTICLE_VISCOSITY_FACTOR\t40.0\n#define PARTICLE_VELOCITY_MAX\t\t1.5\n#define PARTICLE_SPAWN_VELOCITY\t\tvec2 (-10.0, 0.0)\n#define PARTICLE_SPAWN_POSITION\t\tiResolution.xy * 0.9\n#define COLLIDER_RADIUS\t\t\t\t0.75\n#define COLLIDER_SPRING_STIFFNESS\t4000.0\n#define COLLIDER_SPRING_DAMPING\t\t20.0\n#define TIME_STEP_MAX\t\t\t\t0.02\n#define SQRT3\t\t\t\t\t\t1.732\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n#define MAX(x,y) ((x) > (y) ? (x) : (y))\n\nfloat particleDensity;\nfloat particleDensityFactor;\nvec2 particleAcceleration;\nvec2 particleVelocity;\nvec2 particlePosition;\nvec2 particleIdCheck;\n\nvec2 rand (in vec2 seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nvoid accelerationUpdate (in vec2 offset) {\n\n\t// Get the position of the cell\n\tvec2 cellPosition = floor (particlePosition + offset) + 0.5;\n\n\t// Get the particle ID and the collider\n\tvec4 data = texture (iChannel2, cellPosition / iResolution.xy);\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Check whether there is a particle here\n\tif (offset == vec2 (0.0)) {\n\n\t\t// This is the current particle\n\t\tparticleIdCheck = particleId;\n\t} else if (particleId.x > 0.0) {\n\n\t\t// Get the position of this other particle\n\t\tdata = texture (iChannel1, particleId / iResolution.xy);\n\t\tvec2 otherParticlePosition = data.ba;\n\n\t\t// Compute the distance between these 2 particles\n\t\tvec2 direction = otherParticlePosition - particlePosition;\n\t\tfloat dist = length (direction);\n\n\t\t// Check whether these 2 particles touch each other\n\t\tif (dist < 2.0 * PARTICLE_RADIUS) {\n\n\t\t\t// Normalize the direction\n\t\t\tdirection /= dist;\n\t\t\tdist /= 2.0 * PARTICLE_RADIUS;\n\n\t\t\t// Get the velocity and density of this other particle\n\t\t\tvec2 otherParticleVelocity = data.rg;\n\t\t\tdata = texture (iChannel0, particleId / iResolution.xy);\n\t\t\tfloat otherParticleDensity = data.r;\n\t\t\tfloat otherParticleDensityFactor = data.g;\n\n\t\t\t// Apply the pressure and viscosity forces (SPH)\n\t\t\tfloat compression = 1.0 - dist;\n\t\t\tfloat pressure = PARTICLE_PRESSURE_FACTOR * (particleDensityFactor + otherParticleDensityFactor);\n\t\t\tfloat viscosity = PARTICLE_VISCOSITY_FACTOR * max (0.0, dot (particleVelocity - otherParticleVelocity, direction)) / ((particleDensity + otherParticleDensity) * dist);\n\t\t\tparticleAcceleration -= direction * (pressure + viscosity) * 3.0 * compression * compression;\n\t\t}\n\t}\n\n\t// Collision with a collider?\n\tif (collider > 0.5) {\n\n\t\t// Compute the signed distance between the center of the particle (circle) and the border of the collider (square)\n\t\tvec2 direction = cellPosition - particlePosition;\n\t\tvec2 distCollider = abs (direction) - COLLIDER_RADIUS;\n\t\tfloat dist = length (max (distCollider, 0.0)) + min (max (distCollider.x, distCollider.y), 0.0);\n\n\t\t// Check whether the particle touches the collider\n\t\tif (dist < PARTICLE_RADIUS) {\n\n\t\t\t// Normalize the direction\n\t\t\tdirection = sign (direction) * (dist > 0.0 ? distCollider / dist : step (distCollider.yx, distCollider));\n\n\t\t\t// Apply the collision force (spring)\n\t\t\tfloat compression = 1.0 - (dist + COLLIDER_RADIUS) / (PARTICLE_RADIUS + COLLIDER_RADIUS);\n\t\t\tparticleAcceleration -= direction * (compression * COLLIDER_SPRING_STIFFNESS + dot (particleVelocity, direction) * COLLIDER_SPRING_DAMPING);\n\t\t}\n\t}\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Check for a reset\n\tbool reset = iFrame == 0 || texture (iChannel3, vec2 (0.5) / iResolution.xy).a > 0.5;\n\n\t// Define the particle data\n\tif (reset) {\n\n\t\t// Define the particle spawning area\n\t\tfloat liquid =\n\t\t\tstep (fragCoord.y, iResolution.y * 0.5)\n\t\t\t* step (mod (fragCoord.x + SQRT3 * fragCoord.y, ceil (2.0 * PARTICLE_RADIUS)), 1.0)\n\t\t\t* step (mod (fragCoord.y, ceil (SQRT3 * PARTICLE_RADIUS)), 1.0);\n\n\t\t// Initialize the particle\n\t\tparticleVelocity = vec2 (0.0);\n\t\tparticlePosition = liquid > 0.5 ? fragCoord + 0.01 * rand (fragCoord): vec2 (-1.0);\n\t} else {\n\n\t\t// Get the particle data\n\t\tvec4 data = texture (iChannel0, fragCoord / iResolution.xy);\n\t\tparticleDensity = data.r;\n\t\tif (particleDensity > 0.5) {\n\t\t\tparticleDensityFactor = data.g;\n\t\t\tdata = texture (iChannel1, fragCoord / iResolution.xy);\n\t\t\tparticleVelocity = data.rg;\n\t\t\tparticlePosition = data.ba;\n\n\t\t\t// Initialize the acceleration\n\t\t\tfloat gravityDirection = texture (iChannel3, vec2 (1.5, 0.5) / iResolution.xy).r;\n\t\t\tparticleAcceleration = GRAVITY_NORM * vec2 (cos (gravityDirection), sin (gravityDirection));\n\n\t\t\t// Check for collisions with nearby particles and colliders\n\t\t\tparticleIdCheck = vec2 (-1.0);\n\t\t\tconst float collisionRadius = CEIL (PARTICLE_RADIUS + MAX (PARTICLE_RADIUS, COLLIDER_RADIUS));\n\t\t\tfor (float i = -collisionRadius; i <= collisionRadius; ++i) {\n\t\t\t\tfor (float j = -collisionRadius; j <= collisionRadius; ++j) {\n\t\t\t\t\taccelerationUpdate (vec2 (i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make sure the particle is still tracked\n\t\t\tif (particleIdCheck != fragCoord) {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticlePosition = vec2 (-1.0);\n\t\t\t} else {\n\n\t\t\t\t// Limit the time step\n\t\t\t\tfloat timeStep = min (iTimeDelta, TIME_STEP_MAX);\n\n\t\t\t\t// Update the velocity of the particle\n\t\t\t\tparticleVelocity += particleAcceleration * timeStep;\n\n\t\t\t\t// Limit the velocity (to avoid losing track of the particle)\n\t\t\t\tfloat dist = length (particleVelocity * timeStep);\n\t\t\t\tif (dist > PARTICLE_VELOCITY_MAX) {\n\t\t\t\t\tparticleVelocity *= PARTICLE_VELOCITY_MAX / dist;\n\t\t\t\t}\n\n\t\t\t\t// Update the position of the particle\n\t\t\t\tparticlePosition += particleVelocity * timeStep;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Check the particle ID\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tif (fragCoord == particleId) {\n\n\t\t\t\t// Spawn a new particle\n\t\t\t\tparticleVelocity = PARTICLE_SPAWN_VELOCITY;\n\t\t\t\tparticlePosition = floor (PARTICLE_SPAWN_POSITION) + 0.5;\n\t\t\t} else {\n\n\t\t\t\t// The particle is lost...\n\t\t\t\tparticlePosition = vec2 (-1.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleVelocity, particlePosition);\n}",
     "name": "Buf B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Track the particles\n\n// iChannel0 = [nothing]\n// iChannel1 = Buf B (velocity & position)\n// iChannel2 = Buf C (id & colliders)\n// iChannel3 = Buf D (inputs)\n\n#define PARTICLE_VELOCITY_MAX\t1.5\n#define PARTICLE_SPAWN_POSITION\tiResolution.xy * 0.9\n\n#define CEIL(x) (float (int ((x) + 0.9999))) // To workaround a bug with Firefox on Windows...\n\nbool reset;\nvec2 particleIdFound;\nfloat particleVelocity;\n\nfloat track (in vec2 fragCoord, in vec2 offset) {\n\n\t// Get the particle ID and collider\n\tvec2 cellPosition = fragCoord + offset;\n\tvec4 data;\n\tif (reset) {\n\n\t\t// Define the colliders\n\t\tfloat collider = step (0.5 * iResolution.x - 5.0, abs (fragCoord.x - 0.5 * iResolution.x));\n\t\tcollider += step (fragCoord.y, 5.0);\n\t\tcollider += step (abs (fragCoord.y - 0.8 * iResolution.y), 2.5) * step (0.8 * iResolution.x, fragCoord.x);\n\n\t\t// Set the initial data\n\t\tdata = vec4 (cellPosition, 0.0, collider);\n\t} else {\n\n\t\t// Get the exisiting data\n\t\tdata = texture (iChannel2, cellPosition / iResolution.xy);\n\t}\n\tvec2 particleId = data.rg;\n\tfloat collider = data.a;\n\n\t// Get the position of this particle\n\tif (particleId.x > 0.0) {\n\t\tdata = texture (iChannel1, particleId / iResolution.xy);\n\t\tvec2 particlePosition = data.ba;\n\n\t\t// Check whether this particle is the one to track\n\t\tvec2 delta = floor (particlePosition - fragCoord + 0.5);\n\t\tif (delta == vec2 (0.0)) {\n\n\t\t\t// Take note of the particle ID and its velocity\n\t\t\tparticleIdFound = particleId;\n\t\t\tparticleVelocity = length (data.rg);\n\t\t}\n\t}\n\n\t// Return the collider\n\treturn collider;\n}\n\nvec2 rand (in float seed) {\n\tvec2 n = seed * vec2 (12.9898, 78.233);\n\treturn fract (n.yx * fract (n));\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Initialization\n\tparticleIdFound = vec2 (-1.0);\n\tparticleVelocity = -1.0;\n\tfloat collider = 0.0;\n\n\t// Check the player inputs\n\tvec4 data = texture (iChannel3, vec2 (0.5) / iResolution.xy);\n\treset = iFrame == 0 || data.a > 0.5;\n\n\t// Check the current position\n\tvec2 offset = vec2 (0.0);\n\tcollider = track (fragCoord, offset);\n\n\t// Allow to add colliders (removing particles)\n\tif (iMouse.z > 0.5) {\n\t\tfloat dist;\n\t\tif (data.b < 0.5) {\n\t\t\tdist = length (fragCoord - iMouse.xy);\n\t\t} else {\n\t\t\tdist = segDist (fragCoord, data.rg, iMouse.xy);\n\t\t}\n\t\tif (dist < 3.0) {\n\t\t\tcollider = texture (iChannel3, vec2 (1.5, 0.5) / iResolution.xy).b;\n\t\t}\n\t}\n\tif (collider < 0.5) {\n\n\t\t// Track the particle (spiral loop from the current position)\n\t\tvec2 direction = vec2 (1.0, 0.0);\n\t\tfor (float n = 1.0; n < (2.0 * CEIL (PARTICLE_VELOCITY_MAX) + 1.0) * (2.0 * CEIL (PARTICLE_VELOCITY_MAX) + 1.0); ++n) {\n\t\t\tif (particleIdFound.x > 0.0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += direction;\n\t\t\ttrack (fragCoord, offset);\n\t\t\tif (offset.x == offset.y || (offset.x < 0.0 && offset.x == -offset.y) || (offset.x > 0.0 && offset.x == 1.0 - offset.y)) {\n\t\t\t\tdirection = vec2 (-direction.y, direction.x);\n\t\t\t}\n\t\t}\n\n\t\t// Spawn a new particle?\n\t\tif (particleIdFound.x < 0.0 && fragCoord == floor (PARTICLE_SPAWN_POSITION) + 0.5) {\n\t\t\tvec2 particleId = 0.5 + floor (iResolution.xy * rand (iTime));\n\t\t\tvec2 particlePosition = texture (iChannel1, particleId / iResolution.xy).ba;\n\t\t\tif (particlePosition == fragCoord) {\n\t\t\t\tparticleIdFound = particleId;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the fragment\n\tfragColor = vec4 (particleIdFound, particleVelocity, collider);\n}",
     "name": "Buf C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Handle player inputs\n\n// iChannel0 = Keyboard\n// iChannel1 = [nothing]\n// iChannel2 = [nothing]\n// iChannel3 = Buf D (inputs)\n\n#define KEY_R\t\t(vec2 (82.5, 0.5) / 256.0)\n#define KEY_LEFT\t(vec2 (37.5, 0.5) / 256.0)\n#define KEY_RIGHT\t(vec2 (39.5, 0.5) / 256.0)\n#define KEY_DOWN\t(vec2 (40.5, 0.5) / 256.0)\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n#define PI\t\t\t3.14159265359\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time\n\tif (fragCoord.x > 2.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Get the status of the reset (R) key\n\tfloat reset = texture (iChannel0, KEY_R).r;\n\n\t// Check what to do\n\tif (fragCoord.x < 1.0) {\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (iMouse.xyz, reset);\n\t} else {\n\n\t\t// Set the direction of the gravity\n\t\tfloat gravityDirection;\n\t\tfloat gravityTimer;\n\t\tif (iFrame == 0 || reset > 0.5) {\n\n\t\t\t// Reset the gravity\n\t\t\tgravityDirection = -PI * 0.5;\n\t\t\tgravityTimer = 0.0;\n\t\t} else {\n\n\t\t\t// Get the current values\n\t\t\tvec2 data = texture (iChannel3, fragCoord / iResolution.xy).rg;\n\t\t\tgravityDirection = data.r;\n\t\t\tgravityTimer = data.g;\n\n\t\t\t// Get the status of the left, right and down keys\n\t\t\tfloat keyLeft = texture (iChannel0, KEY_LEFT).r;\n\t\t\tfloat keyRight = texture (iChannel0, KEY_RIGHT).r;\n\t\t\tfloat keyDown = texture (iChannel0, KEY_DOWN).r;\n\t\t\tif (keyLeft + keyRight + keyDown < 0.5) {\n\t\t\t\tgravityTimer = max (0.0, gravityTimer - iTimeDelta * 5.0);\n\t\t\t} else {\n\t\t\t\tif (keyLeft > 0.5) {\n\t\t\t\t\tgravityDirection -= PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (keyRight > 0.5) {\n\t\t\t\t\tgravityDirection += PI * 0.5 * iTimeDelta;\n\t\t\t\t} else if (gravityTimer == 0.0) {\n\t\t\t\t\tgravityDirection += PI;\n\t\t\t\t}\n\t\t\t\tgravityTimer = 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// Get the status of the space key\n\t\tfloat keySpace = texture (iChannel0, KEY_SPACE).r;\n\n\t\t// Update the fragment\n\t\tfragColor = vec4 (gravityDirection, gravityTimer, 1.0 - keySpace, 0.0);\n\t}\n}",
     "name": "Buf D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XlyGDm",
    "date": "1474875905",
    "viewed": 626,
    "name": "Diamond ring",
    "description": "Rework of [url=https://www.shadertoy.com/view/ltfXDM]A lonely diamond[/url].",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "transparency",
     "diamond"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Global rendering switch\n//#define FAST\n\n// Rendering parameters\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t100\n#define LIGHT\t\t\t\tvec3 (-1.0, 0.5, 0.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.8\n#define DIAMOND_FACES\t\t8.0\n#define RING_ROTATE\t\t\tPI * 0.465\n#define RING_TRANSLATE\t\t3.0\n#define TRAY_HEIGHT\t\t\t1.3\n\n// Rendering options (for those who have a slow GPU)\n#define PROPAGATION\n#ifndef FAST\n\t#define DISPERSION\n\t#define COVER\n#endif\n\n// Macros used to handle color channels\n#ifdef DISPERSION\n\t#define COLOR float\n\t#define CHANNEL(x) dot (x, channel)\n#else\n\t#define COLOR vec3\n\t#define CHANNEL(x) x\n#endif\n\n// Math constants\n#define DELTA\t0.01\n#define PI\t\t3.14159265359\n\n// Rotation on the X axis\nvec3 rotateX (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\n}\n\n// Rotation on the Y axis\nvec3 rotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n// Materials\nstruct Material {\n\tvec3 color;\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\n\tvec3 refractIndex; // not used if behavior < 0.0\n};\nMaterial getMaterial (in int materialIndex) {\n\tMaterial material;\n\tif (materialIndex == 0) { // Ring\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.8), -0.5, vec3 (1.50, 1.55, 1.60));\n\t} else if (materialIndex == 1) { // Diamond\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.7, vec3 (2.407, 2.426, 2.451));\n\t} else if (materialIndex == 2) { // Tray\n\t\tmaterial = Material (vec3 (0.5, 0.5, 0.7), -0.4, vec3 (1.50, 1.55, 1.60));\n\t} else { // materialIndex == 3 // Cover\n\t\tmaterial = Material (vec3 (1.0, 1.0, 1.0), 0.8, vec3 (1.50, 1.55, 1.60));\n\t}\n\treturn material;\n}\n\n// Distance to the ring\nfloat getDistanceRing (in vec3 p) {\n\tvec2 q = vec2 (length (p.xy) - 7.8, p.z);\n\tfloat d1 = max (length (q) - 0.6, -0.2 - q.x);\n\tfloat d2 = length (max (abs (vec3 (abs (p.x), p.y, abs (p.z)) - vec3 (0.7, 8.2, 0.7)) - vec3 (0.1, 0.5, 0.1), 0.0)) - 0.1;\n\treturn min (d1, d2);\n}\n\n// Distance to the diamond\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\nfloat getDistanceDiamond (in vec3 p) {\n\tp.y -= 10.0;\n\tfloat topCut = p.y - 1.0;\n\tfloat angleStep = PI / DIAMOND_FACES;\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tvec3 q = rotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.5;\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\n\tq = rotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\n\tq = rotateY (p, angle);\n\tfloat topB = dot (q, normalTopB) - 1.85;\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\n// Distance to the tray\nfloat getDistanceTray (in vec3 p) {\n\tp.y += TRAY_HEIGHT;\n\tfloat d = length (p.xz);\n\treturn max (min (d - 4.0, max (d - 17.0, -p.y - 1.0)), p.y);\n}\n\n// Distance to the cover\nfloat getDistanceCover (in vec3 p) {\n\tp.y += TRAY_HEIGHT + 4.0;\n\tfloat d = length (p) - 17.0;\n\treturn max (max (d, -d - 1.0), -p.y + 3.5);\n}\n\n// Distance to a given material\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\n\tfloat materialDist;\n\tif (materialIndex == 0) {\n\t\tmaterialDist = getDistanceRing (q);\n\t} else if (materialIndex == 1) {\n\t\tmaterialDist = getDistanceDiamond (q);\n\t} else if (materialIndex == 2) {\n\t\tmaterialDist = getDistanceTray (p);\n\t#ifdef COVER\n\t} else { // materialIndex == 3\n\t\tmaterialDist = getDistanceCover (p);\n\t#endif\n\t}\n\treturn materialDist;\n}\n\n// Distance to the scene\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\n\n\t// Air\n\tmaterialTo = -1;\n\tfloat sceneDist = RAY_LENGTH_MAX;\n\n\t// Ring\n\tfloat materialDist = getDistanceRing (q);\n\tMATERIAL_PROCESS (0)\n\n\t// Diamond\n\tmaterialDist = getDistanceDiamond (q);\n\tMATERIAL_PROCESS (1)\n\n\t// Tray\n\tmaterialDist = getDistanceTray (p);\n\tMATERIAL_PROCESS (2)\n\n\t// Cover\n\t#ifdef COVER\n\tmaterialDist = getDistanceCover (p);\n\tMATERIAL_PROCESS (3)\n\t#endif\n\n\t// Return the distance\n\treturn sceneDist;\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p, in int materialIndex) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\n\n\t// Check the behavior of the material\n\tMaterial material = getMaterial (materialTo);\n\tfloat alpha = abs (material.behavior);\n\tcolor *= 1.0 - alpha;\n\n\t// The ray continues...\n\tint materialFrom = -1;\n\tfloat refractIndexFrom = 1.0;\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tfloat refractIndexTo;\n\t\tvec3 refraction;\n\t\tif (materialTo == -1) {\n\t\t\trefractIndexTo = 1.0;\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\n\t\t} else {\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\n\t\t}\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tmaterialFrom = materialTo;\n\t\t\trefractIndexFrom = refractIndexTo;\n\t\t}\n\n\t\t// Ray marching\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\n\t\t\tnormal.w += dist;\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * dist;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (materialFrom == materialTo) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tif (materialTo == -1) {\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\n\t\t} else {\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t\t// Basic lighting\n\t\t\tmaterial = getMaterial (materialTo);\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\n\t\t\tfloat localAlpha = abs (material.behavior);\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\n\t\t\talpha *= localAlpha;\n\t\t}\n\t}\n\n\t// Get the background color\n\tCOLOR backColor = CHANNEL (texture (iChannel0, -direction).rgb);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * alpha;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 4.0));\n\n\t// Set the camera\n\tvec3 origin = (35.0 + 10.0 * cos (iTime * 0.5)) * vec3 (cos (iTime * 0.1), 0.6 + 0.5 * sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\torigin.z += 6.0;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tint materialTo = -1;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\n\t\tnormal.w += dist;\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * dist;\n\t}\n\n\t// Check whether we hit something\n\tif (materialTo == -1) {\n\t\tfragColor.rgb = texture (iChannel0, -direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\n\n\t\t// The ray continues...\n\t\t#ifdef PROPAGATION\n\t\t\t#ifdef DISPERSION\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t\t\t#else\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\n\t\t\t#endif\n\t\t#endif\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ltscz8",
    "date": "1504295338",
    "viewed": 444,
    "name": "Cloudy sky",
    "description": "Yet another cloudy sky... This is actually just a test for a possible future integration into my iOS experiment \"Flamin Stack\" (app which all the rendering is made procedurally, using fragment shaders).",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "noise",
     "clouds"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define CAMERA_FOCAL_LENGTH\t3.0\n#define CAMERA_SPEED\t\t10.0\n#define RAY_STEP_MAX\t\t100.0\n#define RAY_STEP_DIST\t\t0.3\n#define RAY_LENGTH_MAX\t\t20.0\n#define NOISE_FACTOR\t\t6.0\n#define NOISE_FREQUENCY\t\t0.4\n#define NOISE_TEXTURE_SIZE\t64.0\n#define CLOUDS_SPACING\t\t1.0\n#define DENSITY_STEP_MAX\t1.0\n#define DENSITY_FACTOR\t\t0.05\n#define COLOR_CLOUDS_A\t\tvec3 (0.2, 0.2, 0.4)\n#define COLOR_CLOUDS_B\t\tvec3 (0.95, 0.9, 1.0)\n#define COLOR_SKY_A\t\t\tvec3 (0.95, 0.95, 1.0)\n#define COLOR_SKY_B\t\t\tvec3 (0.4, 0.4, 0.6)\n#define COLORIZE\n\n// Math constants\n#define PI 3.14159265359\n\n// PRNG\nfloat rand (in vec2 seed) {\n//\tseed = mod (seed, NOISE_TEXTURE_SIZE);\n\treturn fract (sin (dot (seed, vec2 (11.9898, 78.233))) * 137.5453);\n}\n\n// Noise\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tp = floor (p);\n\tp.xy += p.z * vec2 (37.0, 17.0);\n#ifdef NOISE_TEXTURE_SIZE\n\tf.xy = texture (iChannel0, (mod (p.xy + f.xy, NOISE_TEXTURE_SIZE) + 0.5) / iResolution.xy).xy;\n#else\n\tvec2 q = p.xy - vec2 (37.0, 17.0);\n\tvec2 n = vec2 (1.0, 0.0) + 0.5;\n\tf.xy = vec2(\n\t\tmix (\n\t\t\tmix (rand (q + n.yy), rand (q + n.xy), f.x),\n\t\t\tmix (rand (q + n.yx), rand (q + n.xx), f.x),\n\t\t\tf.y\n\t\t),\n\t\tmix (\n\t\t\tmix (rand (p.xy + n.yy), rand (p.xy + n.xy), f.x),\n\t\t\tmix (rand (p.xy + n.yx), rand (p.xy + n.xx), f.x),\n\t\t\tf.y\n\t\t)\n\t);\n#endif\n\treturn mix (f.x, f.y, f.z);\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n#if 0\n\treturn noise (p) / 2.0 + noise (p * 2.0) / 4.0 + noise (p * 4.0) / 8.0;\n#else\n\treturn (noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0) / (1.0 + 1.0 / 2.0 + 1.0 / 4.0);\n#endif\n}\n\n// Distance to the scene\nfloat distScene (in vec3 p, in float noise) {\n\treturn CLOUDS_SPACING - abs (p.y + noise);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the position and orientation of the camera\n\tvec3 rayOrigin = vec3 (0.0, 1.5 * cos (iTime * 0.5), CAMERA_SPEED * iTime);\n\tfloat cameraAngleY = PI * 0.6 * cos(iTime * 0.3);\n\tvec3 cameraForward = vec3 (sin (cameraAngleY), 0.0, cos (cameraAngleY));\n\tvec3 cameraUp = vec3 (sin (iTime * 0.2), 1.0, 0.0);\n\tmat3 cameraOrientation;\n\tcameraOrientation [2] = normalize (cameraForward);\n\tcameraOrientation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraOrientation [1] = cross (cameraOrientation [2], cameraOrientation [0]);\n\tvec3 rayDirection = cameraOrientation * normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Define the colors\n\tfloat colorMix = smoothstep (-0.4, 0.4, cos (iTime * 0.2));\n\tvec3 colorClouds = mix (COLOR_CLOUDS_A, COLOR_CLOUDS_B, colorMix);\n\tvec3 colorSky = mix (COLOR_SKY_A, COLOR_SKY_B, colorMix);\n\n\t// Ray marching\n#ifdef COLORIZE\n\tvec3 color = vec3 (0.0);\n\tfloat colorCloudsValue = max (max (colorClouds.x, colorClouds.y), colorClouds.z);\n\tfloat colorCloudsSaturation = colorCloudsValue > 0.0 ? 1.0 - min (min (colorClouds.x, colorClouds.y), colorClouds.z) / colorCloudsValue : 0.0;\n#endif\n\tfloat densityTotal = 0.0;\n\tfloat rayLength = 0.0;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Compute the maximum density\n\t\tfloat densityMax = 1.0 - rayLength / max (RAY_LENGTH_MAX, RAY_STEP_MAX * RAY_STEP_DIST);\n\t\tif (densityTotal >= densityMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the distance to the scene\n\t\tvec3 p = rayOrigin + rayDirection * rayLength;\n\t\tfloat f = NOISE_FACTOR * (fbm (p * NOISE_FREQUENCY) - 0.5);\n\t\tfloat dist = distScene (p, f);\n\t\tif (dist < 0.0) {\n\n\t\t\t// Compute the local density\n\t\t\tfloat densityLocal = min (-dist, DENSITY_STEP_MAX) * DENSITY_FACTOR;\n\t\t\tdensityLocal *= densityMax - densityTotal;\n\n#ifdef COLORIZE\n\t\t\t// Update the color\n\t\t\tcolor += hsv2rgb (vec3 (noise (p * 0.2), colorCloudsSaturation, densityLocal * colorCloudsValue));\n#endif\n\n\t\t\t// Update the total density\n\t\t\tdensityTotal += densityLocal;\n\t\t}\n\n\t\t// Go ahead\n\t\trayLength += max (RAY_STEP_DIST, dist - NOISE_FACTOR);\n\t}\n#ifdef COLORIZE\n\tcolor += colorSky * (1.0 - densityTotal);\n#else\n\tvec3 color = mix (colorSky, colorClouds, densityTotal);\n#endif\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Rendering parameters\n#define NOISE_TEXTURE_SIZE\t64.0\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (11.9898, 78.233))) * 137.5453);\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time\n\tif (iFrame > 1 || fragCoord.x > (NOISE_TEXTURE_SIZE + 1.0) || fragCoord.y > (NOISE_TEXTURE_SIZE + 1.0)) {\n\t\tdiscard;\n\t}\n\n\t// Set the fragment color\n\tvec2 current = mod (fragCoord, NOISE_TEXTURE_SIZE);\n\tvec2 previous = mod (current - vec2 (37.0, 17.0), NOISE_TEXTURE_SIZE);\n\tfragColor = vec4 (rand (previous), rand (current), 1.0, 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ltGyWz",
    "date": "1535720888",
    "viewed": 252,
    "name": "Non-empty Voxel Pac-Man",
    "description": "Variation of [url=https://www.shadertoy.com/view/MlfGR4]this[/url]. Pac-Man and its friend (the ghost) are no more hollow but full, so that they look more like [url=https://upload.wikimedia.org/wikipedia/en/f/f0/PixelsOfficialPoster.jpg]this[/url]...",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voxel",
     "pacman"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n//  GGGG IIIII  AAA  N   N TTTTT     PPPP   AAA   CCCC     M   M  AAA  N   N //\n// G       I   A   A NN  N   T       P   P A   A C         MM MM A   A NN  N //\n// G  GG   I   AAAAA N N N   T       PPPP  AAAAA C     --- M M M AAAAA N N N //\n// G   G   I   A   A N  NN   T       P     A   A C         M   M A   A N  NN //\n//  GGGG IIIII A   A N   N   T       P     A   A  CCCC     M   M A   A N   N //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n\n// Parameters\n#define VOXEL_RESOLUTION\t1.0\n#define VOXEL_LIGHTING\n#define SHADOW\n#define GROUND\n#define GHOST\n#define MOUSE\n#define HSV2RGB_FAST\n\n#define CAMERA_FOCAL_LENGTH\t8.0\n#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t500.0\n#define RAY_STEP_MAX\t\t100.0\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define SHADOW_LENGTH\t\t150.0\n#define SHADOW_POWER\t\t3.0\n#define FADE_POWER\t\t\t0.7\n#define BACKGROUND\t\t\t0.7\n#define GLOW\t\t\t\t0.4\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define PI\t\t3.14159265359\n#define SQRT3\t1.73205080757\n\n// Global variable to handle the glow effect\nfloat glowCounter;\n\n// PRNG (from https://www.shadertoy.com/view/4djSRW)\nfloat rand (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.3983, 5.4427, 6.9371));\n\tseed += dot (seed.yzx, seed.xyz + vec3 (21.5351, 14.3137, 15.3219));\n\treturn fract (seed.x * seed.y * seed.z * 95.4337);\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Rounded box\n\tconst float voxelRadius = 0.25;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, out vec3 P) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Scaling\n\tp *= VOXEL_RESOLUTION;\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = VOXEL_RESOLUTION * floor (iTime * 100.0 / VOXEL_RESOLUTION);\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Giant Pac-Man\n\tfloat body = length (p);\n\tfloat eyes = 6.0 - length (vec3 (abs (p.x) - 12.5, p.y - 19.5, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.075 + 0.065 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body - 32.0, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, pacMan > 29.0 - body ? 0.13 : 1.0);\n\tP = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0, -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = (q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1)) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\t#ifdef GHOST\n\tv = VOXEL_RESOLUTION * floor ((110.0 + 40.0 * cos (iTime * 3.0)) / VOXEL_RESOLUTION);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\teyes = 8.0 - length (vec3 (abs (q.x) - 12.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body - 28.0, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, ghost > 25.0 - body ? 0.76 : 1.0);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Scaling\n\td.x /= VOXEL_RESOLUTION;\n\treturn d;\n}\n\n// Distance to the (voxelized?) scene\nvec4 dist (inout vec3 p, in vec3 ray, in float voxelized, in float rayLengthMax) {\n\tvec3 P = p;\n\tvec2 d = vec2 (1e10, 0.0);\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\td.x = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n\t\t\td = distScene (floor (p + 0.5), P);\n\t\t\tif (d.x < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\td.x = max (rayLengthInVoxel - rayLength, DELTA - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\td.x = DELTA + dNext;\n\t\t\t}\n\t\t} else {\n\t\t\td = distScene (p, P);\n\t\t\tif (voxelized > 0.5) {\n\t\t\t\tif (d.x < SQRT3 * 0.5) {\n\t\t\t\t\trayLengthCheckVoxel = rayLength + abs (d.x) + SQRT3 * 0.5;\n\t\t\t\t\td.x = max (rayLengthInVoxel - rayLength + DELTA, d.x - SQRT3 * 0.5);\n\t\t\t\t}\n\t\t\t} else if (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trayLength += d.x;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d.x * ray;\n\t}\n\treturn vec4 (d, rayLength, rand (P));\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, in float voxelized) {\n\tvec2 h = vec2 (DELTA, -DELTA);\n\tvec3 n;\n\tif (voxelized > 0.5) {\n\t\tp = fract (p + 0.5) - 0.5;\n\t\tn = h.xxx * distVoxel (p + h.xxx) +\n\t\t\th.xyy * distVoxel (p + h.xyy) +\n\t\t\th.yxy * distVoxel (p + h.yxy) +\n\t\t\th.yyx * distVoxel (p + h.yyx);\n\t} else {\n\t\tn = h.xxx * distScene (p + h.xxx, n).x +\n\t\t\th.xyy * distScene (p + h.xyy, n).x +\n\t\t\th.yxy * distScene (p + h.yxy, n).x +\n\t\t\th.yyx * distScene (p + h.yyx, n).x;\n\t}\n\treturn normalize (n);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\t// Define the rendering mode\n\tfloat modeTiming = iTime * 0.234;\n\tfloat modeAngle = PI * cos (iTime * 0.2);\n\tmodeAngle = dot (frag - vec2 (cos (iTime * 2.0), 0.0), vec2 (cos (modeAngle), sin (modeAngle)));\n\tfloat modeVoxel = step (0.5, fract (modeTiming / (4.0 * PI)));\n\tmodeTiming = cos (modeTiming);\n\tfloat mode3D = smoothstep (0.8, 0.5, modeTiming);\n\tfloat modeSwitch = smoothstep (0.995, 1.0, modeTiming) + smoothstep (0.02, 0.0, abs (modeAngle)) * modeVoxel;\n\tmodeVoxel = 1.0 + (step (0.0, modeAngle) - 1.0) * modeVoxel;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, mix (12.0, CAMERA_FOCAL_LENGTH, mode3D)));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\t#ifdef MOUSE\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n\t#endif\n\tyawAngle = mix (PI * 1.5, yawAngle, mode3D);\n\tpitchAngle *= mode3D;\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = mix (400.0, 200.0 + 80.0 * cos (iTime * 0.8), mode3D);\n\tvec3 origin = (vec3 (0.0, 0.0, 80.0 * sin (iTime * 0.2) - 20.0) - cameraOrientation [2] * cameraDist) / VOXEL_RESOLUTION;\n\n\t// Compute the distance to the scene\n\tglowCounter = 0.0;\n\tvec4 d = dist (origin, ray, modeVoxel, RAY_LENGTH_MAX / VOXEL_RESOLUTION);\n\n\t// Set the background color\n\tvec3 finalColor = hsv2rgb (vec3 (0.2 * ray.y + 0.4 * modeVoxel - 0.37, 1.0, mode3D * BACKGROUND));\n\tvec3 glowColor = GLOW * vec3 (1.0, 0.3, 0.0) * glowCounter / RAY_STEP_MAX;\n\tif (d.x < DELTA) {\n\n\t\t// Set the object color\n\t\tvec3 color = d.y != 1.0 ? hsv2rgb (vec3 (d.y + 0.1 * d.w * modeVoxel, 0.5 + 0.5 * modeVoxel, 1.0)) : vec3 (0.0);\n\n\t\t// Lighting\n\t\tvec3 l = normalize (mix (vec3 (1.0, 0.0, 0.0), vec3 (1.25 + cos (iTime * 0.2), 1.0, 1.0), mode3D));\n\t\t#ifdef VOXEL_LIGHTING\n\t\tif (modeVoxel > 0.5) {\n\t\t\tvec3 n = normal (floor (origin + 0.5), 0.0);\n\t\t\tfloat diffuse = max (0.0, dot (n, l));\n\t\t\tfloat specular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\t\t}\n\t\t#endif\n\t\tvec3 n = normal (origin, modeVoxel);\n\t\tfloat diffuse = dot (n, l);\n\t\tfloat specular;\n\t\tif (diffuse < 0.0) {\n\t\t\tdiffuse = 0.0;\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\t#ifdef SHADOW\n\t\t\torigin += n * DELTA * 2.0;\n\t\t\tvec4 shadow = dist (origin, l, modeVoxel, SHADOW_LENGTH / VOXEL_RESOLUTION);\n\t\t\tif (shadow.x < DELTA) {\n\t\t\t\tshadow.z = pow (min (1.0, shadow.z * VOXEL_RESOLUTION / SHADOW_LENGTH), SHADOW_POWER);\n\t\t\t\tdiffuse *= shadow.z;\n\t\t\t\tspecular *= shadow.z;\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t\t// Fading\n\t\tfloat fade = pow (max (0.0, 1.0 - d.z * VOXEL_RESOLUTION / RAY_LENGTH_MAX), FADE_POWER);\n\t\tfinalColor = mix (finalColor, color, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = mix (pow (finalColor, vec3 (GAMMA)) + glowColor, vec3 (1.0), modeSwitch);\n\tfragColor = vec4 (finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dXfRX",
    "date": "1588690590",
    "viewed": 236,
    "name": "2D FBM example",
    "description": "Basic 2D FBM example in reply to [url=https://www.facebook.com/groups/IndieGameDevs/permalink/10156876829611573/]this Facebook post[/url].\nUse the mouse to zoom & pan.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fbm"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// This is a very basic 2D FBM example in reply to this Facebook post:\n// https://www.facebook.com/groups/IndieGameDevs/permalink/10156876829611573/\n// Comment out line 26 to get a triangular look.\n\n#define SPEED\t\t0.2\n#define SCALE\t\t3.0\n#define WIDTH\t\t0.005\n#define DX\t\t\t0.001\n#define STAR_SIZE\t0.005\n\n// PRNG (1D)\nfloat rand (in float seed) {\n\treturn fract (sin (seed * 12.9898) * 137.5453);\n}\n\n// PRNG (2D)\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// Noise\nfloat noise (in float p) {\n\tfloat f = fract (p);\n//\tf = f * f * (3.0 - 2.0 * f); // Comment this to get a triangular look.\n\tp = floor (p);\n\treturn mix (rand (p), rand (p + 1.0), f);\n}\n\n// FBM\nfloat fbm (in float p) {\n\tp *= SCALE;\n\treturn (noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0) / (1.0 + 1.0 / 2.0 + 1.0 / 4.0);\n}\n\n// Main\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Define the local coordinates\n\tvec2 uv = fragCoord / iResolution.y;\n\tuv.x -= iMouse.x / iResolution.y;\n\tuv *= 1.0 + iMouse.y / iResolution.y;\n\tuv.x += iTime * SPEED;\n\n\t// Call the FBM function to define the profile of the mountain\n\tfloat y = fbm (uv.x);\n\n\t// Compute the distance of the fragment to the mountain, to draw a nice line\n#ifdef DX\n\tfloat dy = (fbm (uv.x + DX) - fbm (uv.x - DX)) / (2.0 * DX);\n#else\n\tfloat dy = dFdx (y) / dFdx (uv.x);\n#endif\n\tfloat dist = abs (uv.y - y) / sqrt (1.0 + dy * dy);\n\tfloat mountain = smoothstep (WIDTH * 1.1, WIDTH, dist);\n\n\t// Add some (blocky) stars above the mountain\n\tfloat star = step (0.995, rand (floor (uv / STAR_SIZE)));\n\tstar *= step (y, uv.y) * step (WIDTH, dist);\n\n\t// Final color\n\tfragColor = vec4 (mountain + star, star, star, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WlscWj",
    "date": "1593109049",
    "viewed": 107,
    "name": "Star demo",
    "description": "A very basic star shape, for educational purposes (with step by step explanations on how things are done).",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "star"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI\t\t\t3.14159265358979\n#define STEPS\t\t5.0\n#define RADIUS\t\t0.8\n#define SLOPE\t\t2.5\n#define THICKNESS\t0.08\n#define AA\t\t\t0.01\n#define REPEAT\t\t2.0\n\nmat2 rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat starDist (in vec2 p)\n{\n\t// Divide the plan in STEPS sectors\n\tconst float arc = 2.0 * PI / STEPS;\n\tp *= rotate (arc * floor (atan (p.y, p.x) / arc + 0.5));\n\n\t// Compute the signed distance to the triangle edge (there is one triangle per sector)\n\treturn (p.x + abs (p.y) * SLOPE - RADIUS) / sqrt (1.0 + SLOPE * SLOPE);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalization of the fragment coordinates\n\tfragCoord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\t// Define the strip pattern\n\tfloat strip = smoothstep (0.3 - AA * 10.0, 0.3 + AA * 10.0, cos (fragCoord.y * 40.0 + sin (fragCoord.x * 20.0) + iTime * 10.0));\n\n\t// Translation of the plan\n\tvec2 p = fragCoord + vec2 (0.5 * cos (iTime * 0.7), 0.2 * sin (iTime * 1.4));\n\n\t// Rotation of the plan\n\tp *= rotate (iTime);\n\n\t// Zoom of the plan\n\tfloat zoom = 1.0 + 0.5 * cos (iTime * 1.8);\n\tp /= zoom;\n\n\t// Consider the plan is a grid of squares\n\tp = p / REPEAT + 0.5;\n\tvec2 id = floor (p);\n\tp = REPEAT * (fract (p) - 0.5);\n\n\t// Rotation of the square's contents (the angle depends on the position of the square in the grid)\n\tp *= rotate (iTime * (id.x * 2.0 + id.y * 3.0));\n\n\t// Compute the signed distance to the star shape within each square\n\tfloat star = starDist (p);\n\n\t// For the fun, add little stars in the big stars, using the same approach as above\n\tp /= 0.1;\n\tp = REPEAT * (fract (p / REPEAT + 0.5) - 0.5);\n\tstar = max (star, -abs (starDist (p)));\n\n\t// What about adding other stars in the background? (Again, using the same approach as above but starting with \"fragCoord\") \n\tp = fragCoord * rotate (-iTime * 0.6) / 0.3;\n\tp = REPEAT * (fract (p / REPEAT + 0.5) - 0.5);\n\tstar = min (star, max (-star,  starDist (p)));\n\n\t// Display the stars and strips\n\tconst float halfThickness = THICKNESS * 0.5;\n\tfloat halfThicknessAA = halfThickness + AA / zoom;\n\tfloat redGradient =  0.7 + 0.3 * cos (PI * fragCoord.x * iResolution.y / iResolution.x);\n\tfragColor = vec4 (\n\t\tsmoothstep (-halfThicknessAA, -halfThickness, star) * redGradient,\n\t\tsmoothstep (halfThicknessAA, halfThickness, abs (star)),\n\t\tsmoothstep (-halfThickness, -halfThicknessAA, star) * strip,\n\t\t1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WtjyWh",
    "date": "1594233103",
    "viewed": 239,
    "name": "Basic optical illusion",
    "description": "Simple optical illusion.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "illusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage (out vec4 a, vec2 b) {\n\tvec2 c = iResolution.xy, d = (b + b - c) / c.y * 6.,\t/* Normalization of the fragment coordinates\t*/\n\t\te = d + 5. * cos (vec2 (0., 1.57) + iTime);\t\t\t/* Position of the little black circle\t\t\t*/\n\tc = floor (d) * .5;\t\t\t\t\t\t\t\t\t\t/* The plan is seen as a grid of squares\t\t*/\n\ta = vec4 (0., .5 + .5 * fract (c.x + c.y), .5, 1.);\t\t/* Squares' colors (light/dark green)\t\t\t*/\n\tc = round (d) / .1;\t\t\t\t\t\t\t\t\t\t/* Get the ID of the green squares' corners\t\t*/\n\ta = mix (a, vec4 (1., vec2 (cos (c.x + c.y) > 0.), 1.),\t/* Crosses' colors are cosines of these IDs\t\t*/\n\t\tsmoothstep (.4, .41, dot (d = fract (d) - .5, d)))\t/* Add crosses in the green squares' corners\t*/\n\t\t* smoothstep (0., .1, dot (e, e));\t\t\t\t\t/* Little black circle\t\t\t\t\t\t\t*/\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tt2yWV",
    "date": "1595439666",
    "viewed": 154,
    "name": "Basic Mandelbrot set display",
    "description": "Basic Mandelbrot set display.\n\nAn anti-aliased version can be seen [url=https://www.shadertoy.com/view/Wl2cDt]here[/url].",
    "likes": 0,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "mandelbrot"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define C1\tvec2 (0.2, 0.55)\n#define C2\tvec2 (-0.743644, 0.131826)\n#define N\t900.0\n#define PI\t3.14159265358979\n\nmat2 Rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat Mandelbrot (in vec2 c)\n{\n\tvec2 m;\n\n\t#ifndef NO_OPTIM\n\tm = vec2 (c.x + 1.0, c.y);\n\tif (dot (m, m) < 0.0625) {\n\t\treturn 1.0;\n\t}\n\n\tm = vec2 (c.x - 0.25, c.y);\n\tfloat l = dot (m, m);\n\tif (c.x < sqrt (l) - 2.0 * l + 0.25) {\n\t\treturn 1.0;\n\t}\n\t#endif\n\n\tm = c;\n\tfor (float n = 0.0; n < N; ++n) {\n\t\tif (dot (m, m) > 256.0) {\n\t\t\treturn n / N;\n\t\t}\n\t\tm = vec2 (m.x * m.x - m.y * m.y, 2.0 * m.x * m.y) + c;\n\t}\n\treturn 1.0;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\tfloat time = iTime * 0.1;\n\tfloat zoom = 1.5 * pow (0.5, 18.0 * (0.5 - 0.5 * cos (time * 2.0)));\n\tfloat angle = PI * 6.0 * cos (time);\n\tvec2 translate = mix (C1, C2, smoothstep (-0.4, 0.4, sin (time)));\n\n\tc = zoom * Rotate (angle) * c + translate;\n\tfloat m = Mandelbrot (c);\n\tfragColor = vec4 (m, pow (m, 0.6), pow (m, 0.3), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wl2cDt",
    "date": "1595717776",
    "viewed": 178,
    "name": "Basic 2 pass AA",
    "description": "Basic anti-aliasing using 2 buffers (1 buffer being shifted by 0.5 pixel, and fetched with linear filtering).\nClick to disable it.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "aa"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene normally\n\tfragColor = Render (fragCoord, iResolution.xy, iTime);\n\n\t// Mix with the scene shifted by half a pixel\n\t// Notes:\n\t// - Linear filtering has to be used to fetch the color\n\t// - A value of 0.8 for the mix returns the actual average of the 5 sampling points,\n\t//   while 0.5 acts more like a Gaussian filter\n\tif (iMouse.z < 0.5) {\n\t\tfragColor = mix (fragColor, texture (iChannel0, (fragCoord + 0.5) / iResolution.xy), 0.5);\n\t}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene shifted by half a pixel\n\tif (iMouse.z < 0.5) {\n\t\tfragColor = Render (fragCoord - 0.5, iResolution.xy, iTime);\n\t}\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Example: basic Mandelbrot set display (from https://www.shadertoy.com/view/tt2yWV)\n#define C vec2 (-0.743603, 0.1318205)\n#define N 900.0\n\nmat2 Rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat Mandelbrot (in vec2 c)\n{\n\tvec2 m = c;\n\tfor (float n = 0.0; n < N; ++n) {\n\t\tif (dot (m, m) > 4.0) {\n\t\t\treturn n / N;\n\t\t}\n\t\tm = vec2 (m.x * m.x - m.y * m.y, 2.0 * m.x * m.y) + c;\n\t}\n\treturn 1.0;\n}\n\nvec4 Render (in vec2 fragCoord, in vec2 resolution, in float time)\n{\n\tvec2 c = (2.0 * fragCoord - resolution) / resolution.y;\n\tfloat zoom = pow (0.5, 18.0 * (0.72 - 0.28 * cos (time * 0.2)));\n\tfloat m = Mandelbrot (zoom * Rotate (time * 0.3) * c + C);\n\treturn vec4 (m, pow (m, 0.6), pow (m, 0.3), 1.0);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wtXBRj",
    "date": "1597140024",
    "viewed": 224,
    "name": "AA Voxel Pac-Man",
    "description": "Mix of [url=https://www.shadertoy.com/view/Wl2cDt]Basic 2 pass AA[/url] and [url=https://www.shadertoy.com/view/ltGyWz]Voxel Pac-Man[/url].\n\nUse the mouse to rotate when in 3D.",
    "likes": 18,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voxel",
     "pacman",
     "aa"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene normally\n\tfragColor = Render (fragCoord, iResolution.xy, iTime, iMouse.xy);\n\n\t// Mix with the scene shifted by half a pixel\n\t// Notes:\n\t// - Linear filtering has to be used to fetch the color\n\t// - A value of 0.8 for the mix returns the actual average of the 5 sampling points,\n\t//   while 0.5 acts more like a Gaussian filter\n\tfragColor = mix (fragColor, texture (iChannel0, (fragCoord + 0.5) / iResolution.xy), 0.5);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene shifted by half a pixel\n\tfragColor = Render (fragCoord - 0.5, iResolution.xy, iTime, iMouse.xy);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Giant Voxel Pac-Man (from https://www.shadertoy.com/view/ltGyWz)\n\n// Parameters\n#define VOXEL_RESOLUTION\t1.0\n#define CAMERA_FOCAL_LENGTH\t8.0\n#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t500.0\n#define RAY_STEP_MAX\t\t100.0\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define SHADOW_LENGTH\t\t150.0\n#define SHADOW_POWER\t\t3.0\n#define FADE_POWER\t\t\t0.7\n#define BACKGROUND\t\t\t0.7\n#define GLOW\t\t\t\t0.4\n#define GAMMA\t\t\t\t0.8\n\n//#define GROUND\n\n// Math constants\n#define PI\t\t3.14159265359\n#define SQRT3\t1.73205080757\n\n// Global variables\nfloat time;\nfloat glowCounter;\n\n// PRNG (from https://www.shadertoy.com/view/4djSRW)\nfloat rand (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.3983, 5.4427, 6.9371));\n\tseed += dot (seed.yzx, seed.xyz + vec3 (21.5351, 14.3137, 15.3219));\n\treturn fract (seed.x * seed.y * seed.z * 95.4337);\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Rounded box\n\tconst float voxelRadius = 0.25;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, out vec3 P) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Scaling\n\tp *= VOXEL_RESOLUTION;\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = VOXEL_RESOLUTION * floor (time * 100.0 / VOXEL_RESOLUTION);\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Giant Pac-Man\n\tfloat body = length (p);\n\tfloat eyes = 6.0 - length (vec3 (abs (p.x) - 12.5, p.y - 19.5, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.075 + 0.065 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body - 32.0, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, pacMan > 29.0 - body ? 0.13 : 1.0);\n\tP = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0, -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = (q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1)) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\tv = VOXEL_RESOLUTION * floor ((110.0 + 40.0 * cos (time * 3.0)) / VOXEL_RESOLUTION);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\teyes = 8.0 - length (vec3 (abs (q.x) - 12.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body - 28.0, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, ghost > 25.0 - body ? 0.76 : 1.0);\n\t\tP = q;\n\t}\n\n\t// Scaling\n\td.x /= VOXEL_RESOLUTION;\n\treturn d;\n}\n\n// Distance to the (voxelized?) scene\nvec4 dist (inout vec3 p, in vec3 ray, in float voxelized, in float rayLengthMax) {\n\tvec3 P = p;\n\tvec2 d = vec2 (1e10, 0.0);\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\td.x = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n\t\t\td = distScene (floor (p + 0.5), P);\n\t\t\tif (d.x < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\td.x = max (rayLengthInVoxel - rayLength, DELTA - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\td.x = DELTA + dNext;\n\t\t\t}\n\t\t} else {\n\t\t\td = distScene (p, P);\n\t\t\tif (voxelized > 0.5) {\n\t\t\t\tif (d.x < SQRT3 * 0.5) {\n\t\t\t\t\trayLengthCheckVoxel = rayLength + abs (d.x) + SQRT3 * 0.5;\n\t\t\t\t\td.x = max (rayLengthInVoxel - rayLength + DELTA, d.x - SQRT3 * 0.5);\n\t\t\t\t}\n\t\t\t} else if (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trayLength += d.x;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d.x * ray;\n\t}\n\treturn vec4 (d, rayLength, rand (P));\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, in float voxelized) {\n\tvec2 h = vec2 (DELTA, -DELTA);\n\tvec3 n;\n\tif (voxelized > 0.5) {\n\t\tp = fract (p + 0.5) - 0.5;\n\t\tn = h.xxx * distVoxel (p + h.xxx) +\n\t\t\th.xyy * distVoxel (p + h.xyy) +\n\t\t\th.yxy * distVoxel (p + h.yxy) +\n\t\t\th.yyx * distVoxel (p + h.yyx);\n\t} else {\n\t\tn = h.xxx * distScene (p + h.xxx, n).x +\n\t\t\th.xyy * distScene (p + h.xyy, n).x +\n\t\t\th.yxy * distScene (p + h.yxy, n).x +\n\t\t\th.yyx * distScene (p + h.yyx, n).x;\n\t}\n\treturn normalize (n);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\n// Main function\nvec4 Render (in vec2 fragCoord, in vec2 iResolution, in float iTime, in vec2 iMouse) {\n\n\t// Make the time global\n\ttime = iTime;\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution) / iResolution.y;\n\n\t// Define the rendering mode\n\tfloat modeTiming = iTime * 0.234;\n\tfloat modeAngle = PI * cos (iTime * 0.2);\n\tmodeAngle = dot (frag - vec2 (cos (iTime * 2.0), 0.0), vec2 (cos (modeAngle), sin (modeAngle)));\n\tfloat modeVoxel = step (0.5, fract (modeTiming / (4.0 * PI)));\n\tmodeTiming = cos (modeTiming);\n\tfloat mode3D = smoothstep (0.8, 0.5, modeTiming);\n\tfloat modeSwitch = smoothstep (0.995, 1.0, modeTiming) + smoothstep (0.02, 0.0, abs (modeAngle)) * modeVoxel;\n\tmodeVoxel = 1.0 + (step (0.0, modeAngle) - 1.0) * modeVoxel;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, mix (12.0, CAMERA_FOCAL_LENGTH, mode3D)));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n\n\tyawAngle = mix (PI * 1.5, yawAngle, mode3D);\n\tpitchAngle *= mode3D;\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = mix (400.0, 200.0 + 80.0 * cos (iTime * 0.8), mode3D);\n\tvec3 origin = (vec3 (0.0, 0.0, 80.0 * sin (iTime * 0.2) - 20.0) - cameraOrientation [2] * cameraDist) / VOXEL_RESOLUTION;\n\n\t// Compute the distance to the scene\n\tglowCounter = 0.0;\n\tvec4 d = dist (origin, ray, modeVoxel, RAY_LENGTH_MAX / VOXEL_RESOLUTION);\n\n\t// Set the background color\n\tvec3 finalColor = hsv2rgb (vec3 (0.53 - 0.1 * ray.y + 0.1 * modeVoxel, 1.0, mode3D * BACKGROUND));\n\tvec3 glowColor = GLOW * vec3 (1.0, 0.3, 0.0) * glowCounter / RAY_STEP_MAX;\n\tif (d.x < DELTA) {\n\n\t\t// Set the object color\n\t\tvec3 color = d.y != 1.0 ? hsv2rgb (vec3 (d.y + 0.1 * d.w * modeVoxel, 0.5 + 0.5 * modeVoxel, 1.0)) : vec3 (0.0);\n\n\t\t// Lighting\n\t\tvec3 l = normalize (mix (vec3 (1.0, 0.0, 0.0), vec3 (1.25 + cos (iTime * 0.2), 1.0, 1.0), mode3D));\n\t\tif (modeVoxel > 0.5) {\n\t\t\tvec3 n = normal (floor (origin + 0.5), 0.0);\n\t\t\tfloat diffuse = max (0.0, dot (n, l));\n\t\t\tfloat specular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\t\t}\n\t\tvec3 n = normal (origin, modeVoxel);\n\t\tfloat diffuse = dot (n, l);\n\t\tfloat specular;\n\t\tif (diffuse < 0.0) {\n\t\t\tdiffuse = 0.0;\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\torigin += n * DELTA * 2.0;\n\t\t\tvec4 shadow = dist (origin, l, modeVoxel, SHADOW_LENGTH / VOXEL_RESOLUTION);\n\t\t\tif (shadow.x < DELTA) {\n\t\t\t\tshadow.z = pow (min (1.0, shadow.z * VOXEL_RESOLUTION / SHADOW_LENGTH), SHADOW_POWER);\n\t\t\t\tdiffuse *= shadow.z;\n\t\t\t\tspecular *= shadow.z;\n\t\t\t}\n\t\t}\n\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t\t// Fading\n\t\tfloat fade = pow (max (0.0, 1.0 - d.z * VOXEL_RESOLUTION / RAY_LENGTH_MAX), FADE_POWER);\n\t\tfinalColor = mix (finalColor, color, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = mix (pow (finalColor, vec3 (GAMMA)) + glowColor, vec3 (1.0), modeSwitch);\n\treturn vec4 (finalColor, 1.0);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsGBRR",
    "date": "1606381166",
    "viewed": 438,
    "name": "Rings of delusion",
    "description": "Nothing moves...",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "optical",
     "illusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Inspired by: https://twitter.com/jagarikin/status/1331409504953540613\n\n#define PI\t\t\t3.14159265358979\n#define RADIUS\t\t0.5\n#define THICKNESS\t0.1\n#define SPEED\t\t10.0\n#define STRIPS\t\t3.0\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.5 + 0.05 * cos (p.x * 50.0) * cos (p.y * 50.0)), 1.0);\n\n\t// Select the animation\n\tfloat select = floor (6.0 * fract (iTime * 0.03 + step (0.0, p.x) / 3.0));\n\n\t// Display the rings & marker\n\tp.x = abs (p.x) - RADIUS * 1.6;\n\n\tfloat d = length (p) - RADIUS;\n\tfloat a = atan (p.y, p.x);\n\tfloat t = STRIPS * (a + iTime * SPEED);\n\n\tvec4 c = vec4 (1.0, smoothstep (-0.05, 0.05, cos (t)), 0.0, 1.0);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, abs (d) - THICKNESS));\n\n\tfloat m;\n\tfloat f;\n\tif (select < 1.5) {\n\t\tm = abs (length (p) - 0.15 + 0.1 * select);\n\t\tf = 1.0;\n\t\tt -= PI * (0.5 + select);\n\t} else {\n\t\tfloat dir = PI * 0.5 * (select - 2.0);\n\t\tvec2 tip = 0.15 * vec2 (-sin (dir), cos (dir));\n\t\tm = segDist (p, -tip * 0.5, tip);\n\t\tm = min (m, segDist (p, tip, tip * 0.7 + 0.3 * vec2 (tip.y, -tip.x)));\n\t\tm = min (m, segDist (p, tip, tip * 0.7 - 0.3 * vec2 (tip.y, -tip.x)));\n\t\tf = abs (sin (a + dir));\n\t\tt -= PI * 0.5 * sign (dot (p, tip));\n\t}\n\tfragColor.rgb *= smoothstep (-halfPixel, halfPixel, m - 0.02);\n\n\tc.g = smoothstep (-0.05, 0.05, cos (t));\n\tfragColor = mix (fragColor, c, f * smoothstep (halfPixel, -halfPixel, abs (d - THICKNESS) - 2.0 * halfPixel));\n\tc.g = 1.0 - c.g;\n\tfragColor = mix (fragColor, c, f * smoothstep (halfPixel, -halfPixel, abs (d + THICKNESS) - 2.0 * halfPixel));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdKfRz",
    "date": "1606474337",
    "viewed": 245,
    "name": "Yet another illusion...",
    "description": "Nothing moves but the arrow!",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "optical",
     "illusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI\t\t\t\t3.14159265358979\n#define DISC_COUNT\t\t9.0\n#define DISC_DIST\t\t0.7\n#define DISC_RADIUS\t\t0.1\n#define HUE_SPEED\t\t0.06\n#define HUE_STEP\t\t3.0\n\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\nmat2 rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.6 + 0.05 * cos (p.x * 50.0) * cos (p.y * 50.0)), 1.0);\n\n\t// Select the direction\n\tfloat dir = sign (cos (iTime * 0.8));\n\n\t// Display the direction\n\tvec2 q = p *rotate (iTime * dir * 0.2);\n\tq.x *= dir;\n\tvec2 tip = vec2 (-0.01, 0.3);\n\tfloat d = max (abs (length (q) - tip.y), min (-q.x, q.x + q.y));\n\td = min (d, segDist (q, tip, tip + vec2 (0.05, 0.05)));\n\td = min (d, segDist (q, tip, tip + vec2 (0.05, -0.05)));\n\td -= 0.01;\n\tfragColor *= smoothstep (-halfPixel, halfPixel, d);\n\n\t// Divide the plan in DISC_COUNT sectors\n\tconst float arc = 2.0 * PI / DISC_COUNT;\n\tp *= rotate (arc * floor (atan (p.y, p.x) / arc + 0.5));\n\tp.x -= DISC_DIST;\n\n\t// Display the discs\n\tfloat h = float (iFrame) * HUE_SPEED;\n\tvec3 hsv = vec3 (h, 0.9, 0.8);\n\n\td = length (p) - DISC_RADIUS;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), step (d, 0.0));\n\n\tp.y *= dir;\n\td = max (d, -d - 2.0 * halfPixel);\n\n\thsv.x = h - HUE_STEP * HUE_SPEED;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), smoothstep (halfPixel, -halfPixel, max (d, -p.y)));\n\n\thsv.x = h + HUE_STEP * HUE_SPEED;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), smoothstep (halfPixel, -halfPixel, max (d, p.y)));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WsGfRh",
    "date": "1606494784",
    "viewed": 276,
    "name": "Runner illusion",
    "description": "Nothing moves...\n\n(Click to stop the animation.)\n\np.s.: An optimized (pre-rendered) version is [url=https://www.shadertoy.com/view/wdVBzh]here[/url].",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "optical",
     "illusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Inspired by: https://twitter.com/jagarikin/status/1329610899976437765\n\n#define PI\t\t\t3.14159265358979\n#define REPEAT\t\t0.3\n#define HEIGHT\t\t2.2\n#define THICKNESS\t0.025\n#define COLOR_SPEED\t0.04\n#define COLOR_DELAY\t4.0\n#define OUTLINE\t\t2.0\n#define DELTA\t\t0.0001\n\nvec4 color (in float t) {\n\treturn vec4 (vec3 (abs (2.0 * fract (t * COLOR_SPEED) - 1.0)), 1.0);\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nfloat charDist (in vec2 p, in float jump) {\n\tp.y -= 0.25;\n\tfloat d = length (p - vec2 (0.0, 0.1)) - 0.04;\n\td = min (d, segDist (p, vec2 (0.0, 0.1), vec2 (-0.02, -0.1)));\n\tif (jump < 0.5) {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.04, -0.15)));\n\t\td = min (d, segDist (p, vec2 (0.04, -0.15), vec2 (0.08, -0.22)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.05, -0.16)));\n\t\td = min (d, segDist (p, vec2 (-0.05, -0.16), vec2 (-0.1, -0.2)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.06, -0.03)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.03), vec2 (0.1, -0.05)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (-0.08, -0.01)));\n\t\td = min (d, segDist (p, vec2 (-0.08, -0.01), vec2 (-0.09, -0.05)));\n\t} else {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.06, -0.1)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.1), vec2 (0.04, -0.2)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.02, -0.18)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.18), vec2 (-0.06, -0.24)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.07, 0.15)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.05, 0.02)));\n\t\td = min (d, segDist (p, vec2 (0.05, 0.02), vec2 (0.11, 0.06)));\n\t}\n\treturn d - THICKNESS;\n}\n\nfloat charY (in float x) {\n\tx = floor (x / REPEAT) * REPEAT;\n\treturn max (0.0, HEIGHT - mix (-x, x * x * 0.8, step (0.0, x)));\n}\n\nfloat frameDist (in vec2 p) {\n\n\t// Vertical position of the character\n\tfloat dy = charY (p.x);\n\n\t// Distance to the stairs\n\tfloat d = p.y;\n\tif (p.x < -REPEAT * 0.5) {\n\t\tfloat dx = ceil ((p.y - HEIGHT) / REPEAT) * REPEAT;\n\t\tvec2 q = vec2 (dx - p.x, p.y - dy);\n\t\td = min (d, max (min (q.x, q.y), min (max (q.x, q.y), 0.0)));\n\t}\n\n\t// Check whether the character is in the air\n\tfloat jump = step (-REPEAT, p.x) * step (DELTA, dy);\n\n\t// Distance to the character\n\tp.x = (fract (p.x / (2.0 * REPEAT)) - 0.75) * REPEAT * 2.0;\n\tp.y -= dy;\n\treturn min (d, charDist (p, jump));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tp = 1.6 * p - vec2 (0.15, -1.2);\n\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.5), 1.0);\n\n\t// Display\n\tvec4 c = color (float (iFrame));\n\tfloat d = frameDist (p);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, d));\n\n\tif (iMouse.z < 0.5) {\n\t\tvec2 n = normalize (vec2 (frameDist (p - vec2 (DELTA, 0.0)), frameDist (p - vec2 (0.0, DELTA))) - d);\n\t\tvec2 v = normalize (vec2 (REPEAT, (charY (p.x) - charY (p.x - REPEAT)))) * step (2.0 * halfPixel * OUTLINE, p.y);\n\t\tfloat f = dot (n, v);\n\n\t\tc = color (float (iFrame) + COLOR_DELAY * sign (f));\n\t\td = abs (d - halfPixel * OUTLINE) - halfPixel * OUTLINE;\n\t\tfragColor = mix (fragColor, c, abs (f) * smoothstep (halfPixel, -halfPixel, d));\n\t}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdVBzh",
    "date": "1606599994",
    "viewed": 254,
    "name": "Runner illusion (buffered)",
    "description": "Nothing moves...\n\n(Click to stop the animation; press the space bar to change colors.)",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "optical",
     "illusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Inspired by: https://twitter.com/jagarikin/status/1329610899976437765\n\n#define COLOR_SPEED\t2.4\n#define COLOR_DELAY\t0.06\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n\nvec4 color (in float t) {\n\treturn vec4 (vec3 (abs (2.0 * fract (t * COLOR_SPEED) - 1.0)), 1.0);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tfloat run = step (iMouse.z, 0.5);\n\tmat4 m;\n\tif (texture (iChannel1, KEY_SPACE).r < 0.5) {\n\t\tvec4 background = vec4 (0.5, 0.5, 0.5, 1.0);\n\t\tm = mat4 (\n\t\t\tbackground,\n\t\t\tmix (background, color (iTime - COLOR_DELAY), run),\n\t\t\tcolor (iTime),\n\t\t\tmix (background, color (iTime + COLOR_DELAY), run)\n\t\t);\n\t} else {\n\t\tvec4 character = vec4 (0.8, 0.3, 0.3, 1.0);\n\t\tm = mat4 (\n\t\t\tcolor (iTime),\n\t\t\tcolor (iTime + COLOR_DELAY * run),\n\t\t\tcharacter,\n\t\t\tcolor (iTime - COLOR_DELAY * run)\n\t\t);\n\t}\n\tfragColor = m * texture (iChannel0, fragCoord / iResolution.xy);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI\t\t\t3.14159265358979\n#define REPEAT\t\t0.3\n#define HEIGHT\t\t2.2\n#define THICKNESS\t0.025\n#define OUTLINE\t\t2.0\n#define DELTA\t\t0.0001\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nfloat charDist (in vec2 p, in float jump) {\n\tp.y -= 0.25;\n\tfloat d = length (p - vec2 (0.0, 0.1)) - 0.04;\n\td = min (d, segDist (p, vec2 (0.0, 0.1), vec2 (-0.02, -0.1)));\n\tif (jump < 0.5) {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.04, -0.15)));\n\t\td = min (d, segDist (p, vec2 (0.04, -0.15), vec2 (0.08, -0.22)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.05, -0.16)));\n\t\td = min (d, segDist (p, vec2 (-0.05, -0.16), vec2 (-0.1, -0.2)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.06, -0.03)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.03), vec2 (0.1, -0.05)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (-0.08, -0.01)));\n\t\td = min (d, segDist (p, vec2 (-0.08, -0.01), vec2 (-0.09, -0.05)));\n\t} else {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.06, -0.1)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.1), vec2 (0.04, -0.2)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.02, -0.18)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.18), vec2 (-0.06, -0.24)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.07, 0.15)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.05, 0.02)));\n\t\td = min (d, segDist (p, vec2 (0.05, 0.02), vec2 (0.11, 0.06)));\n\t}\n\treturn d - THICKNESS;\n}\n\nfloat charY (in float x) {\n\tx = floor (x / REPEAT) * REPEAT;\n\treturn max (0.0, HEIGHT - mix (-x, x * x * 0.8, step (0.0, x)));\n}\n\nfloat frameDist (in vec2 p) {\n\n\t// Vertical position of the character\n\tfloat dy = charY (p.x);\n\n\t// Distance to the stairs\n\tfloat d = p.y;\n\tif (p.x < -REPEAT * 0.5) {\n\t\tfloat dx = ceil ((p.y - HEIGHT) / REPEAT) * REPEAT;\n\t\tvec2 q = vec2 (dx - p.x, p.y - dy);\n\t\td = min (d, max (min (q.x, q.y), min (max (q.x, q.y), 0.0)));\n\t}\n\n\t// Check whether the character is in the air\n\tfloat jump = step (-REPEAT, p.x) * step (DELTA, dy);\n\n\t// Distance to the character\n\tp.x = (fract (p.x / (2.0 * REPEAT)) - 0.75) * REPEAT * 2.0;\n\tp.y -= dy;\n\treturn min (d, charDist (p, jump));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Don't waste time (but beware of a possible change of resolution!)\n\tfragColor = texture (iChannel0, vec2 (0.5) / iResolution.xy);\n\tif (fragColor.xy != iResolution.xy) {\n\t\tfragColor.xyz = vec3 (iResolution.xy, float (iFrame));\n\t} else if (fragColor.z < float (iFrame) - 1.5) {\n\t\tdiscard;\n\t}\n\tif (p == vec2 (0.5)) {\n\t\treturn;\n\t}\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tp = 1.6 * p - vec2 (0.15, -1.2);\n\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (1.0, 0.0, 0.0, 0.0);\n\n\t// Display\n\tvec4 c = vec4 (0.0, 0.0, 1.0, 0.0);\n\tfloat d = frameDist (p);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, d));\n\n\tvec2 n = normalize (vec2 (frameDist (p - vec2 (DELTA, 0.0)), frameDist (p - vec2 (0.0, DELTA))) - d);\n\tvec2 v = normalize (vec2 (REPEAT, (charY (p.x) - charY (p.x - REPEAT)))) * step (2.0 * halfPixel * OUTLINE, p.y);\n\tfloat f = dot (n, v);\n\n\tc = vec4 (0.0, step (f, 0.0), 0.0, step (0.0, f));\n\td = abs (d - halfPixel * OUTLINE) - halfPixel * OUTLINE;\n\tfragColor = mix (fragColor, c, abs (f) * smoothstep (halfPixel, -halfPixel, d));\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  }
 ]
}